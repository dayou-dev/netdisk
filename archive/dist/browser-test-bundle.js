(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

var _uriToBlob = _interopRequireDefault(require("./uriToBlob"));

var _FileSource = _interopRequireDefault(require("./sources/FileSource"));

var _StreamSource = _interopRequireDefault(require("./sources/StreamSource"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var FileReader = /*#__PURE__*/function () {
  function FileReader() {
    _classCallCheck(this, FileReader);
  }

  _createClass(FileReader, [{
    key: "openFile",
    value: function openFile(input, chunkSize) {
      // In React Native, when user selects a file, instead of a File or Blob,
      // you usually get a file object {} with a uri property that contains
      // a local path to the file. We use XMLHttpRequest to fetch
      // the file blob, before uploading with tus.
      if ((0, _isReactNative["default"])() && input && typeof input.uri !== 'undefined') {
        return (0, _uriToBlob["default"])(input.uri).then(function (blob) {
          return new _FileSource["default"](blob);
        })["catch"](function (err) {
          throw new Error("tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. ".concat(err));
        });
      } // Since we emulate the Blob type in our tests (not all target browsers
      // support it), we cannot use `instanceof` for testing whether the input value
      // can be handled. Instead, we simply check is the slice() function and the
      // size property are available.


      if (typeof input.slice === 'function' && typeof input.size !== 'undefined') {
        return Promise.resolve(new _FileSource["default"](input));
      }

      if (typeof input.read === 'function') {
        chunkSize = Number(chunkSize);

        if (!Number.isFinite(chunkSize)) {
          return Promise.reject(new Error('cannot create source for stream without a finite value for the `chunkSize` option'));
        }

        return Promise.resolve(new _StreamSource["default"](input, chunkSize));
      }

      return Promise.reject(new Error('source object may only be an instance of File, Blob, or Reader in this environment'));
    }
  }]);

  return FileReader;
}();

exports["default"] = FileReader;

},{"./isReactNative":5,"./sources/FileSource":6,"./sources/StreamSource":7,"./uriToBlob":10}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = fingerprint;

var _isReactNative = _interopRequireDefault(require("./isReactNative"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
} // TODO: Differenciate between input types

/**
 * Generate a fingerprint for a file which will be used the store the endpoint
 *
 * @param {File} file
 * @param {Object} options
 * @param {Function} callback
 */


function fingerprint(file, options) {
  if ((0, _isReactNative["default"])()) {
    return Promise.resolve(reactNativeFingerprint(file, options));
  }

  return Promise.resolve(['tus-br', file.name, file.type, file.size, file.lastModified, options.endpoint].join('-'));
}

function reactNativeFingerprint(file, options) {
  var exifHash = file.exif ? hashCode(JSON.stringify(file.exif)) : 'noexif';
  return ['tus-rn', file.name || 'noname', file.size || 'nosize', exifHash, options.endpoint].join('/');
}

function hashCode(str) {
  /* eslint-disable no-bitwise */
  // from https://stackoverflow.com/a/8831937/151666
  var hash = 0;

  if (str.length === 0) {
    return hash;
  }

  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);

    hash = (hash << 5) - hash + _char;
    hash &= hash; // Convert to 32bit integer
  }

  return hash;
}

},{"./isReactNative":5}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
/* eslint-disable max-classes-per-file */


var XHRHttpStack = /*#__PURE__*/function () {
  function XHRHttpStack() {
    _classCallCheck(this, XHRHttpStack);
  }

  _createClass(XHRHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      return new Request(method, url);
    }
  }, {
    key: "getName",
    value: function getName() {
      return 'XHRHttpStack';
    }
  }]);

  return XHRHttpStack;
}();

exports["default"] = XHRHttpStack;

var Request = /*#__PURE__*/function () {
  function Request(method, url) {
    _classCallCheck(this, Request);

    this._xhr = new XMLHttpRequest();

    this._xhr.open(method, url, true);

    this._method = method;
    this._url = url;
    this._headers = {};
  }

  _createClass(Request, [{
    key: "getMethod",
    value: function getMethod() {
      return this._method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this._url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this._xhr.setRequestHeader(header, value);

      this._headers[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._headers[header];
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      // Test support for progress events before attaching an event listener
      if (!('upload' in this._xhr)) {
        return;
      }

      this._xhr.upload.onprogress = function (e) {
        if (!e.lengthComputable) {
          return;
        }

        progressHandler(e.loaded);
      };
    }
  }, {
    key: "send",
    value: function send() {
      var _this = this;

      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      return new Promise(function (resolve, reject) {
        _this._xhr.onload = function () {
          resolve(new Response(_this._xhr));
        };

        _this._xhr.onerror = function (err) {
          reject(err);
        };

        _this._xhr.send(body);
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this._xhr.abort();

      return Promise.resolve();
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Request;
}();

var Response = /*#__PURE__*/function () {
  function Response(xhr) {
    _classCallCheck(this, Response);

    this._xhr = xhr;
  }

  _createClass(Response, [{
    key: "getStatus",
    value: function getStatus() {
      return this._xhr.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._xhr.getResponseHeader(header);
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._xhr.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      return this._xhr;
    }
  }]);

  return Response;
}();

},{}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "DetailedError", {
  enumerable: true,
  get: function get() {
    return _error["default"];
  }
});
Object.defineProperty(exports, "HttpStack", {
  enumerable: true,
  get: function get() {
    return _httpStack["default"];
  }
});
exports.Upload = void 0;
Object.defineProperty(exports, "canStoreURLs", {
  enumerable: true,
  get: function get() {
    return _urlStorage.canStoreURLs;
  }
});
exports.defaultOptions = void 0;
Object.defineProperty(exports, "enableDebugLog", {
  enumerable: true,
  get: function get() {
    return _logger.enableDebugLog;
  }
});
exports.isSupported = void 0;

var _upload = _interopRequireDefault(require("../upload"));

var _noopUrlStorage = _interopRequireDefault(require("../noopUrlStorage"));

var _logger = require("../logger");

var _error = _interopRequireDefault(require("../error"));

var _urlStorage = require("./urlStorage");

var _httpStack = _interopRequireDefault(require("./httpStack"));

var _fileReader = _interopRequireDefault(require("./fileReader"));

var _fingerprint = _interopRequireDefault(require("./fingerprint"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defaultOptions = _objectSpread(_objectSpread({}, _upload["default"].defaultOptions), {}, {
  httpStack: new _httpStack["default"](),
  fileReader: new _fileReader["default"](),
  urlStorage: _urlStorage.canStoreURLs ? new _urlStorage.WebStorageUrlStorage() : new _noopUrlStorage["default"](),
  fingerprint: _fingerprint["default"]
});

exports.defaultOptions = defaultOptions;

var Upload = /*#__PURE__*/function (_BaseUpload) {
  _inherits(Upload, _BaseUpload);

  var _super = _createSuper(Upload);

  function Upload() {
    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Upload);

    options = _objectSpread(_objectSpread({}, defaultOptions), options);
    return _super.call(this, file, options);
  }

  _createClass(Upload, null, [{
    key: "terminate",
    value: function terminate(url, options, cb) {
      options = _objectSpread(_objectSpread({}, defaultOptions), options);
      return _upload["default"].terminate(url, options, cb);
    }
  }]);

  return Upload;
}(_upload["default"]);

exports.Upload = Upload;
var _window = window,
    XMLHttpRequest = _window.XMLHttpRequest,
    Blob = _window.Blob;
var isSupported = XMLHttpRequest && Blob && typeof Blob.prototype.slice === 'function';
exports.isSupported = isSupported;

},{"../error":12,"../logger":13,"../noopUrlStorage":14,"../upload":15,"./fileReader":1,"./fingerprint":2,"./httpStack":3,"./urlStorage":11}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isReactNative = function isReactNative() {
  return typeof navigator !== 'undefined' && typeof navigator.product === 'string' && navigator.product.toLowerCase() === 'reactnative';
};

var _default = isReactNative;
exports["default"] = _default;

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _isCordova = _interopRequireDefault(require("./isCordova"));

var _readAsByteArray = _interopRequireDefault(require("./readAsByteArray"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var FileSource = /*#__PURE__*/function () {
  // Make this.size a method
  function FileSource(file) {
    _classCallCheck(this, FileSource);

    this._file = file;
    this.size = file.size;
  }

  _createClass(FileSource, [{
    key: "slice",
    value: function slice(start, end) {
      // In Apache Cordova applications, a File must be resolved using
      // FileReader instances, see
      // https://cordova.apache.org/docs/en/8.x/reference/cordova-plugin-file/index.html#read-a-file
      if ((0, _isCordova["default"])()) {
        return (0, _readAsByteArray["default"])(this._file.slice(start, end));
      }

      var value = this._file.slice(start, end);

      return Promise.resolve({
        value: value
      });
    }
  }, {
    key: "close",
    value: function close() {// Nothing to do here since we don't need to release any resources.
    }
  }]);

  return FileSource;
}();

exports["default"] = FileSource;

},{"./isCordova":8,"./readAsByteArray":9}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function len(blobOrArray) {
  if (blobOrArray === undefined) return 0;
  if (blobOrArray.size !== undefined) return blobOrArray.size;
  return blobOrArray.length;
}
/*
  Typed arrays and blobs don't have a concat method.
  This function helps StreamSource accumulate data to reach chunkSize.
*/


function concat(a, b) {
  if (a.concat) {
    // Is `a` an Array?
    return a.concat(b);
  }

  if (a instanceof Blob) {
    return new Blob([a, b], {
      type: a.type
    });
  }

  if (a.set) {
    // Is `a` a typed array?
    var c = new a.constructor(a.length + b.length);
    c.set(a);
    c.set(b, a.length);
    return c;
  }

  throw new Error('Unknown data type');
}

var StreamSource = /*#__PURE__*/function () {
  function StreamSource(reader) {
    _classCallCheck(this, StreamSource);

    this._buffer = undefined;
    this._bufferOffset = 0;
    this._reader = reader;
    this._done = false;
  }

  _createClass(StreamSource, [{
    key: "slice",
    value: function slice(start, end) {
      if (start < this._bufferOffset) {
        return Promise.reject(new Error("Requested data is before the reader's current offset"));
      }

      return this._readUntilEnoughDataOrDone(start, end);
    }
  }, {
    key: "_readUntilEnoughDataOrDone",
    value: function _readUntilEnoughDataOrDone(start, end) {
      var _this = this;

      var hasEnoughData = end <= this._bufferOffset + len(this._buffer);

      if (this._done || hasEnoughData) {
        var value = this._getDataFromBuffer(start, end);

        var done = value == null ? this._done : false;
        return Promise.resolve({
          value: value,
          done: done
        });
      }

      return this._reader.read().then(function (_ref) {
        var value = _ref.value,
            done = _ref.done;

        if (done) {
          _this._done = true;
        } else if (_this._buffer === undefined) {
          _this._buffer = value;
        } else {
          _this._buffer = concat(_this._buffer, value);
        }

        return _this._readUntilEnoughDataOrDone(start, end);
      });
    }
  }, {
    key: "_getDataFromBuffer",
    value: function _getDataFromBuffer(start, end) {
      // Remove data from buffer before `start`.
      // Data might be reread from the buffer if an upload fails, so we can only
      // safely delete data when it comes *before* what is currently being read.
      if (start > this._bufferOffset) {
        this._buffer = this._buffer.slice(start - this._bufferOffset);
        this._bufferOffset = start;
      } // If the buffer is empty after removing old data, all data has been read.


      var hasAllDataBeenRead = len(this._buffer) === 0;

      if (this._done && hasAllDataBeenRead) {
        return null;
      } // We already removed data before `start`, so we just return the first
      // chunk from the buffer.


      return this._buffer.slice(0, end - start);
    }
  }, {
    key: "close",
    value: function close() {
      if (this._reader.cancel) {
        this._reader.cancel();
      }
    }
  }]);

  return StreamSource;
}();

exports["default"] = StreamSource;

},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var isCordova = function isCordova() {
  return typeof window !== 'undefined' && (typeof window.PhoneGap !== 'undefined' || typeof window.Cordova !== 'undefined' || typeof window.cordova !== 'undefined');
};

var _default = isCordova;
exports["default"] = _default;

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = readAsByteArray;
/**
 * readAsByteArray converts a File object to a Uint8Array.
 * This function is only used on the Apache Cordova platform.
 * See https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-file/index.html#read-a-file
 */

function readAsByteArray(chunk) {
  return new Promise(function (resolve, reject) {
    var reader = new FileReader();

    reader.onload = function () {
      var value = new Uint8Array(reader.result);
      resolve({
        value: value
      });
    };

    reader.onerror = function (err) {
      reject(err);
    };

    reader.readAsArrayBuffer(chunk);
  });
}

},{}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uriToBlob;
/**
 * uriToBlob resolves a URI to a Blob object. This is used for
 * React Native to retrieve a file (identified by a file://
 * URI) as a blob.
 */

function uriToBlob(uri) {
  return new Promise(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.responseType = 'blob';

    xhr.onload = function () {
      var blob = xhr.response;
      resolve(blob);
    };

    xhr.onerror = function (err) {
      reject(err);
    };

    xhr.open('GET', uri);
    xhr.send();
  });
}

},{}],11:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.canStoreURLs = exports.WebStorageUrlStorage = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var hasStorage = false;

try {
  hasStorage = 'localStorage' in window; // Attempt to store and read entries from the local storage to detect Private
  // Mode on Safari on iOS (see #49)

  var key = 'tusSupport';
  localStorage.setItem(key, localStorage.getItem(key));
} catch (e) {
  // If we try to access localStorage inside a sandboxed iframe, a SecurityError
  // is thrown. When in private mode on iOS Safari, a QuotaExceededError is
  // thrown (see #49)
  if (e.code === e.SECURITY_ERR || e.code === e.QUOTA_EXCEEDED_ERR) {
    hasStorage = false;
  } else {
    throw e;
  }
}

var canStoreURLs = hasStorage;
exports.canStoreURLs = canStoreURLs;

var WebStorageUrlStorage = /*#__PURE__*/function () {
  function WebStorageUrlStorage() {
    _classCallCheck(this, WebStorageUrlStorage);
  }

  _createClass(WebStorageUrlStorage, [{
    key: "findAllUploads",
    value: function findAllUploads() {
      var results = this._findEntries('tus::');

      return Promise.resolve(results);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      var results = this._findEntries("tus::".concat(fingerprint, "::"));

      return Promise.resolve(results);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      localStorage.removeItem(urlStorageKey);
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      var id = Math.round(Math.random() * 1e12);
      var key = "tus::".concat(fingerprint, "::").concat(id);
      localStorage.setItem(key, JSON.stringify(upload));
      return Promise.resolve(key);
    }
  }, {
    key: "_findEntries",
    value: function _findEntries(prefix) {
      var results = [];

      for (var i = 0; i < localStorage.length; i++) {
        var _key = localStorage.key(i);

        if (_key.indexOf(prefix) !== 0) continue;

        try {
          var upload = JSON.parse(localStorage.getItem(_key));
          upload.urlStorageKey = _key;
          results.push(upload);
        } catch (e) {// The JSON parse error is intentionally ignored here, so a malformed
          // entry in the storage cannot prevent an upload.
        }
      }

      return results;
    }
  }]);

  return WebStorageUrlStorage;
}();

exports.WebStorageUrlStorage = WebStorageUrlStorage;

},{}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

var DetailedError = /*#__PURE__*/function (_Error) {
  _inherits(DetailedError, _Error);

  var _super = _createSuper(DetailedError);

  function DetailedError(message) {
    var _this;

    var causingErr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var req = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var res = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

    _classCallCheck(this, DetailedError);

    _this = _super.call(this, message);
    _this.originalRequest = req;
    _this.originalResponse = res;
    _this.causingError = causingErr;

    if (causingErr != null) {
      message += ", caused by ".concat(causingErr.toString());
    }

    if (req != null) {
      var requestId = req.getHeader('X-Request-ID') || 'n/a';
      var method = req.getMethod();
      var url = req.getURL();
      var status = res ? res.getStatus() : 'n/a';
      var body = res ? res.getBody() || '' : 'n/a';
      message += ", originated from request (method: ".concat(method, ", url: ").concat(url, ", response code: ").concat(status, ", response text: ").concat(body, ", request id: ").concat(requestId, ")");
    }

    _this.message = message;
    return _this;
  }

  return _createClass(DetailedError);
}( /*#__PURE__*/_wrapNativeSuper(Error));

var _default = DetailedError;
exports["default"] = _default;

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enableDebugLog = enableDebugLog;
exports.log = log;
/* eslint no-console: "off" */

var isEnabled = false;

function enableDebugLog() {
  isEnabled = true;
}

function log(msg) {
  if (!isEnabled) return;
  console.log(msg);
}

},{}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
/* eslint no-unused-vars: "off" */


var NoopUrlStorage = /*#__PURE__*/function () {
  function NoopUrlStorage() {
    _classCallCheck(this, NoopUrlStorage);
  }

  _createClass(NoopUrlStorage, [{
    key: "listAllUploads",
    value: function listAllUploads() {
      return Promise.resolve([]);
    }
  }, {
    key: "findUploadsByFingerprint",
    value: function findUploadsByFingerprint(fingerprint) {
      return Promise.resolve([]);
    }
  }, {
    key: "removeUpload",
    value: function removeUpload(urlStorageKey) {
      return Promise.resolve();
    }
  }, {
    key: "addUpload",
    value: function addUpload(fingerprint, upload) {
      return Promise.resolve(null);
    }
  }]);

  return NoopUrlStorage;
}();

exports["default"] = NoopUrlStorage;

},{}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _jsBase = require("js-base64");

var _urlParse = _interopRequireDefault(require("url-parse"));

var _error = _interopRequireDefault(require("./error"));

var _logger = require("./logger");

var _uuid = _interopRequireDefault(require("./uuid"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

var defaultOptions = {
  endpoint: null,
  uploadUrl: null,
  metadata: {},
  fingerprint: null,
  uploadSize: null,
  onProgress: null,
  onChunkComplete: null,
  onSuccess: null,
  onError: null,
  _onUploadUrlAvailable: null,
  overridePatchMethod: false,
  headers: {},
  addRequestId: false,
  onBeforeRequest: null,
  onAfterResponse: null,
  onShouldRetry: null,
  chunkSize: Infinity,
  retryDelays: [0, 1000, 3000, 5000],
  parallelUploads: 1,
  storeFingerprintForResuming: true,
  removeFingerprintOnSuccess: false,
  uploadLengthDeferred: false,
  uploadDataDuringCreation: false,
  urlStorage: null,
  fileReader: null,
  httpStack: null
};

var BaseUpload = /*#__PURE__*/function () {
  function BaseUpload(file, options) {
    _classCallCheck(this, BaseUpload); // Warn about removed options from previous versions


    if ('resume' in options) {
      console.log('tus: The `resume` option has been removed in tus-js-client v2. Please use the URL storage API instead.'); // eslint-disable-line no-console
    } // The default options will already be added from the wrapper classes.


    this.options = options; // Cast chunkSize to integer

    this.options.chunkSize = Number(this.options.chunkSize); // The storage module used to store URLs

    this._urlStorage = this.options.urlStorage; // The underlying File/Blob object

    this.file = file; // The URL against which the file will be uploaded

    this.url = null; // The underlying request object for the current PATCH request

    this._req = null; // The fingerpinrt for the current file (set after start())

    this._fingerprint = null; // The key that the URL storage returned when saving an URL with a fingerprint,

    this._urlStorageKey = null; // The offset used in the current PATCH request

    this._offset = null; // True if the current PATCH request has been aborted

    this._aborted = false; // The file's size in bytes

    this._size = null; // The Source object which will wrap around the given file and provides us
    // with a unified interface for getting its size and slice chunks from its
    // content allowing us to easily handle Files, Blobs, Buffers and Streams.

    this._source = null; // The current count of attempts which have been made. Zero indicates none.

    this._retryAttempt = 0; // The timeout's ID which is used to delay the next retry

    this._retryTimeout = null; // The offset of the remote upload before the latest attempt was started.

    this._offsetBeforeRetry = 0; // An array of BaseUpload instances which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploads = null; // An array of upload URLs which are used for uploading the different
    // parts, if the parallelUploads option is used.

    this._parallelUploadUrls = null;
  }
  /**
   * Use the Termination extension to delete an upload from the server by sending a DELETE
   * request to the specified upload URL. This is only possible if the server supports the
   * Termination extension. If the `options.retryDelays` property is set, the method will
   * also retry if an error ocurrs.
   *
   * @param {String} url The upload's URL which will be terminated.
   * @param {object} options Optional options for influencing HTTP requests.
   * @return {Promise} The Promise will be resolved/rejected when the requests finish.
   */


  _createClass(BaseUpload, [{
    key: "findPreviousUploads",
    value: function findPreviousUploads() {
      var _this = this;

      return this.options.fingerprint(this.file, this.options).then(function (fingerprint) {
        return _this._urlStorage.findUploadsByFingerprint(fingerprint);
      });
    }
  }, {
    key: "resumeFromPreviousUpload",
    value: function resumeFromPreviousUpload(previousUpload) {
      this.url = previousUpload.uploadUrl || null;
      this._parallelUploadUrls = previousUpload.parallelUploadUrls || null;
      this._urlStorageKey = previousUpload.urlStorageKey;
    }
  }, {
    key: "start",
    value: function start() {
      var _this2 = this;

      var file = this.file;

      if (!file) {
        this._emitError(new Error('tus: no file or stream to upload provided'));

        return;
      }

      if (!this.options.endpoint && !this.options.uploadUrl) {
        this._emitError(new Error('tus: neither an endpoint or an upload URL is provided'));

        return;
      }

      var retryDelays = this.options.retryDelays;

      if (retryDelays != null && Object.prototype.toString.call(retryDelays) !== '[object Array]') {
        this._emitError(new Error('tus: the `retryDelays` option must either be an array or null'));

        return;
      }

      if (this.options.parallelUploads > 1) {
        // Test which options are incompatible with parallel uploads.
        ['uploadUrl', 'uploadSize', 'uploadLengthDeferred'].forEach(function (optionName) {
          if (_this2.options[optionName]) {
            _this2._emitError(new Error("tus: cannot use the ".concat(optionName, " option when parallelUploads is enabled")));
          }
        });
      }

      this.options.fingerprint(file, this.options).then(function (fingerprint) {
        if (fingerprint == null) {
          (0, _logger.log)('No fingerprint was calculated meaning that the upload cannot be stored in the URL storage.');
        } else {
          (0, _logger.log)("Calculated fingerprint: ".concat(fingerprint));
        }

        _this2._fingerprint = fingerprint;

        if (_this2._source) {
          return _this2._source;
        }

        return _this2.options.fileReader.openFile(file, _this2.options.chunkSize);
      }).then(function (source) {
        _this2._source = source; // If the upload was configured to use multiple requests or if we resume from
        // an upload which used multiple requests, we start a parallel upload.

        if (_this2.options.parallelUploads > 1 || _this2._parallelUploadUrls != null) {
          _this2._startParallelUpload();
        } else {
          _this2._startSingleUpload();
        }
      })["catch"](function (err) {
        _this2._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a parallelized upload, where one file is split into
     * multiple request which are run in parallel.
     *
     * @api private
     */

  }, {
    key: "_startParallelUpload",
    value: function _startParallelUpload() {
      var _this3 = this;

      this._size = this._source.size;
      var totalSize = this._size;
      var totalProgress = 0;
      this._parallelUploads = [];
      var partCount = this._parallelUploadUrls != null ? this._parallelUploadUrls.length : this.options.parallelUploads; // The input file will be split into multiple slices which are uploaded in separate
      // requests. Here we generate the start and end position for the slices.

      var parts = splitSizeIntoParts(this._source.size, partCount, this._parallelUploadUrls); // Create an empty list for storing the upload URLs

      this._parallelUploadUrls = new Array(parts.length); // Generate a promise for each slice that will be resolve if the respective
      // upload is completed.

      var uploads = parts.map(function (part, index) {
        var lastPartProgress = 0;
        return _this3._source.slice(part.start, part.end).then(function (_ref) {
          var value = _ref.value;
          return new Promise(function (resolve, reject) {
            // Merge with the user supplied options but overwrite some values.
            var options = _objectSpread(_objectSpread({}, _this3.options), {}, {
              // If available, the partial upload should be resumed from a previous URL.
              uploadUrl: part.uploadUrl || null,
              // We take manually care of resuming for partial uploads, so they should
              // not be stored in the URL storage.
              storeFingerprintForResuming: false,
              removeFingerprintOnSuccess: false,
              // Reset the parallelUploads option to not cause recursion.
              parallelUploads: 1,
              metadata: {},
              // Add the header to indicate the this is a partial upload.
              headers: _objectSpread(_objectSpread({}, _this3.options.headers), {}, {
                'Upload-Concat': 'partial'
              }),
              // Reject or resolve the promise if the upload errors or completes.
              onSuccess: resolve,
              onError: reject,
              // Based in the progress for this partial upload, calculate the progress
              // for the entire final upload.
              onProgress: function onProgress(newPartProgress) {
                totalProgress = totalProgress - lastPartProgress + newPartProgress;
                lastPartProgress = newPartProgress;

                _this3._emitProgress(totalProgress, totalSize);
              },
              // Wait until every partial upload has an upload URL, so we can add
              // them to the URL storage.
              _onUploadUrlAvailable: function _onUploadUrlAvailable() {
                _this3._parallelUploadUrls[index] = upload.url; // Test if all uploads have received an URL

                if (_this3._parallelUploadUrls.filter(function (u) {
                  return Boolean(u);
                }).length === parts.length) {
                  _this3._saveUploadInUrlStorage();
                }
              }
            });

            var upload = new BaseUpload(value, options);
            upload.start(); // Store the upload in an array, so we can later abort them if necessary.

            _this3._parallelUploads.push(upload);
          });
        });
      });
      var req; // Wait until all partial uploads are finished and we can send the POST request for
      // creating the final upload.

      Promise.all(uploads).then(function () {
        req = _this3._openRequest('POST', _this3.options.endpoint);
        req.setHeader('Upload-Concat', "final;".concat(_this3._parallelUploadUrls.join(' '))); // Add metadata if values have been added

        var metadata = encodeMetadata(_this3.options.metadata);

        if (metadata !== '') {
          req.setHeader('Upload-Metadata', metadata);
        }

        return _this3._sendRequest(req, null);
      }).then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this3._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this3._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this3.url = resolveUrl(_this3.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this3.url));

        _this3._emitSuccess();
      })["catch"](function (err) {
        _this3._emitError(err);
      });
    }
    /**
     * Initiate the uploading procedure for a non-parallel upload. Here the entire file is
     * uploaded in a sequential matter.
     *
     * @api private
     */

  }, {
    key: "_startSingleUpload",
    value: function _startSingleUpload() {
      // First, we look at the uploadLengthDeferred option.
      // Next, we check if the caller has supplied a manual upload size.
      // Finally, we try to use the calculated size from the source object.
      if (this.options.uploadLengthDeferred) {
        this._size = null;
      } else if (this.options.uploadSize != null) {
        this._size = Number(this.options.uploadSize);

        if (Number.isNaN(this._size)) {
          this._emitError(new Error('tus: cannot convert `uploadSize` option into a number'));

          return;
        }
      } else {
        this._size = this._source.size;

        if (this._size == null) {
          this._emitError(new Error("tus: cannot automatically derive upload's size from input. Specify it manually using the `uploadSize` option or use the `uploadLengthDeferred` option"));

          return;
        }
      } // Reset the aborted flag when the upload is started or else the
      // _performUpload will stop before sending a request if the upload has been
      // aborted previously.


      this._aborted = false; // The upload had been started previously and we should reuse this URL.

      if (this.url != null) {
        (0, _logger.log)("Resuming upload from previous URL: ".concat(this.url));

        this._resumeUpload();

        return;
      } // A URL has manually been specified, so we try to resume


      if (this.options.uploadUrl != null) {
        (0, _logger.log)("Resuming upload from provided URL: ".concat(this.options.uploadUrl));
        this.url = this.options.uploadUrl;

        this._resumeUpload();

        return;
      } // An upload has not started for the file yet, so we start a new one


      (0, _logger.log)('Creating a new upload');

      this._createUpload();
    }
    /**
     * Abort any running request and stop the current upload. After abort is called, no event
     * handler will be invoked anymore. You can use the `start` method to resume the upload
     * again.
     * If `shouldTerminate` is true, the `terminate` function will be called to remove the
     * current upload from the server.
     *
     * @param {boolean} shouldTerminate True if the upload should be deleted from the server.
     * @return {Promise} The Promise will be resolved/rejected when the requests finish.
     */

  }, {
    key: "abort",
    value: function abort(shouldTerminate) {
      var _this4 = this; // Stop any parallel partial uploads, that have been started in _startParallelUploads.


      if (this._parallelUploads != null) {
        this._parallelUploads.forEach(function (upload) {
          upload.abort(shouldTerminate);
        });
      } // Stop any current running request.


      if (this._req !== null) {
        this._req.abort();

        this._source.close();
      }

      this._aborted = true; // Stop any timeout used for initiating a retry.

      if (this._retryTimeout != null) {
        clearTimeout(this._retryTimeout);
        this._retryTimeout = null;
      }

      if (!shouldTerminate || this.url == null) {
        return Promise.resolve();
      }

      return BaseUpload.terminate(this.url, this.options) // Remove entry from the URL storage since the upload URL is no longer valid.
      .then(function () {
        return _this4._removeFromUrlStorage();
      });
    }
  }, {
    key: "_emitHttpError",
    value: function _emitHttpError(req, res, message, causingErr) {
      this._emitError(new _error["default"](message, causingErr, req, res));
    }
  }, {
    key: "_emitError",
    value: function _emitError(err) {
      var _this5 = this; // Do not emit errors, e.g. from aborted HTTP requests, if the upload has been stopped.


      if (this._aborted) return; // Check if we should retry, when enabled, before sending the error to the user.

      if (this.options.retryDelays != null) {
        // We will reset the attempt counter if
        // - we were already able to connect to the server (offset != null) and
        // - we were able to upload a small chunk of data to the server
        var shouldResetDelays = this._offset != null && this._offset > this._offsetBeforeRetry;

        if (shouldResetDelays) {
          this._retryAttempt = 0;
        }

        if (shouldRetry(err, this._retryAttempt, this.options)) {
          var delay = this.options.retryDelays[this._retryAttempt++];
          this._offsetBeforeRetry = this._offset;
          this._retryTimeout = setTimeout(function () {
            _this5.start();
          }, delay);
          return;
        }
      }

      if (typeof this.options.onError === 'function') {
        this.options.onError(err);
      } else {
        throw err;
      }
    }
    /**
     * Publishes notification if the upload has been successfully completed.
     *
     * @api private
     */

  }, {
    key: "_emitSuccess",
    value: function _emitSuccess() {
      if (this.options.removeFingerprintOnSuccess) {
        // Remove stored fingerprint and corresponding endpoint. This causes
        // new uploads of the same file to be treated as a different file.
        this._removeFromUrlStorage();
      }

      if (typeof this.options.onSuccess === 'function') {
        this.options.onSuccess();
      }
    }
    /**
     * Publishes notification when data has been sent to the server. This
     * data may not have been accepted by the server yet.
     *
     * @param {number} bytesSent  Number of bytes sent to the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitProgress",
    value: function _emitProgress(bytesSent, bytesTotal) {
      if (typeof this.options.onProgress === 'function') {
        this.options.onProgress(bytesSent, bytesTotal);
      }
    }
    /**
     * Publishes notification when a chunk of data has been sent to the server
     * and accepted by the server.
     * @param {number} chunkSize  Size of the chunk that was accepted by the server.
     * @param {number} bytesAccepted Total number of bytes that have been
     *                                accepted by the server.
     * @param {number} bytesTotal Total number of bytes to be sent to the server.
     * @api private
     */

  }, {
    key: "_emitChunkComplete",
    value: function _emitChunkComplete(chunkSize, bytesAccepted, bytesTotal) {
      if (typeof this.options.onChunkComplete === 'function') {
        this.options.onChunkComplete(chunkSize, bytesAccepted, bytesTotal);
      }
    }
    /**
     * Create a new upload using the creation extension by sending a POST
     * request to the endpoint. After successful creation the file will be
     * uploaded
     *
     * @api private
     */

  }, {
    key: "_createUpload",
    value: function _createUpload() {
      var _this6 = this;

      if (!this.options.endpoint) {
        this._emitError(new Error('tus: unable to create upload because no endpoint is provided'));

        return;
      }

      var req = this._openRequest('POST', this.options.endpoint);

      if (this.options.uploadLengthDeferred) {
        req.setHeader('Upload-Defer-Length', 1);
      } else {
        req.setHeader('Upload-Length', this._size);
      } // Add metadata if values have been added


      var metadata = encodeMetadata(this.options.metadata);

      if (metadata !== '') {
        req.setHeader('Upload-Metadata', metadata);
      }

      var promise;

      if (this.options.uploadDataDuringCreation && !this.options.uploadLengthDeferred) {
        this._offset = 0;
        promise = this._addChunkToRequest(req);
      } else {
        promise = this._sendRequest(req, null);
      }

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this6._emitHttpError(req, res, 'tus: unexpected response while creating upload');

          return;
        }

        var location = res.getHeader('Location');

        if (location == null) {
          _this6._emitHttpError(req, res, 'tus: invalid or missing Location header');

          return;
        }

        _this6.url = resolveUrl(_this6.options.endpoint, location);
        (0, _logger.log)("Created upload at ".concat(_this6.url));

        if (typeof _this6.options._onUploadUrlAvailable === 'function') {
          _this6.options._onUploadUrlAvailable();
        }

        if (_this6._size === 0) {
          // Nothing to upload and file was successfully created
          _this6._emitSuccess();

          _this6._source.close();

          return;
        }

        _this6._saveUploadInUrlStorage();

        if (_this6.options.uploadDataDuringCreation) {
          _this6._handleUploadResponse(req, res);
        } else {
          _this6._offset = 0;

          _this6._performUpload();
        }
      })["catch"](function (err) {
        _this6._emitHttpError(req, null, 'tus: failed to create upload', err);
      });
    }
    /*
     * Try to resume an existing upload. First a HEAD request will be sent
     * to retrieve the offset. If the request fails a new upload will be
     * created. In the case of a successful response the file will be uploaded.
     *
     * @api private
     */

  }, {
    key: "_resumeUpload",
    value: function _resumeUpload() {
      var _this7 = this;

      var req = this._openRequest('HEAD', this.url);

      var promise = this._sendRequest(req, null);

      promise.then(function (res) {
        var status = res.getStatus();

        if (!inStatusCategory(status, 200)) {
          if (inStatusCategory(status, 400)) {
            // Remove stored fingerprint and corresponding endpoint,
            // on client errors since the file can not be found
            _this7._removeFromUrlStorage();
          } // If the upload is locked (indicated by the 423 Locked status code), we
          // emit an error instead of directly starting a new upload. This way the
          // retry logic can catch the error and will retry the upload. An upload
          // is usually locked for a short period of time and will be available
          // afterwards.


          if (status === 423) {
            _this7._emitHttpError(req, res, 'tus: upload is currently locked; retry later');

            return;
          }

          if (!_this7.options.endpoint) {
            // Don't attempt to create a new upload if no endpoint is provided.
            _this7._emitHttpError(req, res, 'tus: unable to resume upload (new upload cannot be created without an endpoint)');

            return;
          } // Try to create a new upload


          _this7.url = null;

          _this7._createUpload();

          return;
        }

        var offset = parseInt(res.getHeader('Upload-Offset'), 10);

        if (Number.isNaN(offset)) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing offset value');

          return;
        }

        var length = parseInt(res.getHeader('Upload-Length'), 10);

        if (Number.isNaN(length) && !_this7.options.uploadLengthDeferred) {
          _this7._emitHttpError(req, res, 'tus: invalid or missing length value');

          return;
        }

        if (typeof _this7.options._onUploadUrlAvailable === 'function') {
          _this7.options._onUploadUrlAvailable();
        } // Upload has already been completed and we do not need to send additional
        // data to the server


        if (offset === length) {
          _this7._emitProgress(length, length);

          _this7._emitSuccess();

          return;
        }

        _this7._offset = offset;

        _this7._performUpload();
      })["catch"](function (err) {
        _this7._emitHttpError(req, null, 'tus: failed to resume upload', err);
      });
    }
    /**
     * Start uploading the file using PATCH requests. The file will be divided
     * into chunks as specified in the chunkSize option. During the upload
     * the onProgress event handler may be invoked multiple times.
     *
     * @api private
     */

  }, {
    key: "_performUpload",
    value: function _performUpload() {
      var _this8 = this; // If the upload has been aborted, we will not send the next PATCH request.
      // This is important if the abort method was called during a callback, such
      // as onChunkComplete or onProgress.


      if (this._aborted) {
        return;
      }

      var req; // Some browser and servers may not support the PATCH method. For those
      // cases, you can tell tus-js-client to use a POST request with the
      // X-HTTP-Method-Override header for simulating a PATCH request.

      if (this.options.overridePatchMethod) {
        req = this._openRequest('POST', this.url);
        req.setHeader('X-HTTP-Method-Override', 'PATCH');
      } else {
        req = this._openRequest('PATCH', this.url);
      }

      req.setHeader('Upload-Offset', this._offset);

      var promise = this._addChunkToRequest(req);

      promise.then(function (res) {
        if (!inStatusCategory(res.getStatus(), 200)) {
          _this8._emitHttpError(req, res, 'tus: unexpected response while uploading chunk');

          return;
        }

        _this8._handleUploadResponse(req, res);
      })["catch"](function (err) {
        // Don't emit an error if the upload was aborted manually
        if (_this8._aborted) {
          return;
        }

        _this8._emitHttpError(req, null, "tus: failed to upload chunk at offset ".concat(_this8._offset), err);
      });
    }
    /**
     * _addChunktoRequest reads a chunk from the source and sends it using the
     * supplied request object. It will not handle the response.
     *
     * @api private
     */

  }, {
    key: "_addChunkToRequest",
    value: function _addChunkToRequest(req) {
      var _this9 = this;

      var start = this._offset;
      var end = this._offset + this.options.chunkSize;
      req.setProgressHandler(function (bytesSent) {
        _this9._emitProgress(start + bytesSent, _this9._size);
      });
      req.setHeader('Content-Type', 'application/offset+octet-stream'); // The specified chunkSize may be Infinity or the calcluated end position
      // may exceed the file's size. In both cases, we limit the end position to
      // the input's total size for simpler calculations and correctness.

      if ((end === Infinity || end > this._size) && !this.options.uploadLengthDeferred) {
        end = this._size;
      }

      return this._source.slice(start, end).then(function (_ref2) {
        var value = _ref2.value,
            done = _ref2.done; // If the upload length is deferred, the upload size was not specified during
        // upload creation. So, if the file reader is done reading, we know the total
        // upload size and can tell the tus server.

        if (_this9.options.uploadLengthDeferred && done) {
          _this9._size = _this9._offset + (value && value.size ? value.size : 0);
          req.setHeader('Upload-Length', _this9._size);
        }

        if (value === null) {
          return _this9._sendRequest(req);
        }

        _this9._emitProgress(_this9._offset, _this9._size);

        return _this9._sendRequest(req, value);
      });
    }
    /**
     * _handleUploadResponse is used by requests that haven been sent using _addChunkToRequest
     * and already have received a response.
     *
     * @api private
     */

  }, {
    key: "_handleUploadResponse",
    value: function _handleUploadResponse(req, res) {
      var offset = parseInt(res.getHeader('Upload-Offset'), 10);

      if (Number.isNaN(offset)) {
        this._emitHttpError(req, res, 'tus: invalid or missing offset value');

        return;
      }

      this._emitProgress(offset, this._size);

      this._emitChunkComplete(offset - this._offset, offset, this._size);

      this._offset = offset;

      if (offset === this._size) {
        // Yay, finally done :)
        this._emitSuccess();

        this._source.close();

        return;
      }

      this._performUpload();
    }
    /**
     * Create a new HTTP request object with the given method and URL.
     *
     * @api private
     */

  }, {
    key: "_openRequest",
    value: function _openRequest(method, url) {
      var req = openRequest(method, url, this.options);
      this._req = req;
      return req;
    }
    /**
     * Remove the entry in the URL storage, if it has been saved before.
     *
     * @api private
     */

  }, {
    key: "_removeFromUrlStorage",
    value: function _removeFromUrlStorage() {
      var _this10 = this;

      if (!this._urlStorageKey) return;

      this._urlStorage.removeUpload(this._urlStorageKey)["catch"](function (err) {
        _this10._emitError(err);
      });

      this._urlStorageKey = null;
    }
    /**
     * Add the upload URL to the URL storage, if possible.
     *
     * @api private
     */

  }, {
    key: "_saveUploadInUrlStorage",
    value: function _saveUploadInUrlStorage() {
      var _this11 = this; // Only if a fingerprint was calculated for the input (i.e. not a stream), we can store the upload URL.


      if (!this.options.storeFingerprintForResuming || !this._fingerprint) {
        return;
      }

      var storedUpload = {
        size: this._size,
        metadata: this.options.metadata,
        creationTime: new Date().toString()
      };

      if (this._parallelUploads) {
        // Save multiple URLs if the parallelUploads option is used ...
        storedUpload.parallelUploadUrls = this._parallelUploadUrls;
      } else {
        // ... otherwise we just save the one available URL.
        storedUpload.uploadUrl = this.url;
      }

      this._urlStorage.addUpload(this._fingerprint, storedUpload).then(function (urlStorageKey) {
        _this11._urlStorageKey = urlStorageKey;
      })["catch"](function (err) {
        _this11._emitError(err);
      });
    }
    /**
     * Send a request with the provided body.
     *
     * @api private
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(req) {
      var body = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return sendRequest(req, body, this.options);
    }
  }], [{
    key: "terminate",
    value: function terminate(url) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var req = openRequest('DELETE', url, options);
      return sendRequest(req, null, options).then(function (res) {
        // A 204 response indicates a successfull request
        if (res.getStatus() === 204) {
          return;
        }

        throw new _error["default"]('tus: unexpected response while terminating upload', null, req, res);
      })["catch"](function (err) {
        if (!(err instanceof _error["default"])) {
          err = new _error["default"]('tus: failed to terminate upload', err, req, null);
        }

        if (!shouldRetry(err, 0, options)) {
          throw err;
        } // Instead of keeping track of the retry attempts, we remove the first element from the delays
        // array. If the array is empty, all retry attempts are used up and we will bubble up the error.
        // We recursively call the terminate function will removing elements from the retryDelays array.


        var delay = options.retryDelays[0];
        var remainingDelays = options.retryDelays.slice(1);

        var newOptions = _objectSpread(_objectSpread({}, options), {}, {
          retryDelays: remainingDelays
        });

        return new Promise(function (resolve) {
          return setTimeout(resolve, delay);
        }).then(function () {
          return BaseUpload.terminate(url, newOptions);
        });
      });
    }
  }]);

  return BaseUpload;
}();

function encodeMetadata(metadata) {
  return Object.entries(metadata).map(function (_ref3) {
    var _ref4 = _slicedToArray(_ref3, 2),
        key = _ref4[0],
        value = _ref4[1];

    return "".concat(key, " ").concat(_jsBase.Base64.encode(String(value)));
  }).join(',');
}
/**
 * Checks whether a given status is in the range of the expected category.
 * For example, only a status between 200 and 299 will satisfy the category 200.
 *
 * @api private
 */


function inStatusCategory(status, category) {
  return status >= category && status < category + 100;
}
/**
 * Create a new HTTP request with the specified method and URL.
 * The necessary headers that are included in every request
 * will be added, including the request ID.
 *
 * @api private
 */


function openRequest(method, url, options) {
  var req = options.httpStack.createRequest(method, url);
  req.setHeader('Tus-Resumable', '1.0.0');
  var headers = options.headers || {};
  Object.entries(headers).forEach(function (_ref5) {
    var _ref6 = _slicedToArray(_ref5, 2),
        name = _ref6[0],
        value = _ref6[1];

    req.setHeader(name, value);
  });

  if (options.addRequestId) {
    var requestId = (0, _uuid["default"])();
    req.setHeader('X-Request-ID', requestId);
  }

  return req;
}
/**
 * Send a request with the provided body while invoking the onBeforeRequest
 * and onAfterResponse callbacks.
 *
 * @api private
 */


function sendRequest(req, body, options) {
  var onBeforeRequestPromise = typeof options.onBeforeRequest === 'function' ? Promise.resolve(options.onBeforeRequest(req)) : Promise.resolve();
  return onBeforeRequestPromise.then(function () {
    return req.send(body).then(function (res) {
      var onAfterResponsePromise = typeof options.onAfterResponse === 'function' ? Promise.resolve(options.onAfterResponse(req, res)) : Promise.resolve();
      return onAfterResponsePromise.then(function () {
        return res;
      });
    });
  });
}
/**
 * Checks whether the browser running this code has internet access.
 * This function will always return true in the node.js environment
 *
 * @api private
 */


function isOnline() {
  var online = true;

  if (typeof window !== 'undefined' && 'navigator' in window && window.navigator.onLine === false) {
    online = false;
  }

  return online;
}
/**
 * Checks whether or not it is ok to retry a request.
 * @param {Error} err the error returned from the last request
 * @param {number} retryAttempt the number of times the request has already been retried
 * @param {object} options tus Upload options
 *
 * @api private
 */


function shouldRetry(err, retryAttempt, options) {
  // We only attempt a retry if
  // - retryDelays option is set
  // - we didn't exceed the maxium number of retries, yet, and
  // - this error was caused by a request or it's response and
  // - the error is server error (i.e. not a status 4xx except a 409 or 423) or
  // a onShouldRetry is specified and returns true
  // - the browser does not indicate that we are offline
  if (options.retryDelays == null || retryAttempt >= options.retryDelays.length || err.originalRequest == null) {
    return false;
  }

  if (options && typeof options.onShouldRetry === 'function') {
    return options.onShouldRetry(err, retryAttempt, options);
  }

  var status = err.originalResponse ? err.originalResponse.getStatus() : 0;
  return (!inStatusCategory(status, 400) || status === 409 || status === 423) && isOnline();
}
/**
 * Resolve a relative link given the origin as source. For example,
 * if a HTTP request to http://example.com/files/ returns a Location
 * header with the value /upload/abc, the resolved URL will be:
 * http://example.com/upload/abc
 */


function resolveUrl(origin, link) {
  return new _urlParse["default"](link, origin).toString();
}
/**
 * Calculate the start and end positions for the parts if an upload
 * is split into multiple parallel requests.
 *
 * @param {number} totalSize The byte size of the upload, which will be split.
 * @param {number} partCount The number in how many parts the upload will be split.
 * @param {string[]} previousUrls The upload URLs for previous parts.
 * @return {object[]}
 * @api private
 */


function splitSizeIntoParts(totalSize, partCount, previousUrls) {
  var partSize = Math.floor(totalSize / partCount);
  var parts = [];

  for (var i = 0; i < partCount; i++) {
    parts.push({
      start: partSize * i,
      end: partSize * (i + 1)
    });
  }

  parts[partCount - 1].end = totalSize; // Attach URLs from previous uploads, if available.

  if (previousUrls) {
    parts.forEach(function (part, index) {
      part.uploadUrl = previousUrls[index] || null;
    });
  }

  return parts;
}

BaseUpload.defaultOptions = defaultOptions;
var _default = BaseUpload;
exports["default"] = _default;

},{"./error":12,"./logger":13,"./uuid":16,"js-base64":52,"url-parse":57}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = uuid;
/**
 * Generate a UUID v4 based on random numbers. We intentioanlly use the less
 * secure Math.random function here since the more secure crypto.getRandomNumbers
 * is not available on all platforms.
 * This is not a problem for us since we use the UUID only for generating a
 * request ID, so we can correlate server logs to client errors.
 *
 * This function is taken from following site:
 * https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
 *
 * @return {string} The generate UUID
 */

function uuid() {
  /* eslint-disable no-bitwise */
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = Math.random() * 16 | 0;
    var v = c === 'x' ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
}

},{}],17:[function(require,module,exports){
module.exports = require('./lib/axios');
},{"./lib/axios":19}],18:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var settle = require('./../core/settle');
var cookies = require('./../helpers/cookies');
var buildURL = require('./../helpers/buildURL');
var buildFullPath = require('../core/buildFullPath');
var parseHeaders = require('./../helpers/parseHeaders');
var isURLSameOrigin = require('./../helpers/isURLSameOrigin');
var transitionalDefaults = require('../defaults/transitional');
var AxiosError = require('../core/AxiosError');
var CanceledError = require('../cancel/CanceledError');
var parseProtocol = require('../helpers/parseProtocol');

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;
    var onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', onCanceled);
      }
    }

    if (utils.isFormData(requestData) && utils.isStandardBrowserEnv()) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);

    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?
        request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
      var transitional = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
        cookies.read(config.xsrfCookieName) :
        undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken || config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = function(cancel) {
        if (!request) {
          return;
        }
        reject(!cancel || (cancel && cancel.type) ? new CanceledError() : cancel);
        request.abort();
        request = null;
      };

      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);
      }
    }

    if (!requestData) {
      requestData = null;
    }

    var protocol = parseProtocol(fullPath);

    if (protocol && [ 'http', 'https', 'file' ].indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData);
  });
};

},{"../cancel/CanceledError":21,"../core/AxiosError":24,"../core/buildFullPath":26,"../defaults/transitional":32,"../helpers/parseProtocol":44,"./../core/settle":29,"./../helpers/buildURL":35,"./../helpers/cookies":37,"./../helpers/isURLSameOrigin":40,"./../helpers/parseHeaders":43,"./../utils":48}],19:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var bind = require('./helpers/bind');
var Axios = require('./core/Axios');
var mergeConfig = require('./core/mergeConfig');
var defaults = require('./defaults');

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Expose Cancel & CancelToken
axios.CanceledError = require('./cancel/CanceledError');
axios.CancelToken = require('./cancel/CancelToken');
axios.isCancel = require('./cancel/isCancel');
axios.VERSION = require('./env/data').version;
axios.toFormData = require('./helpers/toFormData');

// Expose AxiosError class
axios.AxiosError = require('../lib/core/AxiosError');

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = require('./helpers/spread');

// Expose isAxiosError
axios.isAxiosError = require('./helpers/isAxiosError');

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

},{"../lib/core/AxiosError":24,"./cancel/CancelToken":20,"./cancel/CanceledError":21,"./cancel/isCancel":22,"./core/Axios":23,"./core/mergeConfig":28,"./defaults":31,"./env/data":33,"./helpers/bind":34,"./helpers/isAxiosError":39,"./helpers/spread":45,"./helpers/toFormData":46,"./utils":48}],20:[function(require,module,exports){
'use strict';

var CanceledError = require('./CanceledError');

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;

  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;

  // eslint-disable-next-line func-names
  this.promise.then(function(cancel) {
    if (!token._listeners) return;

    var i;
    var l = token._listeners.length;

    for (i = 0; i < l; i++) {
      token._listeners[i](cancel);
    }
    token._listeners = null;
  });

  // eslint-disable-next-line func-names
  this.promise.then = function(onfulfilled) {
    var _resolve;
    // eslint-disable-next-line func-names
    var promise = new Promise(function(resolve) {
      token.subscribe(resolve);
      _resolve = resolve;
    }).then(onfulfilled);

    promise.cancel = function reject() {
      token.unsubscribe(_resolve);
    };

    return promise;
  };

  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new CanceledError(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Subscribe to the cancel signal
 */

CancelToken.prototype.subscribe = function subscribe(listener) {
  if (this.reason) {
    listener(this.reason);
    return;
  }

  if (this._listeners) {
    this._listeners.push(listener);
  } else {
    this._listeners = [listener];
  }
};

/**
 * Unsubscribe from the cancel signal
 */

CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
  if (!this._listeners) {
    return;
  }
  var index = this._listeners.indexOf(listener);
  if (index !== -1) {
    this._listeners.splice(index, 1);
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

},{"./CanceledError":21}],21:[function(require,module,exports){
'use strict';

var AxiosError = require('../core/AxiosError');
var utils = require('../utils');

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */
function CanceledError(message) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

module.exports = CanceledError;

},{"../core/AxiosError":24,"../utils":48}],22:[function(require,module,exports){
'use strict';

module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

},{}],23:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var buildURL = require('../helpers/buildURL');
var InterceptorManager = require('./InterceptorManager');
var dispatchRequest = require('./dispatchRequest');
var mergeConfig = require('./mergeConfig');
var buildFullPath = require('./buildFullPath');
var validator = require('../helpers/validator');

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(configOrUrl, config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof configOrUrl === 'string') {
    config = config || {};
    config.url = configOrUrl;
  } else {
    config = configOrUrl || {};
  }

  config = mergeConfig(this.defaults, config);

  // Set config.method
  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators.boolean),
      forcedJSONParsing: validators.transitional(validators.boolean),
      clarifyTimeoutError: validators.transitional(validators.boolean)
    }, false);
  }

  // filter out skipped interceptors
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });

  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];

    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);

    promise = Promise.resolve(config);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }


  var newConfig = config;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  var fullPath = buildFullPath(config.baseURL, config.url);
  return buildURL(fullPath, config.params, config.paramsSerializer);
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method: method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url: url,
        data: data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

module.exports = Axios;

},{"../helpers/buildURL":35,"../helpers/validator":47,"./../utils":48,"./InterceptorManager":25,"./buildFullPath":26,"./dispatchRequest":27,"./mergeConfig":28}],24:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});

var prototype = AxiosError.prototype;
var descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED'
// eslint-disable-next-line func-names
].forEach(function(code) {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = function(error, code, config, request, response, customProps) {
  var axiosError = Object.create(prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

module.exports = AxiosError;

},{"../utils":48}],25:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

},{"./../utils":48}],26:[function(require,module,exports){
'use strict';

var isAbsoluteURL = require('../helpers/isAbsoluteURL');
var combineURLs = require('../helpers/combineURLs');

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */
module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
};

},{"../helpers/combineURLs":36,"../helpers/isAbsoluteURL":38}],27:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var transformData = require('./transformData');
var isCancel = require('../cancel/isCancel');
var defaults = require('../defaults');
var CanceledError = require('../cancel/CanceledError');

/**
 * Throws a `CanceledError` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData.call(
    config,
    config.data,
    config.headers,
    config.transformRequest
  );

  // Flatten headers
  config.headers = utils.merge(
    config.headers.common || {},
    config.headers[config.method] || {},
    config.headers
  );

  utils.forEach(
    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
    function cleanHeaderConfig(method) {
      delete config.headers[method];
    }
  );

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      response.data,
      response.headers,
      config.transformResponse
    );

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          reason.response.data,
          reason.response.headers,
          config.transformResponse
        );
      }
    }

    return Promise.reject(reason);
  });
};

},{"../cancel/CanceledError":21,"../cancel/isCancel":22,"../defaults":31,"./../utils":48,"./transformData":30}],28:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */
module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      return getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(prop) {
    if (prop in config2) {
      return getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      return getMergedValue(undefined, config1[prop]);
    }
  }

  var mergeMap = {
    'url': valueFromConfig2,
    'method': valueFromConfig2,
    'data': valueFromConfig2,
    'baseURL': defaultToConfig2,
    'transformRequest': defaultToConfig2,
    'transformResponse': defaultToConfig2,
    'paramsSerializer': defaultToConfig2,
    'timeout': defaultToConfig2,
    'timeoutMessage': defaultToConfig2,
    'withCredentials': defaultToConfig2,
    'adapter': defaultToConfig2,
    'responseType': defaultToConfig2,
    'xsrfCookieName': defaultToConfig2,
    'xsrfHeaderName': defaultToConfig2,
    'onUploadProgress': defaultToConfig2,
    'onDownloadProgress': defaultToConfig2,
    'decompress': defaultToConfig2,
    'maxContentLength': defaultToConfig2,
    'maxBodyLength': defaultToConfig2,
    'beforeRedirect': defaultToConfig2,
    'transport': defaultToConfig2,
    'httpAgent': defaultToConfig2,
    'httpsAgent': defaultToConfig2,
    'cancelToken': defaultToConfig2,
    'socketPath': defaultToConfig2,
    'responseEncoding': defaultToConfig2,
    'validateStatus': mergeDirectKeys
  };

  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    var merge = mergeMap[prop] || mergeDeepProperties;
    var configValue = merge(prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
};

},{"../utils":48}],29:[function(require,module,exports){
'use strict';

var AxiosError = require('./AxiosError');

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
};

},{"./AxiosError":24}],30:[function(require,module,exports){
'use strict';

var utils = require('./../utils');
var defaults = require('../defaults');

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });

  return data;
};

},{"../defaults":31,"./../utils":48}],31:[function(require,module,exports){
(function (process){(function (){
'use strict';

var utils = require('../utils');
var normalizeHeaderName = require('../helpers/normalizeHeaderName');
var AxiosError = require('../core/AxiosError');
var transitionalDefaults = require('./transitional');
var toFormData = require('../helpers/toFormData');

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = require('../adapters/xhr');
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = require('../adapters/http');
  }
  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {

  transitional: transitionalDefaults,

  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) ||
      utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    var isObjectPayload = utils.isObject(data);
    var contentType = headers && headers['Content-Type'];

    var isFileList;

    if ((isFileList = utils.isFileList(data)) || (isObjectPayload && contentType === 'multipart/form-data')) {
      var _FormData = this.env && this.env.FormData;
      return toFormData(isFileList ? {'files[]': data} : data, _FormData && new _FormData());
    } else if (isObjectPayload || contentType === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional || defaults.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: require('./env/FormData')
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*'
    }
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;

}).call(this)}).call(this,require('_process'))

},{"../adapters/http":18,"../adapters/xhr":18,"../core/AxiosError":24,"../helpers/normalizeHeaderName":41,"../helpers/toFormData":46,"../utils":48,"./env/FormData":42,"./transitional":32,"_process":53}],32:[function(require,module,exports){
'use strict';

module.exports = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

},{}],33:[function(require,module,exports){
module.exports = {
  "version": "0.27.2"
};
},{}],34:[function(require,module,exports){
'use strict';

module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

},{}],35:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

},{"./../utils":48}],36:[function(require,module,exports){
'use strict';

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */
module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
};

},{}],37:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs support document.cookie
    (function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },

        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return (match ? decodeURIComponent(match[3]) : null);
        },

        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    })() :

  // Non standard browser env (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() { return null; },
        remove: function remove() {}
      };
    })()
);

},{"./../utils":48}],38:[function(require,module,exports){
'use strict';

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
};

},{}],39:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
module.exports = function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
};

},{"./../utils":48}],40:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

module.exports = (
  utils.isStandardBrowserEnv() ?

  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
    (function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;

      /**
    * Parse a URL to discover it's components
    *
    * @param {String} url The URL to be parsed
    * @returns {Object}
    */
      function resolveURL(url) {
        var href = url;

        if (msie) {
        // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href);

        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
            urlParsingNode.pathname :
            '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);

      /**
    * Determine if a URL shares the same origin as the current location
    *
    * @param {String} requestURL The URL to test
    * @returns {boolean} True if URL shares the same origin, otherwise false
    */
      return function isURLSameOrigin(requestURL) {
        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
        return (parsed.protocol === originURL.protocol &&
            parsed.host === originURL.host);
      };
    })() :

  // Non standard browser envs (web workers, react-native) lack needed support.
    (function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    })()
);

},{"./../utils":48}],41:[function(require,module,exports){
'use strict';

var utils = require('../utils');

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

},{"../utils":48}],42:[function(require,module,exports){
// eslint-disable-next-line strict
module.exports = null;

},{}],43:[function(require,module,exports){
'use strict';

var utils = require('./../utils');

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = [
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) { return parsed; }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

},{"./../utils":48}],44:[function(require,module,exports){
'use strict';

module.exports = function parseProtocol(url) {
  var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
};

},{}],45:[function(require,module,exports){
'use strict';

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */
module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

},{}],46:[function(require,module,exports){
(function (Buffer){(function (){
'use strict';

var utils = require('../utils');

/**
 * Convert a data object to FormData
 * @param {Object} obj
 * @param {?Object} [formData]
 * @returns {Object}
 **/

function toFormData(obj, formData) {
  // eslint-disable-next-line no-param-reassign
  formData = formData || new FormData();

  var stack = [];

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  function build(data, parentKey) {
    if (utils.isPlainObject(data) || utils.isArray(data)) {
      if (stack.indexOf(data) !== -1) {
        throw Error('Circular reference detected in ' + parentKey);
      }

      stack.push(data);

      utils.forEach(data, function each(value, key) {
        if (utils.isUndefined(value)) return;
        var fullKey = parentKey ? parentKey + '.' + key : key;
        var arr;

        if (value && !parentKey && typeof value === 'object') {
          if (utils.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (utils.endsWith(key, '[]') && (arr = utils.toArray(value))) {
            // eslint-disable-next-line func-names
            arr.forEach(function(el) {
              !utils.isUndefined(el) && formData.append(fullKey, convertValue(el));
            });
            return;
          }
        }

        build(value, fullKey);
      });

      stack.pop();
    } else {
      formData.append(parentKey, convertValue(data));
    }
  }

  build(obj);

  return formData;
}

module.exports = toFormData;

}).call(this)}).call(this,require("buffer").Buffer)

},{"../utils":48,"buffer":50}],47:[function(require,module,exports){
'use strict';

var VERSION = require('../env/data').version;
var AxiosError = require('../core/AxiosError');

var validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

var deprecatedWarnings = {};

/**
 * Transitional option validator
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return function(value, opt, opts) {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  var keys = Object.keys(options);
  var i = keys.length;
  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];
    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

module.exports = {
  assertOptions: assertOptions,
  validators: validators
};

},{"../core/AxiosError":24,"../env/data":33}],48:[function(require,module,exports){
'use strict';

var bind = require('./helpers/bind');

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

// eslint-disable-next-line func-names
var kindOf = (function(cache) {
  // eslint-disable-next-line func-names
  return function(thing) {
    var str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  };
})(Object.create(null));

function kindOfTest(type) {
  type = type.toLowerCase();
  return function isKindOf(thing) {
    return kindOf(thing) === type;
  };
}

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return Array.isArray(val);
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
var isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && typeof val === 'object';
}

/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */
function isPlainObject(val) {
  if (kindOf(val) !== 'object') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}

/**
 * Determine if a value is a Date
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
var isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
var isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
var isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} thing The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(thing) {
  var pattern = '[object FormData]';
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) ||
    toString.call(thing) === pattern ||
    (isFunction(thing.toString) && thing.toString() === pattern)
  );
}

/**
 * Determine if a value is a URLSearchParams object
 * @function
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
var isURLSearchParams = kindOfTest('URLSearchParams');

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                           navigator.product === 'NativeScript' ||
                                           navigator.product === 'NS')) {
    return false;
  }
  return (
    typeof window !== 'undefined' &&
    typeof document !== 'undefined'
  );
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */
function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 */

function inherits(constructor, superConstructor, props, descriptors) {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function} [filter]
 * @returns {Object}
 */

function toFlatObject(sourceObj, destObj, filter) {
  var props;
  var i;
  var prop;
  var merged = {};

  destObj = destObj || {};

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if (!merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = Object.getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/*
 * determines whether a string ends with the characters of a specified string
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 * @returns {boolean}
 */
function endsWith(str, searchString, position) {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  var lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object
 * @param {*} [thing]
 * @returns {Array}
 */
function toArray(thing) {
  if (!thing) return null;
  var i = thing.length;
  if (isUndefined(i)) return null;
  var arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

// eslint-disable-next-line func-names
var isTypedArray = (function(TypedArray) {
  // eslint-disable-next-line func-names
  return function(thing) {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && Object.getPrototypeOf(Uint8Array));

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM,
  inherits: inherits,
  toFlatObject: toFlatObject,
  kindOf: kindOf,
  kindOfTest: kindOfTest,
  endsWith: endsWith,
  toArray: toArray,
  isTypedArray: isTypedArray,
  isFileList: isFileList
};

},{"./helpers/bind":34}],49:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],50:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)

},{"base64-js":49,"buffer":50,"ieee754":51}],51:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],52:[function(require,module,exports){
(function (global,Buffer){(function (){
//
// THIS FILE IS AUTOMATICALLY GENERATED! DO NOT EDIT BY HAND!
//
;
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? module.exports = factory()
        : typeof define === 'function' && define.amd
            ? define(factory) :
            // cf. https://github.com/dankogai/js-base64/issues/119
            (function () {
                // existing version for noConflict()
                var _Base64 = global.Base64;
                var gBase64 = factory();
                gBase64.noConflict = function () {
                    global.Base64 = _Base64;
                    return gBase64;
                };
                if (global.Meteor) { // Meteor.js
                    Base64 = gBase64;
                }
                global.Base64 = gBase64;
            })();
}((typeof self !== 'undefined' ? self
    : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
            : this), function () {
    'use strict';
    /**
     *  base64.ts
     *
     *  Licensed under the BSD 3-Clause License.
     *    http://opensource.org/licenses/BSD-3-Clause
     *
     *  References:
     *    http://en.wikipedia.org/wiki/Base64
     *
     * @author Dan Kogai (https://github.com/dankogai)
     */
    var version = '3.7.2';
    /**
     * @deprecated use lowercase `version`.
     */
    var VERSION = version;
    var _hasatob = typeof atob === 'function';
    var _hasbtoa = typeof btoa === 'function';
    var _hasBuffer = typeof Buffer === 'function';
    var _TD = typeof TextDecoder === 'function' ? new TextDecoder() : undefined;
    var _TE = typeof TextEncoder === 'function' ? new TextEncoder() : undefined;
    var b64ch = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var b64chs = Array.prototype.slice.call(b64ch);
    var b64tab = (function (a) {
        var tab = {};
        a.forEach(function (c, i) { return tab[c] = i; });
        return tab;
    })(b64chs);
    var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
    var _fromCC = String.fromCharCode.bind(String);
    var _U8Afrom = typeof Uint8Array.from === 'function'
        ? Uint8Array.from.bind(Uint8Array)
        : function (it, fn) {
            if (fn === void 0) { fn = function (x) { return x; }; }
            return new Uint8Array(Array.prototype.slice.call(it, 0).map(fn));
        };
    var _mkUriSafe = function (src) { return src
        .replace(/=/g, '').replace(/[+\/]/g, function (m0) { return m0 == '+' ? '-' : '_'; }); };
    var _tidyB64 = function (s) { return s.replace(/[^A-Za-z0-9\+\/]/g, ''); };
    /**
     * polyfill version of `btoa`
     */
    var btoaPolyfill = function (bin) {
        // console.log('polyfilled');
        var u32, c0, c1, c2, asc = '';
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length;) {
            if ((c0 = bin.charCodeAt(i++)) > 255 ||
                (c1 = bin.charCodeAt(i++)) > 255 ||
                (c2 = bin.charCodeAt(i++)) > 255)
                throw new TypeError('invalid character found');
            u32 = (c0 << 16) | (c1 << 8) | c2;
            asc += b64chs[u32 >> 18 & 63]
                + b64chs[u32 >> 12 & 63]
                + b64chs[u32 >> 6 & 63]
                + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
    };
    /**
     * does what `window.btoa` of web browsers do.
     * @param {String} bin binary string
     * @returns {string} Base64-encoded string
     */
    var _btoa = _hasbtoa ? function (bin) { return btoa(bin); }
        : _hasBuffer ? function (bin) { return Buffer.from(bin, 'binary').toString('base64'); }
            : btoaPolyfill;
    var _fromUint8Array = _hasBuffer
        ? function (u8a) { return Buffer.from(u8a).toString('base64'); }
        : function (u8a) {
            // cf. https://stackoverflow.com/questions/12710001/how-to-convert-uint8-array-to-base64-encoded-string/12713326#12713326
            var maxargs = 0x1000;
            var strs = [];
            for (var i = 0, l = u8a.length; i < l; i += maxargs) {
                strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
            }
            return _btoa(strs.join(''));
        };
    /**
     * converts a Uint8Array to a Base64 string.
     * @param {boolean} [urlsafe] URL-and-filename-safe a la RFC4648 §5
     * @returns {string} Base64 string
     */
    var fromUint8Array = function (u8a, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
    };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const utob = (src: string) => unescape(encodeURIComponent(src));
    // reverting good old fationed regexp
    var cb_utob = function (c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (_fromCC(0xc0 | (cc >>> 6))
                    + _fromCC(0x80 | (cc & 0x3f)))
                    : (_fromCC(0xe0 | ((cc >>> 12) & 0x0f))
                        + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                        + _fromCC(0x80 | (cc & 0x3f)));
        }
        else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (_fromCC(0xf0 | ((cc >>> 18) & 0x07))
                + _fromCC(0x80 | ((cc >>> 12) & 0x3f))
                + _fromCC(0x80 | ((cc >>> 6) & 0x3f))
                + _fromCC(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-8 string
     * @returns {string} UTF-16 string
     */
    var utob = function (u) { return u.replace(re_utob, cb_utob); };
    //
    var _encode = _hasBuffer
        ? function (s) { return Buffer.from(s, 'utf8').toString('base64'); }
        : _TE
            ? function (s) { return _fromUint8Array(_TE.encode(s)); }
            : function (s) { return _btoa(utob(s)); };
    /**
     * converts a UTF-8-encoded string to a Base64 string.
     * @param {boolean} [urlsafe] if `true` make the result URL-safe
     * @returns {string} Base64 string
     */
    var encode = function (src, urlsafe) {
        if (urlsafe === void 0) { urlsafe = false; }
        return urlsafe
            ? _mkUriSafe(_encode(src))
            : _encode(src);
    };
    /**
     * converts a UTF-8-encoded string to URL-safe Base64 RFC4648 §5.
     * @returns {string} Base64 string
     */
    var encodeURI = function (src) { return encode(src, true); };
    // This trick is found broken https://github.com/dankogai/js-base64/issues/130
    // const btou = (src: string) => decodeURIComponent(escape(src));
    // reverting good old fationed regexp
    var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
    var cb_btou = function (cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                    | ((0x3f & cccc.charCodeAt(1)) << 12)
                    | ((0x3f & cccc.charCodeAt(2)) << 6)
                    | (0x3f & cccc.charCodeAt(3)), offset = cp - 0x10000;
                return (_fromCC((offset >>> 10) + 0xD800)
                    + _fromCC((offset & 0x3FF) + 0xDC00));
            case 3:
                return _fromCC(((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    | (0x3f & cccc.charCodeAt(2)));
            default:
                return _fromCC(((0x1f & cccc.charCodeAt(0)) << 6)
                    | (0x3f & cccc.charCodeAt(1)));
        }
    };
    /**
     * @deprecated should have been internal use only.
     * @param {string} src UTF-16 string
     * @returns {string} UTF-8 string
     */
    var btou = function (b) { return b.replace(re_btou, cb_btou); };
    /**
     * polyfill version of `atob`
     */
    var atobPolyfill = function (asc) {
        // console.log('polyfilled');
        asc = asc.replace(/\s+/g, '');
        if (!b64re.test(asc))
            throw new TypeError('malformed base64.');
        asc += '=='.slice(2 - (asc.length & 3));
        var u24, bin = '', r1, r2;
        for (var i = 0; i < asc.length;) {
            u24 = b64tab[asc.charAt(i++)] << 18
                | b64tab[asc.charAt(i++)] << 12
                | (r1 = b64tab[asc.charAt(i++)]) << 6
                | (r2 = b64tab[asc.charAt(i++)]);
            bin += r1 === 64 ? _fromCC(u24 >> 16 & 255)
                : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255)
                    : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
    };
    /**
     * does what `window.atob` of web browsers do.
     * @param {String} asc Base64-encoded string
     * @returns {string} binary string
     */
    var _atob = _hasatob ? function (asc) { return atob(_tidyB64(asc)); }
        : _hasBuffer ? function (asc) { return Buffer.from(asc, 'base64').toString('binary'); }
            : atobPolyfill;
    //
    var _toUint8Array = _hasBuffer
        ? function (a) { return _U8Afrom(Buffer.from(a, 'base64')); }
        : function (a) { return _U8Afrom(_atob(a), function (c) { return c.charCodeAt(0); }); };
    /**
     * converts a Base64 string to a Uint8Array.
     */
    var toUint8Array = function (a) { return _toUint8Array(_unURI(a)); };
    //
    var _decode = _hasBuffer
        ? function (a) { return Buffer.from(a, 'base64').toString('utf8'); }
        : _TD
            ? function (a) { return _TD.decode(_toUint8Array(a)); }
            : function (a) { return btou(_atob(a)); };
    var _unURI = function (a) { return _tidyB64(a.replace(/[-_]/g, function (m0) { return m0 == '-' ? '+' : '/'; })); };
    /**
     * converts a Base64 string to a UTF-8 string.
     * @param {String} src Base64 string.  Both normal and URL-safe are supported
     * @returns {string} UTF-8 string
     */
    var decode = function (src) { return _decode(_unURI(src)); };
    /**
     * check if a value is a valid Base64 string
     * @param {String} src a value to check
      */
    var isValid = function (src) {
        if (typeof src !== 'string')
            return false;
        var s = src.replace(/\s+/g, '').replace(/={0,2}$/, '');
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
    };
    //
    var _noEnum = function (v) {
        return {
            value: v, enumerable: false, writable: true, configurable: true
        };
    };
    /**
     * extend String.prototype with relevant methods
     */
    var extendString = function () {
        var _add = function (name, body) { return Object.defineProperty(String.prototype, name, _noEnum(body)); };
        _add('fromBase64', function () { return decode(this); });
        _add('toBase64', function (urlsafe) { return encode(this, urlsafe); });
        _add('toBase64URI', function () { return encode(this, true); });
        _add('toBase64URL', function () { return encode(this, true); });
        _add('toUint8Array', function () { return toUint8Array(this); });
    };
    /**
     * extend Uint8Array.prototype with relevant methods
     */
    var extendUint8Array = function () {
        var _add = function (name, body) { return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body)); };
        _add('toBase64', function (urlsafe) { return fromUint8Array(this, urlsafe); });
        _add('toBase64URI', function () { return fromUint8Array(this, true); });
        _add('toBase64URL', function () { return fromUint8Array(this, true); });
    };
    /**
     * extend Builtin prototypes with relevant methods
     */
    var extendBuiltins = function () {
        extendString();
        extendUint8Array();
    };
    var gBase64 = {
        version: version,
        VERSION: VERSION,
        atob: _atob,
        atobPolyfill: atobPolyfill,
        btoa: _btoa,
        btoaPolyfill: btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode: encode,
        encodeURI: encodeURI,
        encodeURL: encodeURI,
        utob: utob,
        btou: btou,
        decode: decode,
        isValid: isValid,
        fromUint8Array: fromUint8Array,
        toUint8Array: toUint8Array,
        extendString: extendString,
        extendUint8Array: extendUint8Array,
        extendBuiltins: extendBuiltins
    };
    //
    // export Base64 to the namespace
    //
    // ES5 is yet to have Object.assign() that may make transpilers unhappy.
    // gBase64.Base64 = Object.assign({}, gBase64);
    gBase64.Base64 = {};
    Object.keys(gBase64).forEach(function (k) { return gBase64.Base64[k] = gBase64[k]; });
    return gBase64;
}));

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)

},{"buffer":50}],53:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],54:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty
  , undef;

/**
 * Decode a URI encoded string.
 *
 * @param {String} input The URI encoded string.
 * @returns {String|Null} The decoded string.
 * @api private
 */
function decode(input) {
  try {
    return decodeURIComponent(input.replace(/\+/g, ' '));
  } catch (e) {
    return null;
  }
}

/**
 * Attempts to encode a given input.
 *
 * @param {String} input The string that needs to be encoded.
 * @returns {String|Null} The encoded string.
 * @api private
 */
function encode(input) {
  try {
    return encodeURIComponent(input);
  } catch (e) {
    return null;
  }
}

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?#&]+)=?([^&]*)/g
    , result = {}
    , part;

  while (part = parser.exec(query)) {
    var key = decode(part[1])
      , value = decode(part[2]);

    //
    // Prevent overriding of existing properties. This ensures that build-in
    // methods like `toString` or __proto__ are not overriden by malicious
    // querystrings.
    //
    // In the case if failed decoding, we want to omit the key/value pairs
    // from the result.
    //
    if (key === null || value === null || key in result) continue;
    result[key] = value;
  }

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = []
    , value
    , key;

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (key in obj) {
    if (has.call(obj, key)) {
      value = obj[key];

      //
      // Edge cases where we actually want to encode the value to an empty
      // string instead of the stringified value.
      //
      if (!value && (value === null || value === undef || isNaN(value))) {
        value = '';
      }

      key = encode(key);
      value = encode(value);

      //
      // If we failed to encode the strings, we should bail out as we don't
      // want to add invalid strings to the query.
      //
      if (key === null || value === null) continue;
      pairs.push(key +'='+ value);
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],55:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = GeneratorFunctionPrototype;
  define(Gp, "constructor", GeneratorFunctionPrototype);
  define(GeneratorFunctionPrototype, "constructor", GeneratorFunction);
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  });
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  define(Gp, iteratorSymbol, function() {
    return this;
  });

  define(Gp, "toString", function() {
    return "[object Generator]";
  });

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, in modern engines
  // we can explicitly access globalThis. In older engines we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  if (typeof globalThis === "object") {
    globalThis.regeneratorRuntime = runtime;
  } else {
    Function("r", "regeneratorRuntime = r")(runtime);
  }
}

},{}],56:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 21;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],57:[function(require,module,exports){
(function (global){(function (){
'use strict';

var required = require('requires-port')
  , qs = require('querystringify')
  , controlOrWhitespace = /^[\x00-\x20\u00a0\u1680\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]+/
  , CRHTLF = /[\n\r\t]/g
  , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\/\//
  , port = /:\d+$/
  , protocolre = /^([a-z][a-z0-9.+-]*:)?(\/\/)?([\\/]+)?([\S\s]*)/i
  , windowsDriveLetter = /^[a-zA-Z]:/;

/**
 * Remove control characters and whitespace from the beginning of a string.
 *
 * @param {Object|String} str String to trim.
 * @returns {String} A new string representing `str` stripped of control
 *     characters and whitespace from its beginning.
 * @public
 */
function trimLeft(str) {
  return (str ? str : '').toString().replace(controlOrWhitespace, '');
}

/**
 * These are the parse rules for the URL parser, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var rules = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  function sanitize(address, url) {     // Sanitize what is left of the address
    return isSpecial(url.protocol) ? address.replace(/\\/g, '/') : address;
  },
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/:(\d*)$/, 'port', undefined, 1],    // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 };

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object|String} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @public
 */
function lolcation(loc) {
  var globalVar;

  if (typeof window !== 'undefined') globalVar = window;
  else if (typeof global !== 'undefined') globalVar = global;
  else if (typeof self !== 'undefined') globalVar = self;
  else globalVar = {};

  var location = globalVar.location || {};
  loc = loc || location;

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new Url(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new Url(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) {
    for (key in loc) {
      if (key in ignore) continue;
      finaldestination[key] = loc[key];
    }

    if (finaldestination.slashes === undefined) {
      finaldestination.slashes = slashes.test(loc.href);
    }
  }

  return finaldestination;
}

/**
 * Check whether a protocol scheme is special.
 *
 * @param {String} The protocol scheme of the URL
 * @return {Boolean} `true` if the protocol scheme is special, else `false`
 * @private
 */
function isSpecial(scheme) {
  return (
    scheme === 'file:' ||
    scheme === 'ftp:' ||
    scheme === 'http:' ||
    scheme === 'https:' ||
    scheme === 'ws:' ||
    scheme === 'wss:'
  );
}

/**
 * @typedef ProtocolExtract
 * @type Object
 * @property {String} protocol Protocol matched in the URL, in lowercase.
 * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
 * @property {String} rest Rest of the URL that is not part of the protocol.
 */

/**
 * Extract protocol information from a URL with/without double slash ("//").
 *
 * @param {String} address URL we want to extract from.
 * @param {Object} location
 * @return {ProtocolExtract} Extracted information.
 * @private
 */
function extractProtocol(address, location) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');
  location = location || {};

  var match = protocolre.exec(address);
  var protocol = match[1] ? match[1].toLowerCase() : '';
  var forwardSlashes = !!match[2];
  var otherSlashes = !!match[3];
  var slashesCount = 0;
  var rest;

  if (forwardSlashes) {
    if (otherSlashes) {
      rest = match[2] + match[3] + match[4];
      slashesCount = match[2].length + match[3].length;
    } else {
      rest = match[2] + match[4];
      slashesCount = match[2].length;
    }
  } else {
    if (otherSlashes) {
      rest = match[3] + match[4];
      slashesCount = match[3].length;
    } else {
      rest = match[4]
    }
  }

  if (protocol === 'file:') {
    if (slashesCount >= 2) {
      rest = rest.slice(2);
    }
  } else if (isSpecial(protocol)) {
    rest = match[4];
  } else if (protocol) {
    if (forwardSlashes) {
      rest = rest.slice(2);
    }
  } else if (slashesCount >= 2 && isSpecial(location.protocol)) {
    rest = match[4];
  }

  return {
    protocol: protocol,
    slashes: forwardSlashes || isSpecial(protocol),
    slashesCount: slashesCount,
    rest: rest
  };
}

/**
 * Resolve a relative URL pathname against a base URL pathname.
 *
 * @param {String} relative Pathname of the relative URL.
 * @param {String} base Pathname of the base URL.
 * @return {String} Resolved pathname.
 * @private
 */
function resolve(relative, base) {
  if (relative === '') return base;

  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
    , i = path.length
    , last = path[i - 1]
    , unshift = false
    , up = 0;

  while (i--) {
    if (path[i] === '.') {
      path.splice(i, 1);
    } else if (path[i] === '..') {
      path.splice(i, 1);
      up++;
    } else if (up) {
      if (i === 0) unshift = true;
      path.splice(i, 1);
      up--;
    }
  }

  if (unshift) path.unshift('');
  if (last === '.' || last === '..') path.push('');

  return path.join('/');
}

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my OCD.
 *
 * It is worth noting that we should not use `URL` as class name to prevent
 * clashes with the global URL instance that got introduced in browsers.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Object|String} [location] Location defaults for relative paths.
 * @param {Boolean|Function} [parser] Parser for the query string.
 * @private
 */
function Url(address, location, parser) {
  address = trimLeft(address);
  address = address.replace(CRHTLF, '');

  if (!(this instanceof Url)) {
    return new Url(address, location, parser);
  }

  var relative, extracted, parse, instruction, index, key
    , instructions = rules.slice()
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) parser = qs.parse;

  location = lolcation(location);

  //
  // Extract protocol information before running the instructions.
  //
  extracted = extractProtocol(address || '', location);
  relative = !extracted.protocol && !extracted.slashes;
  url.slashes = extracted.slashes || relative && location.slashes;
  url.protocol = extracted.protocol || location.protocol || '';
  address = extracted.rest;

  //
  // When the authority component is absent the URL starts with a path
  // component.
  //
  if (
    extracted.protocol === 'file:' && (
      extracted.slashesCount !== 2 || windowsDriveLetter.test(address)) ||
    (!extracted.slashes &&
      (extracted.protocol ||
        extracted.slashesCount < 2 ||
        !isSpecial(url.protocol)))
  ) {
    instructions[3] = [/(.*)/, 'pathname'];
  }

  for (; i < instructions.length; i++) {
    instruction = instructions[i];

    if (typeof instruction === 'function') {
      address = instruction(address, url);
      continue;
    }

    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      index = parse === '@'
        ? address.lastIndexOf(parse)
        : address.indexOf(parse);

      if (~index) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if ((index = parse.exec(address))) {
      url[key] = index[1];
      address = address.slice(0, index.index);
    }

    url[key] = url[key] || (
      relative && instruction[3] ? location[key] || '' : ''
    );

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) url[key] = url[key].toLowerCase();
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // If the URL is relative, resolve the pathname against the base URL.
  //
  if (
      relative
    && location.slashes
    && url.pathname.charAt(0) !== '/'
    && (url.pathname !== '' || location.pathname !== '')
  ) {
    url.pathname = resolve(url.pathname, location.pathname);
  }

  //
  // Default to a / for pathname if none exists. This normalizes the URL
  // to always have a /
  //
  if (url.pathname.charAt(0) !== '/' && isSpecial(url.protocol)) {
    url.pathname = '/' + url.pathname;
  }

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';

  if (url.auth) {
    index = url.auth.indexOf(':');

    if (~index) {
      url.username = url.auth.slice(0, index);
      url.username = encodeURIComponent(decodeURIComponent(url.username));

      url.password = url.auth.slice(index + 1);
      url.password = encodeURIComponent(decodeURIComponent(url.password))
    } else {
      url.username = encodeURIComponent(decodeURIComponent(url.auth));
    }

    url.auth = url.password ? url.username +':'+ url.password : url.username;
  }

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} part          Property we need to adjust.
 * @param {Mixed} value          The newly assigned value.
 * @param {Boolean|Function} fn  When setting the query, it will be the function
 *                               used to parse the query.
 *                               When setting the protocol, double slash will be
 *                               removed from the final url if it is true.
 * @returns {URL} URL instance for chaining.
 * @public
 */
function set(part, value, fn) {
  var url = this;

  switch (part) {
    case 'query':
      if ('string' === typeof value && value.length) {
        value = (fn || qs.parse)(value);
      }

      url[part] = value;
      break;

    case 'port':
      url[part] = value;

      if (!required(value, url.protocol)) {
        url.host = url.hostname;
        url[part] = '';
      } else if (value) {
        url.host = url.hostname +':'+ value;
      }

      break;

    case 'hostname':
      url[part] = value;

      if (url.port) value += ':'+ url.port;
      url.host = value;
      break;

    case 'host':
      url[part] = value;

      if (port.test(value)) {
        value = value.split(':');
        url.port = value.pop();
        url.hostname = value.join(':');
      } else {
        url.hostname = value;
        url.port = '';
      }

      break;

    case 'protocol':
      url.protocol = value.toLowerCase();
      url.slashes = !fn;
      break;

    case 'pathname':
    case 'hash':
      if (value) {
        var char = part === 'pathname' ? '/' : '#';
        url[part] = value.charAt(0) !== char ? char + value : value;
      } else {
        url[part] = value;
      }
      break;

    case 'username':
    case 'password':
      url[part] = encodeURIComponent(value);
      break;

    case 'auth':
      var index = value.indexOf(':');

      if (~index) {
        url.username = value.slice(0, index);
        url.username = encodeURIComponent(decodeURIComponent(url.username));

        url.password = value.slice(index + 1);
        url.password = encodeURIComponent(decodeURIComponent(url.password));
      } else {
        url.username = encodeURIComponent(decodeURIComponent(value));
      }
  }

  for (var i = 0; i < rules.length; i++) {
    var ins = rules[i];

    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
  }

  url.auth = url.password ? url.username +':'+ url.password : url.username;

  url.origin = url.protocol !== 'file:' && isSpecial(url.protocol) && url.host
    ? url.protocol +'//'+ url.host
    : 'null';

  url.href = url.toString();

  return url;
}

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String} Compiled version of the URL.
 * @public
 */
function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , host = url.host
    , protocol = url.protocol;

  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';

  var result =
    protocol +
    ((url.protocol && url.slashes) || isSpecial(url.protocol) ? '//' : '');

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  } else if (url.password) {
    result += ':'+ url.password;
    result += '@';
  } else if (
    url.protocol !== 'file:' &&
    isSpecial(url.protocol) &&
    !host &&
    url.pathname !== '/'
  ) {
    //
    // Add back the empty userinfo, otherwise the original invalid URL
    // might be transformed into a valid one with `url.pathname` as host.
    //
    result += '@';
  }

  //
  // Trailing colon is removed from `url.host` when it is parsed. If it still
  // ends with a colon, then add back the trailing colon that was removed. This
  // prevents an invalid URL from being transformed into a valid one.
  //
  if (host[host.length - 1] === ':' || (port.test(url.hostname) && !url.port)) {
    host += ':';
  }

  result += host + url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
}

Url.prototype = { set: set, toString: toString };

//
// Expose the URL parser and some additional properties that might be useful for
// others or testing.
//
Url.extractProtocol = extractProtocol;
Url.location = lolcation;
Url.trimLeft = trimLeft;
Url.qs = qs;

module.exports = Url;

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"querystringify":54,"requires-port":56}],58:[function(require,module,exports){
"use strict";

require("regenerator-runtime/runtime");

// The regenerator runtime is needed since the test use functions
// with the async/await keywords. See
// https://babeljs.io/docs/en/babel-plugin-transform-regenerator
beforeEach(function () {
  // Clear localStorage before every test to prevent stored URLs to
  // interfere with our setup.
  localStorage.clear();
});

require('./test-common');

require('./test-browser-specific');

require('./test-parallel-uploads');

require('./test-terminate');

require('./test-end-to-end');

},{"./test-browser-specific":61,"./test-common":62,"./test-end-to-end":63,"./test-parallel-uploads":64,"./test-terminate":65,"regenerator-runtime/runtime":55}],59:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

module.exports = /*#__PURE__*/function () {
  var _assertUrlStorage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(urlStorage) {
    var result, key1, key2, key3;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return urlStorage.findAllUploads();

          case 2:
            result = _context.sent;
            expect(result).toEqual([]); // Add a few uploads into the storage

            _context.next = 6;
            return urlStorage.addUpload('fingerprintA', {
              id: 1
            });

          case 6:
            key1 = _context.sent;
            _context.next = 9;
            return urlStorage.addUpload('fingerprintA', {
              id: 2
            });

          case 9:
            key2 = _context.sent;
            _context.next = 12;
            return urlStorage.addUpload('fingerprintB', {
              id: 3
            });

          case 12:
            key3 = _context.sent;
            expect(/^tus::fingerprintA::/.test(key1)).toBe(true);
            expect(/^tus::fingerprintA::/.test(key2)).toBe(true);
            expect(/^tus::fingerprintB::/.test(key3)).toBe(true); // Query the just stored uploads individually

            _context.next = 18;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 18:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }]);
            _context.next = 23;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 23:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 3,
              urlStorageKey: key3
            }]); // Check that we can retrieve all stored uploads

            _context.next = 28;
            return urlStorage.findAllUploads();

          case 28:
            result = _context.sent;
            sort(result);
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }, {
              id: 2,
              urlStorageKey: key2
            }, {
              id: 3,
              urlStorageKey: key3
            }]); // Check that it can remove an upload and will not return it back

            _context.next = 33;
            return urlStorage.removeUpload(key2);

          case 33:
            _context.next = 35;
            return urlStorage.removeUpload(key3);

          case 35:
            _context.next = 37;
            return urlStorage.findUploadsByFingerprint('fingerprintA');

          case 37:
            result = _context.sent;
            expect(result).toEqual([{
              id: 1,
              urlStorageKey: key1
            }]);
            _context.next = 41;
            return urlStorage.findUploadsByFingerprint('fingerprintB');

          case 41:
            result = _context.sent;
            expect(result).toEqual([]);

          case 43:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  function assertUrlStorage(_x) {
    return _assertUrlStorage.apply(this, arguments);
  }

  return assertUrlStorage;
}(); // Sort the results from the URL storage since the order in not deterministic.


function sort(result) {
  result.sort(function (a, b) {
    return a.id - b.id;
  });
}

},{}],60:[function(require,module,exports){
(function (Buffer){(function (){
"use strict";

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable max-classes-per-file */
var isBrowser = typeof window !== 'undefined';
var isNode = !isBrowser;
/**
 * Obtain a platform specific buffer object, which can be
 * handled by tus-js-client.
 */

function getBlob(str) {
  if (isNode) {
    return Buffer.from(str);
  }

  return new Blob(str.split(''));
}
/**
 * Create a promise and obtain the resolve/reject functions
 * outside of the Promise callback.
 */


function flatPromise() {
  var resolveFn;
  var rejectFn;
  var p = new Promise(function (resolve, reject) {
    resolveFn = resolve;
    rejectFn = reject;
  });
  return [p, resolveFn, rejectFn];
}
/**
 * Create a spy-able function which resolves a Promise
 * once it is called.
 */


function waitableFunction() {
  var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'func';

  var _flatPromise = flatPromise(),
      _flatPromise2 = _slicedToArray(_flatPromise, 2),
      promise = _flatPromise2[0],
      resolve = _flatPromise2[1];

  var fn = jasmine.createSpy(name, resolve).and.callThrough();
  fn.toBeCalled = promise;
  return fn;
}
/**
 * Create a Promise that resolves after the specified duration.
 */


function wait(delay) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, delay, 'timed out');
  });
}
/**
 * TestHttpStack implements the HTTP stack interface for tus-js-client
 * and can be used to assert outgoing requests and respond with mock data.
 */


var TestHttpStack = /*#__PURE__*/function () {
  function TestHttpStack() {
    _classCallCheck(this, TestHttpStack);

    this._pendingRequests = [];
    this._pendingWaits = [];
  }

  _createClass(TestHttpStack, [{
    key: "createRequest",
    value: function createRequest(method, url) {
      var _this = this;

      return new TestRequest(method, url, function (req) {
        if (_this._pendingWaits.length >= 1) {
          var handler = _this._pendingWaits.shift();

          handler(req);
          return;
        }

        _this._pendingRequests.push(req);
      });
    }
  }, {
    key: "nextRequest",
    value: function nextRequest() {
      var _this2 = this;

      if (this._pendingRequests.length >= 1) {
        return Promise.resolve(this._pendingRequests.shift());
      }

      return new Promise(function (resolve) {
        _this2._pendingWaits.push(resolve);
      });
    }
  }]);

  return TestHttpStack;
}();

var TestRequest = /*#__PURE__*/function () {
  function TestRequest(method, url, onRequestSend) {
    _classCallCheck(this, TestRequest);

    this.method = method;
    this.url = url;
    this.requestHeaders = {};
    this.body = null;
    this._onRequestSend = onRequestSend;

    this._onProgress = function () {};

    var _flatPromise3 = flatPromise();

    var _flatPromise4 = _slicedToArray(_flatPromise3, 3);

    this._requestPromise = _flatPromise4[0];
    this._resolveRequest = _flatPromise4[1];
    this._rejectRequest = _flatPromise4[2];
  }

  _createClass(TestRequest, [{
    key: "getMethod",
    value: function getMethod() {
      return this.method;
    }
  }, {
    key: "getURL",
    value: function getURL() {
      return this.url;
    }
  }, {
    key: "setHeader",
    value: function setHeader(header, value) {
      this.requestHeaders[header] = value;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this.requestHeaders[header] || null;
    }
  }, {
    key: "setProgressHandler",
    value: function setProgressHandler(progressHandler) {
      this._onProgress = progressHandler;
    }
  }, {
    key: "send",
    value: function send() {
      var body = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      this.body = body;

      if (body) {
        this._onProgress(0);

        this._onProgress(body.length || body.size || 0);
      }

      this._onRequestSend(this);

      return this._requestPromise;
    }
  }, {
    key: "abort",
    value: function abort() {
      this._rejectRequest(new Error('request aborted'));
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }, {
    key: "respondWith",
    value: function respondWith(resData) {
      resData.responseHeaders = resData.responseHeaders || {};
      var res = new TestResponse(resData);

      this._resolveRequest(res);
    }
  }, {
    key: "responseError",
    value: function responseError(err) {
      this._rejectRequest(err);
    }
  }]);

  return TestRequest;
}();

var TestResponse = /*#__PURE__*/function () {
  function TestResponse(res) {
    _classCallCheck(this, TestResponse);

    this._response = res;
  }

  _createClass(TestResponse, [{
    key: "getStatus",
    value: function getStatus() {
      return this._response.status;
    }
  }, {
    key: "getHeader",
    value: function getHeader(header) {
      return this._response.responseHeaders[header];
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this._response.responseText;
    }
  }, {
    key: "getUnderlyingObject",
    value: function getUnderlyingObject() {
      throw new Error('not implemented');
    }
  }]);

  return TestResponse;
}();

module.exports = {
  TestHttpStack: TestHttpStack,
  waitableFunction: waitableFunction,
  wait: wait,
  getBlob: getBlob
};

}).call(this)}).call(this,require("buffer").Buffer)

},{"buffer":50}],61:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var assertUrlStorage = require('./helpers/assertUrlStorage');

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait;

var tus = require('../..');

describe('tus', function () {
  beforeEach(function () {
    localStorage.clear();
  });
  describe('#Upload', function () {
    it('should resume an upload from a stored url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, file, options, upload, previousUploads, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              localStorage.setItem('tus::fingerprinted::1337', JSON.stringify({
                uploadUrl: 'http://tus.io/uploads/resuming'
              }));
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              _context.next = 9;
              return upload.findPreviousUploads();

            case 9:
              previousUploads = _context.sent;
              expect(previousUploads).toEqual([{
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              }]);
              upload.resumeFromPreviousUpload(previousUploads[0]);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalledWith(file, upload.options);
              _context.next = 16;
              return testStack.nextRequest();

            case 16:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context.next = 23;
              return testStack.nextRequest();

            case 23:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://tus.io/uploads/resuming');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 33:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    describe('storing of upload urls', function () {
      var testStack = new TestHttpStack();
      var options = {
        httpStack: testStack,
        endpoint: 'http://tus.io/uploads',
        fingerprint: function fingerprint() {}
      };

      function startUpload() {
        return _startUpload.apply(this, arguments);
      }

      function _startUpload() {
        _startUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
          var file, upload, req;
          return _regeneratorRuntime().wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  file = new Blob('hello world'.split(''));
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  options.onSuccess = waitableFunction('onSuccess');
                  upload = new tus.Upload(file, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalled();
                  _context4.next = 8;
                  return testStack.nextRequest();

                case 8:
                  req = _context4.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: '/uploads/blargh'
                    }
                  }); // Wait a short delay to allow the Promises to settle

                  _context4.next = 14;
                  return wait(10);

                case 14:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }));
        return _startUpload.apply(this, arguments);
      }

      function finishUpload() {
        return _finishUpload.apply(this, arguments);
      }

      function _finishUpload() {
        _finishUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
          var req;
          return _regeneratorRuntime().wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return testStack.nextRequest();

                case 2:
                  req = _context5.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context5.next = 8;
                  return options.onSuccess.toBeCalled;

                case 8:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }));
        return _finishUpload.apply(this, arguments);
      }

      it('should store and retain with default options', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var key, storedUpload;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                options.removeFingerprintOnSuccess = false;
                _context2.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context2.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(JSON.stringify(storedUpload));

              case 11:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      })));
      it('should store and remove with option removeFingerprintOnSuccess set', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
        var key, storedUpload;
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                options.removeFingerprintOnSuccess = true;
                _context3.next = 3;
                return startUpload();

              case 3:
                key = localStorage.key(0);
                expect(key.indexOf('tus::fingerprinted::')).toBe(0);
                storedUpload = JSON.parse(localStorage.getItem(key));
                expect(storedUpload.uploadUrl).toBe('http://tus.io/uploads/blargh');
                expect(storedUpload.size).toBe(11);
                _context3.next = 10;
                return finishUpload();

              case 10:
                expect(localStorage.getItem(key)).toBe(null);

              case 11:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      })));
    });
    it('should delete upload urls on a 4XX', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = new Blob('hello world'.split(''));
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                uploadUrl: 'http://tus.io/uploads/resuming',
                urlStorageKey: 'tus::fingerprinted::1337'
              });
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 400
              });
              _context6.next = 15;
              return wait(10);

            case 15:
              expect(localStorage.getItem('tus::fingerprinted::1337')).toBe(null);

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    describe('uploading data from a Reader', function () {
      function makeReader(content) {
        var readSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : content.length;
        var reader = {
          value: content.split(''),
          read: function read() {
            var value;
            var done = false;

            if (this.value.length > 0) {
              value = this.value.slice(0, readSize);
              this.value = this.value.slice(readSize);
            } else {
              done = true;
            }

            return Promise.resolve({
              value: value,
              done: done
            });
          },
          cancel: waitableFunction('cancel')
        };
        return reader;
      }

      function assertReaderUpload(_x) {
        return _assertReaderUpload.apply(this, arguments);
      }

      function _assertReaderUpload() {
        _assertReaderUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(_ref5) {
          var readSize, chunkSize, reader, testStack, options, upload, req;
          return _regeneratorRuntime().wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  readSize = _ref5.readSize, chunkSize = _ref5.chunkSize;
                  reader = makeReader('hello world', readSize);
                  testStack = new TestHttpStack();
                  options = {
                    httpStack: testStack,
                    endpoint: 'http://tus.io/uploads',
                    chunkSize: chunkSize,
                    onProgress: waitableFunction('onProgress'),
                    onSuccess: waitableFunction('onSuccess'),
                    fingerprint: function fingerprint() {},
                    uploadLengthDeferred: true
                  };
                  spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                  upload = new tus.Upload(reader, options);
                  upload.start();
                  expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                  _context14.next = 10;
                  return testStack.nextRequest();

                case 10:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads');
                  expect(req.method).toBe('POST');
                  expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                  expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                  req.respondWith({
                    status: 201,
                    responseHeaders: {
                      Location: 'http://tus.io/uploads/blargh'
                    }
                  });
                  _context14.next = 18;
                  return testStack.nextRequest();

                case 18:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(0);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body.length).toBe(11);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 27;
                  return options.onProgress.toBeCalled;

                case 27:
                  expect(options.onProgress).toHaveBeenCalledWith(11, null);
                  _context14.next = 30;
                  return testStack.nextRequest();

                case 30:
                  req = _context14.sent;
                  expect(req.url).toBe('http://tus.io/uploads/blargh');
                  expect(req.method).toBe('PATCH');
                  expect(req.requestHeaders['Upload-Offset']).toBe(11);
                  expect(req.requestHeaders['Upload-Length']).toBe(11);
                  expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                  expect(req.body).toBe(null);
                  req.respondWith({
                    status: 204,
                    responseHeaders: {
                      'Upload-Offset': 11
                    }
                  });
                  _context14.next = 40;
                  return options.onSuccess.toBeCalled;

                case 40:
                  expect(upload.url).toBe('http://tus.io/uploads/blargh');
                  expect(options.onProgress).toHaveBeenCalledWith(11, 11);

                case 42:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }));
        return _assertReaderUpload.apply(this, arguments);
      }

      it('should upload data', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
        return _regeneratorRuntime().wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 100
                });

              case 2:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      })));
      it('should read multiple times from the reader', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
        return _regeneratorRuntime().wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return assertReaderUpload({
                  chunkSize: 100,
                  readSize: 6
                });

              case 2:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      })));
      it('should use multiple PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  chunkSize: 6,
                  onProgress: waitableFunction('onProgress'),
                  onSuccess: waitableFunction('onSuccess'),
                  fingerprint: function fingerprint() {},
                  uploadLengthDeferred: true
                };
                spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
                upload = new tus.Upload(reader, options);
                upload.start();
                expect(options.fingerprint).toHaveBeenCalledWith(reader, upload.options);
                _context9.next = 9;
                return testStack.nextRequest();

              case 9:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(undefined);
                expect(req.requestHeaders['Upload-Defer-Length']).toBe(1);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: 'http://tus.io/uploads/blargh'
                  }
                });
                _context9.next = 17;
                return testStack.nextRequest();

              case 17:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(6);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context9.next = 26;
                return options.onProgress.toBeCalled;

              case 26:
                expect(options.onProgress).toHaveBeenCalledWith(6, null);
                _context9.next = 29;
                return testStack.nextRequest();

              case 29:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(6);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.length).toBe(5);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context9.next = 39;
                return testStack.nextRequest();

              case 39:
                req = _context9.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Offset']).toBe(11);
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body).toBe(null);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context9.next = 49;
                return options.onSuccess.toBeCalled;

              case 49:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');
                expect(options.onProgress).toHaveBeenCalledWith(11, 11);

              case 51:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      })));
      it('should retry the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context10.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 500
                });
                _context10.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context10.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context10.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context10.next = 32;
                return options.onSuccess.toBeCalled;

              case 32:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      })));
      it('should retry the first PATCH request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                reader = makeReader('hello world', 1);
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 11,
                  retryDelays: [10, 10, 10],
                  onSuccess: waitableFunction('onSuccess'),
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context11.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context11.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context11.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 0
                  }
                });
                _context11.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context11.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context11.next = 38;
                return options.onSuccess.toBeCalled;

              case 38:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      })));
      it('should retry following PATCH requests', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
        var reader, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                reader = makeReader('hello world there!');
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start();
                _context12.next = 7;
                return testStack.nextRequest();

              case 7:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/');
                expect(req.method).toBe('POST');
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/files/foo'
                  }
                });
                _context12.next = 13;
                return testStack.nextRequest();

              case 13:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context12.next = 19;
                return testStack.nextRequest();

              case 19:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 500
                });
                _context12.next = 25;
                return testStack.nextRequest();

              case 25:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('HEAD');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 6
                  }
                });
                _context12.next = 31;
                return testStack.nextRequest();

              case 31:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 12
                  }
                });
                _context12.next = 37;
                return testStack.nextRequest();

              case 37:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context12.next = 43;
                return testStack.nextRequest();

              case 43:
                req = _context12.sent;
                expect(req.url).toBe('http://tus.io/files/foo');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Upload-Length']).toBe(18);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 18
                  }
                });
                _context12.next = 50;
                return options.onSuccess.toBeCalled;

              case 50:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      })));
      it('should cancel the reader when aborted', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
        var reader, options, upload;
        return _regeneratorRuntime().wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                reader = makeReader('hello there world');
                options = {
                  httpStack: new TestHttpStack(),
                  endpoint: 'http://tus.io/files/',
                  chunkSize: 6,
                  retryDelays: [10, 10, 10],
                  onSuccess: function onSuccess() {},
                  uploadLengthDeferred: true
                };
                upload = new tus.Upload(reader, options);
                upload.start(); // We wait until the first request arrives, so that the first promises have resolved.

                _context13.next = 6;
                return options.httpStack.nextRequest();

              case 6:
                upload.abort();
                _context13.next = 9;
                return reader.cancel.toBeCalled;

              case 9:
                expect(reader.cancel).toHaveBeenCalled();

              case 10:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      })));
    });
    describe('resolving of URIs', function () {
      // Disable these tests for IE 10 and 11 because it's not possible to overwrite
      // the navigator.product property.
      var isIE = navigator.userAgent.indexOf('Trident/') > 0;

      if (isIE) {
        console.log('Skipping tests for React Native in Internet Explorer'); // eslint-disable-line no-console

        return;
      }

      var originalProduct = navigator.product;
      beforeEach(function () {
        jasmine.Ajax.install(); // Simulate React Native environment to enable URIs as input objects.

        Object.defineProperty(navigator, 'product', {
          value: 'ReactNative',
          configurable: true
        });
      });
      afterEach(function () {
        jasmine.Ajax.uninstall();
        Object.defineProperty(navigator, 'product', {
          value: originalProduct,
          configurable: true
        });
      });
      it('should upload a file from an URI', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
        var file, testStack, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                testStack = new TestHttpStack();
                options = {
                  httpStack: testStack,
                  endpoint: 'http://tus.io/uploads',
                  onSuccess: waitableFunction('onSuccess')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context15.next = 7;
                return wait(0);

              case 7:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.respondWith({
                  status: 200,
                  responseHeaders: {
                    'Upload-Length': 11,
                    'Upload-Offset': 3
                  },
                  response: new Blob('hello world'.split(''))
                });
                _context15.next = 14;
                return testStack.nextRequest();

              case 14:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads');
                expect(req.method).toBe('POST');
                expect(req.requestHeaders['Upload-Length']).toBe(11);
                req.respondWith({
                  status: 201,
                  responseHeaders: {
                    Location: '/uploads/blargh'
                  }
                });
                _context15.next = 21;
                return testStack.nextRequest();

              case 21:
                req = _context15.sent;
                expect(req.url).toBe('http://tus.io/uploads/blargh');
                expect(req.method).toBe('PATCH');
                expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
                expect(req.requestHeaders['Upload-Offset']).toBe(0);
                expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
                expect(req.body.size).toBe(11);
                req.respondWith({
                  status: 204,
                  responseHeaders: {
                    'Upload-Offset': 11
                  }
                });
                _context15.next = 31;
                return options.onSuccess.toBeCalled;

              case 31:
                expect(upload.url).toBe('http://tus.io/uploads/blargh');

              case 32:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15);
      })));
      it("should emit an error if it can't resolve the URI", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
        var file, options, upload, req;
        return _regeneratorRuntime().wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                file = {
                  uri: 'file:///my/file.dat'
                };
                options = {
                  endpoint: 'http://tus.io/uploads',
                  onError: waitableFunction('onError')
                };
                upload = new tus.Upload(file, options);
                upload.start(); // Wait a short interval to make sure that the XHR has been sent.

                _context16.next = 6;
                return wait(0);

              case 6:
                req = jasmine.Ajax.requests.mostRecent();
                expect(req.url).toBe('file:///my/file.dat');
                expect(req.method).toBe('GET');
                expect(req.responseType).toBe('blob');
                req.responseError();
                _context16.next = 13;
                return options.onError.toBeCalled;

              case 13:
                expect(options.onError).toHaveBeenCalledWith(new Error('tus: cannot fetch `file.uri` as Blob, make sure the uri is correct and accessible. [object Object]'));

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16);
      })));
    });
  });
  describe('#LocalStorageUrlStorage', function () {
    it('should allow storing and retrieving uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              _context17.next = 2;
              return assertUrlStorage(tus.defaultOptions.urlStorage);

            case 2:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
  });
});

},{"../..":4,"./helpers/assertUrlStorage":59,"./helpers/utils":60}],62:[function(require,module,exports){
"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..'); // Uncomment to enable debug log from tus-js-client
// tus.enableDebugLog();


describe('tus', function () {
  describe('#isSupported', function () {
    it('should be true', function () {
      expect(tus.isSupported).toBe(true);
    });
  });
  describe('#Upload', function () {
    it('should throw if no error handler is available', function () {
      var upload = new tus.Upload(null);
      expect(upload.start.bind(upload)).toThrowError('tus: no file or stream to upload provided');
    });
    it('should throw if no endpoint and upload URL is provided', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file);
      expect(upload.start.bind(upload)).toThrowError('tus: neither an endpoint or an upload URL is provided');
    });
    it('should upload a file', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello',
                  bar: 'world',
                  nonlatin: 'słońce',
                  number: 100
                },
                withCredentials: true,
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=,bar d29ybGQ=,nonlatin c8WCb8WEY2U=,number MTAw');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/blargh'
                }
              });
              _context.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11); // if (isBrowser) expect(req.withCredentials).toBe(true);

              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context.next = 29;
              return options.onSuccess.toBeCalled;

            case 29:
              expect(upload.url).toBe('https://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 31:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should create an upload if resuming fails', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11); // The upload URL should be cleared when tus-js.client tries to create a new upload.

              expect(upload.url).toBe(null);

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should create an upload using the creation-with-data extension', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context3.next = 19;
              return options.onSuccess.toBeCalled;

            case 19:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(11, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should create an upload with partial data and continue', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadDataDuringCreation: true,
                chunkSize: 6,
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 6
                }
              });
              _context4.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context4.sent;
              // Once the second request has been sent, the progress handler must have been invoked.
              expect(options.onProgress).toHaveBeenCalledWith(6, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(6, 6, 11);
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(6);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh',
                  'Upload-Offset': 11
                }
              });
              _context4.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(5, 11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 36:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
    it("should add the request's body and ID to errors", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
      var testStack, file, options, upload, req, reqId, err;
      return _regeneratorRuntime().wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                addRequestId: true,
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context5.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context5.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              reqId = req.requestHeaders['X-Request-ID'];
              expect(_typeof(reqId)).toBe('string');
              expect(reqId.length).toBe(36);
              req.respondWith({
                status: 500,
                responseText: 'server_error'
              });
              _context5.next = 16;
              return options.onError.toBeCalled;

            case 16:
              err = _context5.sent;
              expect(err.message).toBe("tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: server_error, request id: ".concat(reqId, ")"));
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();

            case 20:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    })));
    it('should invoke the request and response callbacks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/foo',
                onBeforeRequest: function onBeforeRequest(req) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                  expect(req.getMethod()).toBe('HEAD');
                  expect(res.getStatus()).toBe(204);
                  expect(res.getHeader('Upload-Offset')).toBe(11);
                },
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              upload = new tus.Upload(file, options);
              upload.start();
              _context6.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context6.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11,
                  'Upload-Length': 11
                }
              });
              _context6.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 17:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    })));
    it('should throw an error if resuming fails and no endpoint is provided', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                uploadUrl: 'http://tus.io/uploads/resuming',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context7.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context7.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 404
              });
              _context7.next = 14;
              return options.onError.toBeCalled;

            case 14:
              err = _context7.sent;
              expect(err.message).toBe('tus: unable to resume upload (new upload cannot be created without an endpoint), originated from request (method: HEAD, url: http://tus.io/uploads/resuming, response code: 404, response text: , request id: n/a)');

            case 16:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    })));
    it('should resolve relative URLs', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io:1080/files/'
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context8.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context8.sent;
              expect(req.url).toBe('http://tus.io:1080/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '//localhost/uploads/foo'
                }
              });
              _context8.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context8.sent;
              expect(req.url).toBe('http://localhost/uploads/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              expect(upload.url).toBe('http://localhost/uploads/foo');

            case 18:
            case "end":
              return _context8.stop();
          }
        }
      }, _callee8);
    })));
    it('should upload a file in chunks', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                chunkSize: 7,
                onSuccess: waitableFunction('onSuccess'),
                onProgress: function onProgress() {},
                onChunkComplete: function onChunkComplete() {}
              };
              spyOn(options, 'onProgress');
              spyOn(options, 'onChunkComplete');
              upload = new tus.Upload(file, options);
              upload.start();
              _context9.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(11);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/uploads/blargh'
                }
              });
              _context9.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(7);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 7
                }
              });
              _context9.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context9.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(7);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(4);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context9.next = 37;
              return options.onSuccess.toBeCalled;

            case 37:
              expect(upload.url).toBe('http://tus.io/uploads/blargh');
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(7, 7, 11);
              expect(options.onChunkComplete).toHaveBeenCalledWith(4, 11, 11);

            case 41:
            case "end":
              return _context9.stop();
          }
        }
      }, _callee9);
    })));
    it('should add the original request to errors', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                retryDelays: null,
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context10.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context10.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500,
                responseHeaders: {
                  Custom: 'blargh'
                }
              });
              _context10.next = 13;
              return options.onError.toBeCalled;

            case 13:
              err = _context10.sent;
              expect(upload.url).toBe(null);
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: http://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBeDefined();
              expect(err.originalResponse).toBeDefined();
              expect(err.originalResponse.getHeader('Custom')).toBe('blargh');

            case 19:
            case "end":
              return _context10.stop();
          }
        }
      }, _callee10);
    })));
    it('should only create an upload for empty files', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context11.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context11.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(0);
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/empty'
                }
              });
              _context11.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onSuccess).toHaveBeenCalled();

            case 16:
            case "end":
              return _context11.stop();
          }
        }
      }, _callee11);
    })));
    it('should not resume a finished upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                uploadUrl: 'http://tus.io/uploads/resuming'
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context12.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context12.sent;
              expect(req.url).toBe('http://tus.io/uploads/resuming');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': '11',
                  'Upload-Offset': '11'
                }
              });
              _context12.next = 15;
              return options.onSuccess.toBeCalled;

            case 15:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(options.onSuccess).toHaveBeenCalled();

            case 17:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    })));
    it('should resume an upload from a specified url', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee13$(_context13) {
        while (1) {
          switch (_context13.prev = _context13.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction('onSuccess'),
                fingerprint: function fingerprint() {}
              };
              spyOn(options, 'fingerprint').and.resolveTo('fingerprinted');
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              expect(options.fingerprint).toHaveBeenCalled();
              _context13.next = 10;
              return testStack.nextRequest();

            case 10:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context13.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context13.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(11 - 3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context13.next = 27;
              return options.onSuccess.toBeCalled;

            case 27:
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(upload.url).toBe('http://tus.io/files/upload');

            case 29:
            case "end":
              return _context13.stop();
          }
        }
      }, _callee13);
    })));
    it('should resume a previously started upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onSuccess: waitableFunction('onSuccess'),
                onError: function onError() {}
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context14.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'http://tus.io/uploads/blargh'
                }
              });
              _context14.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              upload.abort();
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              upload.start();
              _context14.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context14.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context14.sent;
              expect(req.url).toBe('http://tus.io/uploads/blargh');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context14.next = 33;
              return options.onSuccess.toBeCalled;

            case 33:
              expect(options.onSuccess).toHaveBeenCalled();

            case 34:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14);
    })));
    it('should override the PATCH method', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                overridePatchMethod: true
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context15.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 3
                }
              });
              _context15.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context15.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(3);
              expect(req.requestHeaders['X-HTTP-Method-Override']).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });

            case 21:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15);
    })));
    it('should emit an error if an upload is locked', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                uploadUrl: 'http://tus.io/files/upload',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context16.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context16.sent;
              expect(req.url).toBe('http://tus.io/files/upload');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 423 // Locked

              });
              _context16.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: upload is currently locked; retry later, originated from request (method: HEAD, url: http://tus.io/files/upload, response code: 423, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16);
    })));
    it('should emit an error if no Location header is presented', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/uploads',
                onError: waitableFunction('onError'),
                retryDelays: null
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context17.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context17.sent;
              expect(req.url).toBe('http://tus.io/uploads');
              expect(req.method).toBe('POST'); // The Location header is omitted on purpose here

              req.respondWith({
                status: 201
              });
              _context17.next = 13;
              return options.onError.toBeCalled;

            case 13:
              expect(options.onError).toHaveBeenCalledWith(new Error('tus: invalid or missing Location header, originated from request (method: POST, url: http://tus.io/uploads, response code: 201, response text: , request id: n/a)'));

            case 14:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17);
    })));
    it('should throw if retryDelays is not an array', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'http://endpoint/',
        retryDelays: 44
      });
      expect(upload.start.bind(upload)).toThrowError('tus: the `retryDelays` option must either be an array or null');
    }); // This tests ensures that tus-js-client correctly retries if the
    // response has the code 500 Internal Error, 423 Locked or 409 Conflict.

    it('should retry the upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context18.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context18.next = 13;
              return testStack.nextRequest();

            case 13:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context18.next = 19;
              return testStack.nextRequest();

            case 19:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context18.next = 25;
              return testStack.nextRequest();

            case 25:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 31;
              return testStack.nextRequest();

            case 31:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context18.next = 37;
              return testStack.nextRequest();

            case 37:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context18.next = 43;
              return testStack.nextRequest();

            case 43:
              req = _context18.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context18.next = 49;
              return options.onSuccess.toBeCalled;

            case 49:
              expect(options.onSuccess).toHaveBeenCalled();

            case 50:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18);
    }))); // This tests ensures that tus-js-client correctly retries if the
    // return value of onShouldRetry is true.

    it('should retry the upload when onShouldRetry specified and returns true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {
      var testStack, file, options, upload, req, _upload$_emitError$ca, _upload$_emitError$ca2, error1, _upload$_emitError$ca3, _upload$_emitError$ca4, error2;

      return _regeneratorRuntime().wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onShouldRetry: function onShouldRetry() {
                  return true;
                }
              };
              spyOn(options, 'onShouldRetry').and.callThrough();
              spyOn(tus.Upload.prototype, '_emitError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context19.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context19.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context19.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 423
              });
              _context19.next = 27;
              return testStack.nextRequest();

            case 27:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 409
              });
              _context19.next = 39;
              return testStack.nextRequest();

            case 39:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context19.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context19.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context19.next = 51;
              return options.onSuccess.toBeCalled;

            case 51:
              expect(options.onSuccess).toHaveBeenCalled();
              _upload$_emitError$ca = upload._emitError.calls.argsFor(0), _upload$_emitError$ca2 = _slicedToArray(_upload$_emitError$ca, 1), error1 = _upload$_emitError$ca2[0];
              expect(options.onShouldRetry).toHaveBeenCalled();
              expect(options.onShouldRetry.calls.argsFor(0)).toEqual([error1, 0, upload.options]);
              _upload$_emitError$ca3 = upload._emitError.calls.argsFor(1), _upload$_emitError$ca4 = _slicedToArray(_upload$_emitError$ca3, 1), error2 = _upload$_emitError$ca4[0];
              expect(options.onShouldRetry.calls.argsFor(1)).toEqual([error2, 1, upload.options]);

            case 57:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19);
    }))); // This tests ensures that tus-js-client correctly aborts if the
    // return value of onShouldRetry is false.

    it('should not retry the upload when callback specified and returns false', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee20$(_context20) {
        while (1) {
          switch (_context20.prev = _context20.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: waitableFunction('onSuccess'),
                onError: waitableFunction('onError'),
                onShouldRetry: function onShouldRetry() {
                  return false;
                }
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context20.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context20.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context20.next = 14;
              return options.onError.toBeCalled;

            case 14:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 16:
            case "end":
              return _context20.stop();
          }
        }
      }, _callee20);
    })));
    it('should not retry if the error has not been caused by a request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {
      var file, options, upload, error;
      return _regeneratorRuntime().wrap(function _callee21$(_context21) {
        while (1) {
          switch (_context21.prev = _context21.next) {
            case 0:
              file = getBlob('hello world');
              options = {
                httpStack: new TestHttpStack(),
                endpoint: 'http://tus.io/files/',
                retryDelays: [10, 10, 10],
                onSuccess: function onSuccess() {},
                onError: function onError() {}
              };
              spyOn(options, 'onSuccess');
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              spyOn(upload, '_createUpload');
              upload.start();
              _context21.next = 9;
              return wait(200);

            case 9:
              error = new Error('custom error');

              upload._emitError(error);

              expect(upload._createUpload).toHaveBeenCalledTimes(1);
              expect(options.onError).toHaveBeenCalledWith(error);
              expect(options.onSuccess).not.toHaveBeenCalled();

            case 14:
            case "end":
              return _context21.stop();
          }
        }
      }, _callee21);
    })));
    it('should stop retrying after all delays have been used', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee22$(_context22) {
        while (1) {
          switch (_context22.prev = _context22.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onSuccess: function onSuccess() {},
                onError: waitableFunction('onError')
              };
              spyOn(options, 'onSuccess');
              upload = new tus.Upload(file, options);
              upload.start();
              _context22.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 500
              });
              _context22.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context22.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST'); // The error callback should not be invoked for the first error response.

              expect(options.onError).not.toHaveBeenCalled();
              req.respondWith({
                status: 500
              });
              _context22.next = 21;
              return options.onError.toBeCalled;

            case 21:
              expect(options.onSuccess).not.toHaveBeenCalled();
              expect(options.onError).toHaveBeenCalledTimes(1);

            case 23:
            case "end":
              return _context22.stop();
          }
        }
      }, _callee22);
    })));
    it('should stop retrying when the abort function is called', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee23$(_context23) {
        while (1) {
          switch (_context23.prev = _context23.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {}
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context23.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context23.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              spyOn(upload, 'start').and.callThrough();
              upload.abort();
              req.respondWith({
                status: 500
              });
              _context23.next = 16;
              return Promise.race([testStack.nextRequest(), wait(100)]);

            case 16:
              result = _context23.sent;
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context23.stop();
          }
        }
      }, _callee23);
    })));
    it('should stop upload when the abort function is called during a callback', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee24$(_context24) {
        while (1) {
          switch (_context24.prev = _context24.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  upload.abort();
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context24.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context24.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context24.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context24.next = 20;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 20:
              result = _context24.sent;
              expect(options.onChunkComplete).toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 23:
            case "end":
              return _context24.stop();
          }
        }
      }, _callee24);
    })));
    it('should stop upload when the abort function is called during the POST request', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {
      var testStack, file, options, upload, req, result;
      return _regeneratorRuntime().wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                onError: function onError() {}
              };
              spyOn(options, 'onError').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context25.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context25.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              upload.abort();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context25.next = 15;
              return Promise.race([testStack.nextRequest(), wait(200)]);

            case 15:
              result = _context25.sent;
              expect(options.onError).not.toHaveBeenCalled();
              expect(result).toBe('timed out');

            case 18:
            case "end":
              return _context25.stop();
          }
        }
      }, _callee25);
    })));
    it('should reset the attempt counter if an upload proceeds', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                retryDelays: [10],
                onError: function onError() {},
                onSuccess: waitableFunction('onSuccess')
              };
              spyOn(options, 'onError');
              upload = new tus.Upload(file, options);
              upload.start();
              _context26.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context26.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 0,
                  'Upload-Length': 11
                }
              });
              _context26.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context26.next = 32;
              return testStack.nextRequest();

            case 32:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 500
              });
              _context26.next = 38;
              return testStack.nextRequest();

            case 38:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5,
                  'Upload-Length': 11
                }
              });
              _context26.next = 44;
              return testStack.nextRequest();

            case 44:
              req = _context26.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 11
                }
              });
              _context26.next = 50;
              return options.onSuccess.toBeCalled;

            case 50:
              expect(options.onError).not.toHaveBeenCalled();
              expect(options.onSuccess).toHaveBeenCalled();

            case 52:
            case "end":
              return _context26.stop();
          }
        }
      }, _callee26);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}],63:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var axios = require('axios');

var _require = require('./helpers/utils'),
    getBlob = _require.getBlob;

var tus = require('../..'); // Test timeout for end-to-end tests when uploading to real server.


var END_TO_END_TIMEOUT = 20 * 1000;
describe('tus', function () {
  describe('end-to-end', function () {
    it('should upload to a real tus server', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent).then(function (upload) {
                return upload.abort(true).then(function () {
                  return upload;
                });
              }).then(validateUploadDeletion));

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), END_TO_END_TIMEOUT);
    it('should upload to a real tus server with creation-with-upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.abrupt("return", new Promise(function (resolve, reject) {
                var file = getBlob('hello world');
                var options = {
                  endpoint: 'https://tusd.tusdemo.net/files/',
                  metadata: {
                    nonlatin: 'słońce',
                    number: 100,
                    filename: 'hello.txt',
                    filetype: 'text/plain'
                  },
                  onSuccess: function onSuccess() {
                    expect(upload.url).toMatch(/^https:\/\/tusd\.tusdemo\.net\/files\//);
                    console.log('Upload URL:', upload.url); // eslint-disable-line no-console

                    resolve(upload);
                  },
                  onError: function onError(err) {
                    reject(err);
                  }
                };
                var upload = new tus.Upload(file, options);
                upload.start();
              }).then(validateUploadContent));

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })), END_TO_END_TIMEOUT);
  });
});

function validateUploadContent(upload) {
  return axios.get(upload.url).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('hello world');
    return validateUploadMetadata(upload);
  });
}

function validateUploadMetadata(upload) {
  return axios.head(upload.url, {
    headers: {
      'Tus-Resumable': '1.0.0'
    }
  }).then(function (res) {
    expect(res.status).toBe(200);
    expect(res.data).toBe('');
    expect(res.headers['tus-resumable']).toBe('1.0.0');
    expect(res.headers['upload-offset']).toBe('11');
    expect(res.headers['upload-length']).toBe('11'); // The values in the Upload-Metadata header may not be in the same
    // order as we submitted them (the specification does not require
    // that). Therefore, we split the values and verify that each one
    // is present.

    var metadataStr = res.headers['upload-metadata'];
    expect(metadataStr).toBeTruthy();
    var metadata = metadataStr.split(',');
    expect(metadata).toContain('filename aGVsbG8udHh0');
    expect(metadata).toContain('filetype dGV4dC9wbGFpbg==');
    expect(metadata).toContain('nonlatin c8WCb8WEY2U=');
    expect(metadata).toContain('number MTAw');
    expect(metadata.length).toBe(4);
    return upload;
  });
}

function validateUploadDeletion(upload) {
  return axios.get(upload.url, {
    validateStatus: function validateStatus(status) {
      return status === 404;
    }
  }).then(function (res) {
    expect(res.status).toBe(404);
    return upload;
  });
}

},{"../..":4,"./helpers/utils":60,"axios":17}],64:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    waitableFunction = _require.waitableFunction,
    wait = _require.wait,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('parallel uploading', function () {
    it('should throw if incompatible options are used', function () {
      var file = getBlob('hello world');
      var upload = new tus.Upload(file, {
        endpoint: 'https://tus.io/uploads',
        parallelUploads: 2,
        uploadUrl: 'foo'
      });
      expect(upload.start.bind(upload)).toThrowError('tus: cannot use the uploadUrl option when parallelUploads is enabled');
    });
    it('should split a file into multiple parts and create an upload for each', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var testStack, testUrlStorage, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              testUrlStorage = {
                addUpload: function addUpload(fingerprint, upload) {
                  expect(fingerprint).toBe('fingerprinted');
                  expect(upload.uploadUrl).toBeUndefined();
                  expect(upload.size).toBe(11);
                  expect(upload.parallelUploadUrls).toEqual(['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']);
                  return Promise.resolve('tus::fingerprinted::1337');
                },
                removeUpload: function removeUpload(urlStorageKey) {
                  expect(urlStorageKey).toBe('tus::fingerprinted::1337');
                  return Promise.resolve();
                }
              };
              spyOn(testUrlStorage, 'removeUpload').and.callThrough();
              spyOn(testUrlStorage, 'addUpload').and.callThrough();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                urlStorage: testUrlStorage,
                storeFingerprintForResuming: true,
                removeFingerprintOnSuccess: true,
                parallelUploads: 2,
                retryDelays: [10],
                endpoint: 'https://tus.io/uploads',
                headers: {
                  Custom: 'blargh'
                },
                metadata: {
                  foo: 'hello'
                },
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context.next = 22;
              return testStack.nextRequest();

            case 22:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context.next = 33;
              return testStack.nextRequest();

            case 33:
              req = _context.sent;
              // Assert that the URLs have been stored.
              expect(testUrlStorage.addUpload).toHaveBeenCalled();
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(5);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 45;
              return testStack.nextRequest();

            case 45:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6); // Return an error to ensure that the individual partial upload is properly retried.

              req.respondWith({
                status: 500
              });
              _context.next = 56;
              return testStack.nextRequest();

            case 56:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 11,
                  'Upload-Offset': 0
                }
              });
              _context.next = 62;
              return testStack.nextRequest();

            case 62:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Offset']).toBe(0);
              expect(req.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context.next = 73;
              return testStack.nextRequest();

            case 73:
              req = _context.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders.Custom).toBe('blargh');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              expect(req.requestHeaders['Upload-Metadata']).toBe('foo aGVsbG8=');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context.next = 84;
              return options.onSuccess.toBeCalled;

            case 84:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);
              expect(testUrlStorage.removeUpload).toHaveBeenCalled();

            case 88:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should emit error from a partial upload', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var testStack, file, options, upload, req, err;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                retryDelays: null,
                endpoint: 'https://tus.io/uploads',
                onError: waitableFunction('onError')
              };
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context2.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              req.respondWith({
                status: 500
              });
              _context2.next = 15;
              return options.onError.toBeCalled;

            case 15:
              err = _context2.sent;
              expect(err.message).toBe('tus: unexpected response while creating upload, originated from request (method: POST, url: https://tus.io/uploads, response code: 500, response text: , request id: n/a)');
              expect(err.originalRequest).toBe(req);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should resume the partial uploads', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                // The client should resume the parallel uploads, even if it is not
                // configured for new uploads.
                parallelUploads: 1,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction()
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.resumeFromPreviousUpload({
                urlStorageKey: 'tus::fingerprint::1337',
                parallelUploadUrls: ['https://tus.io/uploads/upload1', 'https://tus.io/uploads/upload2']
              });
              upload.start();
              _context3.next = 9;
              return testStack.nextRequest();

            case 9:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 2
                }
              });
              _context3.next = 15;
              return testStack.nextRequest();

            case 15:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 0
                }
              });
              _context3.next = 21;
              return testStack.nextRequest();

            case 21:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(3);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context3.next = 28;
              return testStack.nextRequest();

            case 28:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('PATCH');
              expect(req.body.size).toBe(6);
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              });
              _context3.next = 35;
              return testStack.nextRequest();

            case 35:
              req = _context3.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context3.next = 42;
              return options.onSuccess.toBeCalled;

            case 42:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 45:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should abort all partial uploads and resume from them', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, file, options, upload, req, req1, req2, reqPromise, result;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                parallelUploads: 2,
                endpoint: 'https://tus.io/uploads',
                onProgress: function onProgress() {},
                onSuccess: waitableFunction(),
                fingerprint: function fingerprint() {
                  return Promise.resolve('fingerprinted');
                }
              };
              spyOn(options, 'onProgress');
              upload = new tus.Upload(file, options);
              upload.start();
              _context4.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(5);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload1'
                }
              });
              _context4.next = 18;
              return testStack.nextRequest();

            case 18:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBe(6);
              expect(req.requestHeaders['Upload-Concat']).toBe('partial');
              expect(req.requestHeaders['Upload-Metadata']).toBeUndefined();
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload2'
                }
              });
              _context4.next = 28;
              return testStack.nextRequest();

            case 28:
              req1 = _context4.sent;
              expect(req1.url).toBe('https://tus.io/uploads/upload1');
              expect(req1.method).toBe('PATCH');
              expect(req1.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req1.requestHeaders['Upload-Offset']).toBe(0);
              expect(req1.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req1.body.size).toBe(5);
              _context4.next = 37;
              return testStack.nextRequest();

            case 37:
              req2 = _context4.sent;
              expect(req2.url).toBe('https://tus.io/uploads/upload2');
              expect(req2.method).toBe('PATCH');
              expect(req2.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req2.requestHeaders['Upload-Offset']).toBe(0);
              expect(req2.requestHeaders['Content-Type']).toBe('application/offset+octet-stream');
              expect(req2.body.size).toBe(6);
              upload.abort();
              req1.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              req2.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 6
                }
              }); // No further requests should be sent.

              reqPromise = testStack.nextRequest();
              _context4.next = 50;
              return Promise.race([reqPromise, wait(100)]);

            case 50:
              result = _context4.sent;
              expect(result).toBe('timed out'); // Restart the upload

              upload.start(); // Reuse the promise from before as it is not cancelled.

              _context4.next = 55;
              return reqPromise;

            case 55:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload1');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 5,
                  'Upload-Offset': 5
                }
              });
              _context4.next = 61;
              return testStack.nextRequest();

            case 61:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads/upload2');
              expect(req.method).toBe('HEAD');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Length': 6,
                  'Upload-Offset': 6
                }
              });
              _context4.next = 67;
              return testStack.nextRequest();

            case 67:
              req = _context4.sent;
              expect(req.url).toBe('https://tus.io/uploads');
              expect(req.method).toBe('POST');
              expect(req.requestHeaders['Tus-Resumable']).toBe('1.0.0');
              expect(req.requestHeaders['Upload-Length']).toBeUndefined();
              expect(req.requestHeaders['Upload-Concat']).toBe('final;https://tus.io/uploads/upload1 https://tus.io/uploads/upload2');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: 'https://tus.io/uploads/upload3'
                }
              });
              _context4.next = 76;
              return options.onSuccess.toBeCalled;

            case 76:
              expect(upload.url).toBe('https://tus.io/uploads/upload3');
              expect(options.onProgress).toHaveBeenCalledWith(5, 11);
              expect(options.onProgress).toHaveBeenCalledWith(11, 11);

            case 79:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}],65:[function(require,module,exports){
"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return generator._invoke = function (innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; }(innerFn, self, context), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; this._invoke = function (method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _require = require('./helpers/utils'),
    TestHttpStack = _require.TestHttpStack,
    getBlob = _require.getBlob;

var tus = require('../..');

describe('tus', function () {
  describe('terminate upload', function () {
    it('should terminate upload when abort is called with true', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
      var abortPromise, testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              expect(options.onChunkComplete).toHaveBeenCalled();
              _context.next = 27;
              return abortPromise;

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })));
    it('should retry terminate when an error is returned on first try', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
      var abortPromise, testStack, file, options, upload, req;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              testStack = new TestHttpStack();
              file = getBlob('hello world');
              options = {
                httpStack: testStack,
                endpoint: 'http://tus.io/files/',
                chunkSize: 5,
                retryDelays: [10, 10, 10],
                onChunkComplete: function onChunkComplete() {
                  abortPromise = upload.abort(true);
                }
              };
              spyOn(options, 'onChunkComplete').and.callThrough();
              upload = new tus.Upload(file, options);
              upload.start();
              _context2.next = 8;
              return testStack.nextRequest();

            case 8:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/');
              expect(req.method).toBe('POST');
              req.respondWith({
                status: 201,
                responseHeaders: {
                  Location: '/files/foo'
                }
              });
              _context2.next = 14;
              return testStack.nextRequest();

            case 14:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('PATCH');
              req.respondWith({
                status: 204,
                responseHeaders: {
                  'Upload-Offset': 5
                }
              });
              _context2.next = 20;
              return testStack.nextRequest();

            case 20:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 423
              });
              _context2.next = 26;
              return testStack.nextRequest();

            case 26:
              req = _context2.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context2.next = 32;
              return abortPromise;

            case 32:
              expect(options.onChunkComplete).toHaveBeenCalled();

            case 33:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    })));
    it('should stop retrying when all delays are used up', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {
      var testStack, options, terminatePromise, req;
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                retryDelays: [10, 10]
              };
              terminatePromise = tus.Upload.terminate('http://tus.io/files/foo', options);
              _context3.next = 5;
              return testStack.nextRequest();

            case 5:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 11;
              return testStack.nextRequest();

            case 11:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 17;
              return testStack.nextRequest();

            case 17:
              req = _context3.sent;
              expect(req.url).toBe('http://tus.io/files/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 500
              });
              _context3.next = 23;
              return expectAsync(terminatePromise).toBeRejectedWithError(/tus: unexpected response while terminating upload/);

            case 23:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3);
    })));
    it('should invoke the request and response Promises', /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {
      var testStack, options, terminatePromise, req;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              testStack = new TestHttpStack();
              options = {
                httpStack: testStack,
                onBeforeRequest: function onBeforeRequest(req) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    resolve();
                  });
                },
                onAfterResponse: function onAfterResponse(req, res) {
                  return new Promise(function (resolve) {
                    expect(req.getURL()).toBe('http://tus.io/uploads/foo');
                    expect(req.getMethod()).toBe('DELETE');
                    expect(res.getStatus()).toBe(204);
                    resolve();
                  });
                }
              };
              spyOn(options, 'onBeforeRequest');
              spyOn(options, 'onAfterResponse');
              terminatePromise = tus.Upload.terminate('http://tus.io/uploads/foo', options);
              _context4.next = 7;
              return testStack.nextRequest();

            case 7:
              req = _context4.sent;
              expect(req.url).toBe('http://tus.io/uploads/foo');
              expect(req.method).toBe('DELETE');
              req.respondWith({
                status: 204
              });
              _context4.next = 13;
              return expectAsync(terminatePromise).toBeResolved();

            case 13:
              expect(options.onBeforeRequest).toHaveBeenCalled();
              expect(options.onAfterResponse).toHaveBeenCalled();

            case 15:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    })));
  });
});

},{"../..":4,"./helpers/utils":60}]},{},[58])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIuZXM1L2Jyb3dzZXIvZmlsZVJlYWRlci5qcyIsImxpYi5lczUvYnJvd3Nlci9maW5nZXJwcmludC5qcyIsImxpYi5lczUvYnJvd3Nlci9odHRwU3RhY2suanMiLCJsaWIuZXM1L2Jyb3dzZXIvaW5kZXguanMiLCJsaWIuZXM1L2Jyb3dzZXIvaXNSZWFjdE5hdGl2ZS5qcyIsImxpYi5lczUvYnJvd3Nlci9zb3VyY2VzL0ZpbGVTb3VyY2UuanMiLCJsaWIuZXM1L2Jyb3dzZXIvc291cmNlcy9TdHJlYW1Tb3VyY2UuanMiLCJsaWIuZXM1L2Jyb3dzZXIvc291cmNlcy9pc0NvcmRvdmEuanMiLCJsaWIuZXM1L2Jyb3dzZXIvc291cmNlcy9yZWFkQXNCeXRlQXJyYXkuanMiLCJsaWIuZXM1L2Jyb3dzZXIvdXJpVG9CbG9iLmpzIiwibGliLmVzNS9icm93c2VyL3VybFN0b3JhZ2UuanMiLCJsaWIuZXM1L2Vycm9yLmpzIiwibGliLmVzNS9sb2dnZXIuanMiLCJsaWIuZXM1L25vb3BVcmxTdG9yYWdlLmpzIiwibGliLmVzNS91cGxvYWQuanMiLCJsaWIuZXM1L3V1aWQuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbGVkRXJyb3IuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9tZXJnZUNvbmZpZy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIm5vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL251bGwuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3RvRm9ybURhdGEuanMiLCJub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzIiwibm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanMtYmFzZTY0L2Jhc2U2NC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmdpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcmVnZW5lcmF0b3ItcnVudGltZS9ydW50aW1lLmpzIiwibm9kZV9tb2R1bGVzL3JlcXVpcmVzLXBvcnQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwidGVzdC9zcGVjL2Jyb3dzZXItaW5kZXguanMiLCJ0ZXN0L3NwZWMvaGVscGVycy9hc3NlcnRVcmxTdG9yYWdlLmpzIiwidGVzdC9zcGVjL2hlbHBlcnMvdXRpbHMuanMiLCJ0ZXN0L3NwZWMvdGVzdC1icm93c2VyLXNwZWNpZmljLmpzIiwidGVzdC9zcGVjL3Rlc3QtY29tbW9uLmpzIiwidGVzdC9zcGVjL3Rlc3QtZW5kLXRvLWVuZC5qcyIsInRlc3Qvc3BlYy90ZXN0LXBhcmFsbGVsLXVwbG9hZHMuanMiLCJ0ZXN0L3NwZWMvdGVzdC10ZXJtaW5hdGUuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTs7QUFFQSxNQUFNLENBQUMsY0FBUCxDQUFzQixPQUF0QixFQUErQixZQUEvQixFQUE2QztFQUMzQyxLQUFLLEVBQUU7QUFE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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOU5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNsSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQy9UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2x2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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MEJwRCxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUwsQ0FBTixDQUFnQixJQUFoQixDQUFxQiwyQkFBckI7Y0FDQSxNQUFNLENBQUMsR0FBRyxDQUFDLE1BQUwsQ0FBTixDQUFtQixJQUFuQixDQUF3QixRQUF4QjtjQUVBLEdBQUcsQ0FBQyxXQUFKLENBQWdCO2dCQUNkLE1BQU0sRUFBRTtjQURNLENBQWhCO2NBN0JvRDtjQUFBLE9BaUM5QyxXQUFXLENBQUMsZ0JBQUQsQ0FBWCxDQUE4QixZQUE5QixFQWpDOEM7O1lBQUE7Y0FrQ3BELE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBVCxDQUFOLENBQWdDLGdCQUFoQztjQUNBLE1BQU0sQ0FBQyxPQUFPLENBQUMsZUFBVCxDQUFOLENBQWdDLGdCQUFoQzs7WUFuQ29EO1lBQUE7Y0FBQTtVQUFBO1FBQUE7TUFBQTtJQUFBLENBQXBELEdBQUY7RUFxQ0QsQ0EzTE8sQ0FBUjtBQTRMRCxDQTdMTyxDQUFSIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbnZhciBfdXJpVG9CbG9iID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi91cmlUb0Jsb2JcIikpO1xuXG52YXIgX0ZpbGVTb3VyY2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3NvdXJjZXMvRmlsZVNvdXJjZVwiKSk7XG5cbnZhciBfU3RyZWFtU291cmNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9zb3VyY2VzL1N0cmVhbVNvdXJjZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEZpbGVSZWFkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZpbGVSZWFkZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZpbGVSZWFkZXIsIFt7XG4gICAga2V5OiBcIm9wZW5GaWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW5GaWxlKGlucHV0LCBjaHVua1NpemUpIHtcbiAgICAgIC8vIEluIFJlYWN0IE5hdGl2ZSwgd2hlbiB1c2VyIHNlbGVjdHMgYSBmaWxlLCBpbnN0ZWFkIG9mIGEgRmlsZSBvciBCbG9iLFxuICAgICAgLy8geW91IHVzdWFsbHkgZ2V0IGEgZmlsZSBvYmplY3Qge30gd2l0aCBhIHVyaSBwcm9wZXJ0eSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyBhIGxvY2FsIHBhdGggdG8gdGhlIGZpbGUuIFdlIHVzZSBYTUxIdHRwUmVxdWVzdCB0byBmZXRjaFxuICAgICAgLy8gdGhlIGZpbGUgYmxvYiwgYmVmb3JlIHVwbG9hZGluZyB3aXRoIHR1cy5cbiAgICAgIGlmICgoMCwgX2lzUmVhY3ROYXRpdmUuZGVmYXVsdCkoKSAmJiBpbnB1dCAmJiB0eXBlb2YgaW5wdXQudXJpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gKDAsIF91cmlUb0Jsb2IuZGVmYXVsdCkoaW5wdXQudXJpKS50aGVuKGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBfRmlsZVNvdXJjZS5kZWZhdWx0KGJsb2IpO1xuICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0dXM6IGNhbm5vdCBmZXRjaCBgZmlsZS51cmlgIGFzIEJsb2IsIG1ha2Ugc3VyZSB0aGUgdXJpIGlzIGNvcnJlY3QgYW5kIGFjY2Vzc2libGUuIFwiLmNvbmNhdChlcnIpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFNpbmNlIHdlIGVtdWxhdGUgdGhlIEJsb2IgdHlwZSBpbiBvdXIgdGVzdHMgKG5vdCBhbGwgdGFyZ2V0IGJyb3dzZXJzXG4gICAgICAvLyBzdXBwb3J0IGl0KSwgd2UgY2Fubm90IHVzZSBgaW5zdGFuY2VvZmAgZm9yIHRlc3Rpbmcgd2hldGhlciB0aGUgaW5wdXQgdmFsdWVcbiAgICAgIC8vIGNhbiBiZSBoYW5kbGVkLiBJbnN0ZWFkLCB3ZSBzaW1wbHkgY2hlY2sgaXMgdGhlIHNsaWNlKCkgZnVuY3Rpb24gYW5kIHRoZVxuICAgICAgLy8gc2l6ZSBwcm9wZXJ0eSBhcmUgYXZhaWxhYmxlLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgaW5wdXQuc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGlucHV0LnNpemUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobmV3IF9GaWxlU291cmNlLmRlZmF1bHQoaW5wdXQpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5yZWFkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNodW5rU2l6ZSA9IE51bWJlcihjaHVua1NpemUpO1xuXG4gICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGNodW5rU2l6ZSkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdjYW5ub3QgY3JlYXRlIHNvdXJjZSBmb3Igc3RyZWFtIHdpdGhvdXQgYSBmaW5pdGUgdmFsdWUgZm9yIHRoZSBgY2h1bmtTaXplYCBvcHRpb24nKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBfU3RyZWFtU291cmNlLmRlZmF1bHQoaW5wdXQsIGNodW5rU2l6ZSkpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdzb3VyY2Ugb2JqZWN0IG1heSBvbmx5IGJlIGFuIGluc3RhbmNlIG9mIEZpbGUsIEJsb2IsIG9yIFJlYWRlciBpbiB0aGlzIGVudmlyb25tZW50JykpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGaWxlUmVhZGVyO1xufSgpO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBGaWxlUmVhZGVyOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gZmluZ2VycHJpbnQ7XG5cbnZhciBfaXNSZWFjdE5hdGl2ZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNSZWFjdE5hdGl2ZVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIFRPRE86IERpZmZlcmVuY2lhdGUgYmV0d2VlbiBpbnB1dCB0eXBlc1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgZmluZ2VycHJpbnQgZm9yIGEgZmlsZSB3aGljaCB3aWxsIGJlIHVzZWQgdGhlIHN0b3JlIHRoZSBlbmRwb2ludFxuICpcbiAqIEBwYXJhbSB7RmlsZX0gZmlsZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIGZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpIHtcbiAgaWYgKCgwLCBfaXNSZWFjdE5hdGl2ZS5kZWZhdWx0KSgpKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWFjdE5hdGl2ZUZpbmdlcnByaW50KGZpbGUsIG9wdGlvbnMpKTtcbiAgfVxuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoWyd0dXMtYnInLCBmaWxlLm5hbWUsIGZpbGUudHlwZSwgZmlsZS5zaXplLCBmaWxlLmxhc3RNb2RpZmllZCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbignLScpKTtcbn1cblxuZnVuY3Rpb24gcmVhY3ROYXRpdmVGaW5nZXJwcmludChmaWxlLCBvcHRpb25zKSB7XG4gIHZhciBleGlmSGFzaCA9IGZpbGUuZXhpZiA/IGhhc2hDb2RlKEpTT04uc3RyaW5naWZ5KGZpbGUuZXhpZikpIDogJ25vZXhpZic7XG4gIHJldHVybiBbJ3R1cy1ybicsIGZpbGUubmFtZSB8fCAnbm9uYW1lJywgZmlsZS5zaXplIHx8ICdub3NpemUnLCBleGlmSGFzaCwgb3B0aW9ucy5lbmRwb2ludF0uam9pbignLycpO1xufVxuXG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICAvLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84ODMxOTM3LzE1MTY2NlxuICB2YXIgaGFzaCA9IDA7XG5cbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gaGFzaDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9jaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgX2NoYXI7XG4gICAgaGFzaCAmPSBoYXNoOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufSIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5cblxudmFyIFhIUkh0dHBTdGFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFhIUkh0dHBTdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgWEhSSHR0cFN0YWNrKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYSFJIdHRwU3RhY2ssIFt7XG4gICAga2V5OiBcImNyZWF0ZVJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlUmVxdWVzdChtZXRob2QsIHVybCkge1xuICAgICAgcmV0dXJuIG5ldyBSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROYW1lKCkge1xuICAgICAgcmV0dXJuICdYSFJIdHRwU3RhY2snO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBYSFJIdHRwU3RhY2s7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFhIUkh0dHBTdGFjaztcblxudmFyIFJlcXVlc3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlcXVlc3QpO1xuXG4gICAgdGhpcy5feGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICB0aGlzLl94aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG5cbiAgICB0aGlzLl9tZXRob2QgPSBtZXRob2Q7XG4gICAgdGhpcy5fdXJsID0gdXJsO1xuICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXF1ZXN0LCBbe1xuICAgIGtleTogXCJnZXRNZXRob2RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0TWV0aG9kKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21ldGhvZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VVJMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFVSTCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl91cmw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEhlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIZWFkZXIoaGVhZGVyLCB2YWx1ZSkge1xuICAgICAgdGhpcy5feGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyLCB2YWx1ZSk7XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNbaGVhZGVyXSA9IHZhbHVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNbaGVhZGVyXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvZ3Jlc3NIYW5kbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFByb2dyZXNzSGFuZGxlcihwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICAgIC8vIFRlc3Qgc3VwcG9ydCBmb3IgcHJvZ3Jlc3MgZXZlbnRzIGJlZm9yZSBhdHRhY2hpbmcgYW4gZXZlbnQgbGlzdGVuZXJcbiAgICAgIGlmICghKCd1cGxvYWQnIGluIHRoaXMuX3hocikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl94aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBpZiAoIWUubGVuZ3RoQ29tcHV0YWJsZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByb2dyZXNzSGFuZGxlcihlLmxvYWRlZCk7XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogbnVsbDtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIF90aGlzLl94aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJlc29sdmUobmV3IFJlc3BvbnNlKF90aGlzLl94aHIpKTtcbiAgICAgICAgfTtcblxuICAgICAgICBfdGhpcy5feGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH07XG5cbiAgICAgICAgX3RoaXMuX3hoci5zZW5kKGJvZHkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KCkge1xuICAgICAgdGhpcy5feGhyLmFib3J0KCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVxdWVzdDtcbn0oKTtcblxudmFyIFJlc3BvbnNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVzcG9uc2UoeGhyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNlKTtcblxuICAgIHRoaXMuX3hociA9IHhocjtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSZXNwb25zZSwgW3tcbiAgICBrZXk6IFwiZ2V0U3RhdHVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXR1cygpIHtcbiAgICAgIHJldHVybiB0aGlzLl94aHIuc3RhdHVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRIZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVhZGVyKGhlYWRlcikge1xuICAgICAgcmV0dXJuIHRoaXMuX3hoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb2R5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvZHkoKSB7XG4gICAgICByZXR1cm4gdGhpcy5feGhyLnJlc3BvbnNlVGV4dDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VW5kZXJseWluZ09iamVjdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRVbmRlcmx5aW5nT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3hocjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUmVzcG9uc2U7XG59KCk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZXRhaWxlZEVycm9yXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9lcnJvci5kZWZhdWx0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkh0dHBTdGFja1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfaHR0cFN0YWNrLmRlZmF1bHQ7XG4gIH1cbn0pO1xuZXhwb3J0cy5VcGxvYWQgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJjYW5TdG9yZVVSTHNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3VybFN0b3JhZ2UuY2FuU3RvcmVVUkxzO1xuICB9XG59KTtcbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbmFibGVEZWJ1Z0xvZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfbG9nZ2VyLmVuYWJsZURlYnVnTG9nO1xuICB9XG59KTtcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSB2b2lkIDA7XG5cbnZhciBfdXBsb2FkID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vdXBsb2FkXCIpKTtcblxudmFyIF9ub29wVXJsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4uL25vb3BVcmxTdG9yYWdlXCIpKTtcblxudmFyIF9sb2dnZXIgPSByZXF1aXJlKFwiLi4vbG9nZ2VyXCIpO1xuXG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi4vZXJyb3JcIikpO1xuXG52YXIgX3VybFN0b3JhZ2UgPSByZXF1aXJlKFwiLi91cmxTdG9yYWdlXCIpO1xuXG52YXIgX2h0dHBTdGFjayA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaHR0cFN0YWNrXCIpKTtcblxudmFyIF9maWxlUmVhZGVyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9maWxlUmVhZGVyXCIpKTtcblxudmFyIF9maW5nZXJwcmludCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vZmluZ2VycHJpbnRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cblxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgICBvLl9fcHJvdG9fXyA9IHA7XG4gICAgcmV0dXJuIG87XG4gIH07XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7XG4gIHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpO1xuXG4gIHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHtcbiAgICB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksXG4gICAgICAgIHJlc3VsdDtcblxuICAgIGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7XG4gICAgICB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yO1xuXG4gICAgICByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTtcblxuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbnZhciBkZWZhdWx0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3VwbG9hZC5kZWZhdWx0LmRlZmF1bHRPcHRpb25zKSwge30sIHtcbiAgaHR0cFN0YWNrOiBuZXcgX2h0dHBTdGFjay5kZWZhdWx0KCksXG4gIGZpbGVSZWFkZXI6IG5ldyBfZmlsZVJlYWRlci5kZWZhdWx0KCksXG4gIHVybFN0b3JhZ2U6IF91cmxTdG9yYWdlLmNhblN0b3JlVVJMcyA/IG5ldyBfdXJsU3RvcmFnZS5XZWJTdG9yYWdlVXJsU3RvcmFnZSgpIDogbmV3IF9ub29wVXJsU3RvcmFnZS5kZWZhdWx0KCksXG4gIGZpbmdlcnByaW50OiBfZmluZ2VycHJpbnQuZGVmYXVsdFxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdE9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcblxudmFyIFVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VVcGxvYWQpIHtcbiAgX2luaGVyaXRzKFVwbG9hZCwgX0Jhc2VVcGxvYWQpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoVXBsb2FkKTtcblxuICBmdW5jdGlvbiBVcGxvYWQoKSB7XG4gICAgdmFyIGZpbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVwbG9hZCk7XG5cbiAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBmaWxlLCBvcHRpb25zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVcGxvYWQsIG51bGwsIFt7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUodXJsLCBvcHRpb25zLCBjYikge1xuICAgICAgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBfdXBsb2FkLmRlZmF1bHQudGVybWluYXRlKHVybCwgb3B0aW9ucywgY2IpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBVcGxvYWQ7XG59KF91cGxvYWQuZGVmYXVsdCk7XG5cbmV4cG9ydHMuVXBsb2FkID0gVXBsb2FkO1xudmFyIF93aW5kb3cgPSB3aW5kb3csXG4gICAgWE1MSHR0cFJlcXVlc3QgPSBfd2luZG93LlhNTEh0dHBSZXF1ZXN0LFxuICAgIEJsb2IgPSBfd2luZG93LkJsb2I7XG52YXIgaXNTdXBwb3J0ZWQgPSBYTUxIdHRwUmVxdWVzdCAmJiBCbG9iICYmIHR5cGVvZiBCbG9iLnByb3RvdHlwZS5zbGljZSA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNTdXBwb3J0ZWQgPSBpc1N1cHBvcnRlZDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxudmFyIGlzUmVhY3ROYXRpdmUgPSBmdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xuICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnc3RyaW5nJyAmJiBuYXZpZ2F0b3IucHJvZHVjdC50b0xvd2VyQ2FzZSgpID09PSAncmVhY3RuYXRpdmUnO1xufTtcblxudmFyIF9kZWZhdWx0ID0gaXNSZWFjdE5hdGl2ZTtcbmV4cG9ydHMuZGVmYXVsdCA9IF9kZWZhdWx0OyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2lzQ29yZG92YSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vaXNDb3Jkb3ZhXCIpKTtcblxudmFyIF9yZWFkQXNCeXRlQXJyYXkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3JlYWRBc0J5dGVBcnJheVwiKSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgRmlsZVNvdXJjZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIE1ha2UgdGhpcy5zaXplIGEgbWV0aG9kXG4gIGZ1bmN0aW9uIEZpbGVTb3VyY2UoZmlsZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGaWxlU291cmNlKTtcblxuICAgIHRoaXMuX2ZpbGUgPSBmaWxlO1xuICAgIHRoaXMuc2l6ZSA9IGZpbGUuc2l6ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGaWxlU291cmNlLCBbe1xuICAgIGtleTogXCJzbGljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgICAvLyBJbiBBcGFjaGUgQ29yZG92YSBhcHBsaWNhdGlvbnMsIGEgRmlsZSBtdXN0IGJlIHJlc29sdmVkIHVzaW5nXG4gICAgICAvLyBGaWxlUmVhZGVyIGluc3RhbmNlcywgc2VlXG4gICAgICAvLyBodHRwczovL2NvcmRvdmEuYXBhY2hlLm9yZy9kb2NzL2VuLzgueC9yZWZlcmVuY2UvY29yZG92YS1wbHVnaW4tZmlsZS9pbmRleC5odG1sI3JlYWQtYS1maWxlXG4gICAgICBpZiAoKDAsIF9pc0NvcmRvdmEuZGVmYXVsdCkoKSkge1xuICAgICAgICByZXR1cm4gKDAsIF9yZWFkQXNCeXRlQXJyYXkuZGVmYXVsdCkodGhpcy5fZmlsZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2ZpbGUuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHsvLyBOb3RoaW5nIHRvIGRvIGhlcmUgc2luY2Ugd2UgZG9uJ3QgbmVlZCB0byByZWxlYXNlIGFueSByZXNvdXJjZXMuXG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZpbGVTb3VyY2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IEZpbGVTb3VyY2U7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBsZW4oYmxvYk9yQXJyYXkpIHtcbiAgaWYgKGJsb2JPckFycmF5ID09PSB1bmRlZmluZWQpIHJldHVybiAwO1xuICBpZiAoYmxvYk9yQXJyYXkuc2l6ZSAhPT0gdW5kZWZpbmVkKSByZXR1cm4gYmxvYk9yQXJyYXkuc2l6ZTtcbiAgcmV0dXJuIGJsb2JPckFycmF5Lmxlbmd0aDtcbn1cbi8qXG4gIFR5cGVkIGFycmF5cyBhbmQgYmxvYnMgZG9uJ3QgaGF2ZSBhIGNvbmNhdCBtZXRob2QuXG4gIFRoaXMgZnVuY3Rpb24gaGVscHMgU3RyZWFtU291cmNlIGFjY3VtdWxhdGUgZGF0YSB0byByZWFjaCBjaHVua1NpemUuXG4qL1xuXG5cbmZ1bmN0aW9uIGNvbmNhdChhLCBiKSB7XG4gIGlmIChhLmNvbmNhdCkge1xuICAgIC8vIElzIGBhYCBhbiBBcnJheT9cbiAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gIH1cblxuICBpZiAoYSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICByZXR1cm4gbmV3IEJsb2IoW2EsIGJdLCB7XG4gICAgICB0eXBlOiBhLnR5cGVcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChhLnNldCkge1xuICAgIC8vIElzIGBhYCBhIHR5cGVkIGFycmF5P1xuICAgIHZhciBjID0gbmV3IGEuY29uc3RydWN0b3IoYS5sZW5ndGggKyBiLmxlbmd0aCk7XG4gICAgYy5zZXQoYSk7XG4gICAgYy5zZXQoYiwgYS5sZW5ndGgpO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGRhdGEgdHlwZScpO1xufVxuXG52YXIgU3RyZWFtU291cmNlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU3RyZWFtU291cmNlKHJlYWRlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJlYW1Tb3VyY2UpO1xuXG4gICAgdGhpcy5fYnVmZmVyID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2J1ZmZlck9mZnNldCA9IDA7XG4gICAgdGhpcy5fcmVhZGVyID0gcmVhZGVyO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdHJlYW1Tb3VyY2UsIFt7XG4gICAga2V5OiBcInNsaWNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICAgIGlmIChzdGFydCA8IHRoaXMuX2J1ZmZlck9mZnNldCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiUmVxdWVzdGVkIGRhdGEgaXMgYmVmb3JlIHRoZSByZWFkZXIncyBjdXJyZW50IG9mZnNldFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9yZWFkVW50aWxFbm91Z2hEYXRhT3JEb25lKHN0YXJ0LCBlbmQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgaGFzRW5vdWdoRGF0YSA9IGVuZCA8PSB0aGlzLl9idWZmZXJPZmZzZXQgKyBsZW4odGhpcy5fYnVmZmVyKTtcblxuICAgICAgaWYgKHRoaXMuX2RvbmUgfHwgaGFzRW5vdWdoRGF0YSkge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9nZXREYXRhRnJvbUJ1ZmZlcihzdGFydCwgZW5kKTtcblxuICAgICAgICB2YXIgZG9uZSA9IHZhbHVlID09IG51bGwgPyB0aGlzLl9kb25lIDogZmFsc2U7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICBkb25lOiBkb25lXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWUsXG4gICAgICAgICAgICBkb25lID0gX3JlZi5kb25lO1xuXG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgX3RoaXMuX2RvbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLl9idWZmZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIF90aGlzLl9idWZmZXIgPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fYnVmZmVyID0gY29uY2F0KF90aGlzLl9idWZmZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5fcmVhZFVudGlsRW5vdWdoRGF0YU9yRG9uZShzdGFydCwgZW5kKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0RGF0YUZyb21CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldERhdGFGcm9tQnVmZmVyKHN0YXJ0LCBlbmQpIHtcbiAgICAgIC8vIFJlbW92ZSBkYXRhIGZyb20gYnVmZmVyIGJlZm9yZSBgc3RhcnRgLlxuICAgICAgLy8gRGF0YSBtaWdodCBiZSByZXJlYWQgZnJvbSB0aGUgYnVmZmVyIGlmIGFuIHVwbG9hZCBmYWlscywgc28gd2UgY2FuIG9ubHlcbiAgICAgIC8vIHNhZmVseSBkZWxldGUgZGF0YSB3aGVuIGl0IGNvbWVzICpiZWZvcmUqIHdoYXQgaXMgY3VycmVudGx5IGJlaW5nIHJlYWQuXG4gICAgICBpZiAoc3RhcnQgPiB0aGlzLl9idWZmZXJPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5fYnVmZmVyID0gdGhpcy5fYnVmZmVyLnNsaWNlKHN0YXJ0IC0gdGhpcy5fYnVmZmVyT2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fYnVmZmVyT2Zmc2V0ID0gc3RhcnQ7XG4gICAgICB9IC8vIElmIHRoZSBidWZmZXIgaXMgZW1wdHkgYWZ0ZXIgcmVtb3Zpbmcgb2xkIGRhdGEsIGFsbCBkYXRhIGhhcyBiZWVuIHJlYWQuXG5cblxuICAgICAgdmFyIGhhc0FsbERhdGFCZWVuUmVhZCA9IGxlbih0aGlzLl9idWZmZXIpID09PSAwO1xuXG4gICAgICBpZiAodGhpcy5fZG9uZSAmJiBoYXNBbGxEYXRhQmVlblJlYWQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vIFdlIGFscmVhZHkgcmVtb3ZlZCBkYXRhIGJlZm9yZSBgc3RhcnRgLCBzbyB3ZSBqdXN0IHJldHVybiB0aGUgZmlyc3RcbiAgICAgIC8vIGNodW5rIGZyb20gdGhlIGJ1ZmZlci5cblxuXG4gICAgICByZXR1cm4gdGhpcy5fYnVmZmVyLnNsaWNlKDAsIGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5fcmVhZGVyLmNhbmNlbCkge1xuICAgICAgICB0aGlzLl9yZWFkZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmVhbVNvdXJjZTtcbn0oKTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gU3RyZWFtU291cmNlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgaXNDb3Jkb3ZhID0gZnVuY3Rpb24gaXNDb3Jkb3ZhKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHR5cGVvZiB3aW5kb3cuUGhvbmVHYXAgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiB3aW5kb3cuQ29yZG92YSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdy5jb3Jkb3ZhICE9PSAndW5kZWZpbmVkJyk7XG59O1xuXG52YXIgX2RlZmF1bHQgPSBpc0NvcmRvdmE7XG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHJlYWRBc0J5dGVBcnJheTtcblxuLyoqXG4gKiByZWFkQXNCeXRlQXJyYXkgY29udmVydHMgYSBGaWxlIG9iamVjdCB0byBhIFVpbnQ4QXJyYXkuXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgdXNlZCBvbiB0aGUgQXBhY2hlIENvcmRvdmEgcGxhdGZvcm0uXG4gKiBTZWUgaHR0cHM6Ly9jb3Jkb3ZhLmFwYWNoZS5vcmcvZG9jcy9lbi9sYXRlc3QvcmVmZXJlbmNlL2NvcmRvdmEtcGx1Z2luLWZpbGUvaW5kZXguaHRtbCNyZWFkLWEtZmlsZVxuICovXG5mdW5jdGlvbiByZWFkQXNCeXRlQXJyYXkoY2h1bmspIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblxuICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBuZXcgVWludDhBcnJheShyZWFkZXIucmVzdWx0KTtcbiAgICAgIHJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICByZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoY2h1bmspO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHVyaVRvQmxvYjtcblxuLyoqXG4gKiB1cmlUb0Jsb2IgcmVzb2x2ZXMgYSBVUkkgdG8gYSBCbG9iIG9iamVjdC4gVGhpcyBpcyB1c2VkIGZvclxuICogUmVhY3QgTmF0aXZlIHRvIHJldHJpZXZlIGEgZmlsZSAoaWRlbnRpZmllZCBieSBhIGZpbGU6Ly9cbiAqIFVSSSkgYXMgYSBibG9iLlxuICovXG5mdW5jdGlvbiB1cmlUb0Jsb2IodXJpKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYmxvYic7XG5cbiAgICB4aHIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGJsb2IgPSB4aHIucmVzcG9uc2U7XG4gICAgICByZXNvbHZlKGJsb2IpO1xuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH07XG5cbiAgICB4aHIub3BlbignR0VUJywgdXJpKTtcbiAgICB4aHIuc2VuZCgpO1xuICB9KTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuY2FuU3RvcmVVUkxzID0gZXhwb3J0cy5XZWJTdG9yYWdlVXJsU3RvcmFnZSA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbnZhciBoYXNTdG9yYWdlID0gZmFsc2U7XG5cbnRyeSB7XG4gIGhhc1N0b3JhZ2UgPSAnbG9jYWxTdG9yYWdlJyBpbiB3aW5kb3c7IC8vIEF0dGVtcHQgdG8gc3RvcmUgYW5kIHJlYWQgZW50cmllcyBmcm9tIHRoZSBsb2NhbCBzdG9yYWdlIHRvIGRldGVjdCBQcml2YXRlXG4gIC8vIE1vZGUgb24gU2FmYXJpIG9uIGlPUyAoc2VlICM0OSlcblxuICB2YXIga2V5ID0gJ3R1c1N1cHBvcnQnO1xuICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShrZXksIGxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSkpO1xufSBjYXRjaCAoZSkge1xuICAvLyBJZiB3ZSB0cnkgdG8gYWNjZXNzIGxvY2FsU3RvcmFnZSBpbnNpZGUgYSBzYW5kYm94ZWQgaWZyYW1lLCBhIFNlY3VyaXR5RXJyb3JcbiAgLy8gaXMgdGhyb3duLiBXaGVuIGluIHByaXZhdGUgbW9kZSBvbiBpT1MgU2FmYXJpLCBhIFF1b3RhRXhjZWVkZWRFcnJvciBpc1xuICAvLyB0aHJvd24gKHNlZSAjNDkpXG4gIGlmIChlLmNvZGUgPT09IGUuU0VDVVJJVFlfRVJSIHx8IGUuY29kZSA9PT0gZS5RVU9UQV9FWENFRURFRF9FUlIpIHtcbiAgICBoYXNTdG9yYWdlID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuXG52YXIgY2FuU3RvcmVVUkxzID0gaGFzU3RvcmFnZTtcbmV4cG9ydHMuY2FuU3RvcmVVUkxzID0gY2FuU3RvcmVVUkxzO1xuXG52YXIgV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXZWJTdG9yYWdlVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2ViU3RvcmFnZVVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFdlYlN0b3JhZ2VVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJmaW5kQWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kQWxsVXBsb2FkcygpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoJ3R1czo6Jyk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbmRVcGxvYWRzQnlGaW5nZXJwcmludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoZmluZ2VycHJpbnQpIHtcbiAgICAgIHZhciByZXN1bHRzID0gdGhpcy5fZmluZEVudHJpZXMoXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKSk7XG5cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVVcGxvYWQodXJsU3RvcmFnZUtleSkge1xuICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odXJsU3RvcmFnZUtleSk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgdmFyIGlkID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMWUxMik7XG4gICAgICB2YXIga2V5ID0gXCJ0dXM6OlwiLmNvbmNhdChmaW5nZXJwcmludCwgXCI6OlwiKS5jb25jYXQoaWQpO1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh1cGxvYWQpKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoa2V5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2ZpbmRFbnRyaWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9maW5kRW50cmllcyhwcmVmaXgpIHtcbiAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBfa2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcblxuICAgICAgICBpZiAoX2tleS5pbmRleE9mKHByZWZpeCkgIT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oX2tleSkpO1xuICAgICAgICAgIHVwbG9hZC51cmxTdG9yYWdlS2V5ID0gX2tleTtcbiAgICAgICAgICByZXN1bHRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgey8vIFRoZSBKU09OIHBhcnNlIGVycm9yIGlzIGludGVudGlvbmFsbHkgaWdub3JlZCBoZXJlLCBzbyBhIG1hbGZvcm1lZFxuICAgICAgICAgIC8vIGVudHJ5IGluIHRoZSBzdG9yYWdlIGNhbm5vdCBwcmV2ZW50IGFuIHVwbG9hZC5cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViU3RvcmFnZVVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuV2ViU3RvcmFnZVVybFN0b3JhZ2UgPSBXZWJTdG9yYWdlVXJsU3RvcmFnZTsiLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIF90eXBlb2Yob2JqKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHtcbiAgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkge1xuICAgIHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSxcbiAgICAgICAgcmVzdWx0O1xuXG4gICAgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHtcbiAgICAgIHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7XG5cbiAgICAgIHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cblxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cblxuICByZXR1cm4gc2VsZjtcbn1cblxuZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuXG4gIF93cmFwTmF0aXZlU3VwZXIgPSBmdW5jdGlvbiBfd3JhcE5hdGl2ZVN1cGVyKENsYXNzKSB7XG4gICAgaWYgKENsYXNzID09PSBudWxsIHx8ICFfaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcblxuICAgIGlmICh0eXBlb2YgQ2xhc3MgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgX2NhY2hlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoX2NhY2hlLmhhcyhDbGFzcykpIHJldHVybiBfY2FjaGUuZ2V0KENsYXNzKTtcblxuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gV3JhcHBlcigpIHtcbiAgICAgIHJldHVybiBfY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3Rvcik7XG4gICAgfVxuXG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihXcmFwcGVyLCBDbGFzcyk7XG4gIH07XG5cbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufVxuXG5mdW5jdGlvbiBfY29uc3RydWN0KFBhcmVudCwgYXJncywgQ2xhc3MpIHtcbiAgaWYgKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgX3NldFByb3RvdHlwZU9mKGluc3RhbmNlLCBDbGFzcy5wcm90b3R5cGUpO1xuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH07XG4gIH1cblxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gIGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7XG5cbiAgdHJ5IHtcbiAgICBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcbiAgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gICAgby5fX3Byb3RvX18gPSBwO1xuICAgIHJldHVybiBvO1xuICB9O1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG52YXIgRGV0YWlsZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhEZXRhaWxlZEVycm9yLCBfRXJyb3IpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRGV0YWlsZWRFcnJvcik7XG5cbiAgZnVuY3Rpb24gRGV0YWlsZWRFcnJvcihtZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgdmFyIGNhdXNpbmdFcnIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgdmFyIHJlcSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICB2YXIgcmVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERldGFpbGVkRXJyb3IpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKTtcbiAgICBfdGhpcy5vcmlnaW5hbFJlcXVlc3QgPSByZXE7XG4gICAgX3RoaXMub3JpZ2luYWxSZXNwb25zZSA9IHJlcztcbiAgICBfdGhpcy5jYXVzaW5nRXJyb3IgPSBjYXVzaW5nRXJyO1xuXG4gICAgaWYgKGNhdXNpbmdFcnIgIT0gbnVsbCkge1xuICAgICAgbWVzc2FnZSArPSBcIiwgY2F1c2VkIGJ5IFwiLmNvbmNhdChjYXVzaW5nRXJyLnRvU3RyaW5nKCkpO1xuICAgIH1cblxuICAgIGlmIChyZXEgIT0gbnVsbCkge1xuICAgICAgdmFyIHJlcXVlc3RJZCA9IHJlcS5nZXRIZWFkZXIoJ1gtUmVxdWVzdC1JRCcpIHx8ICduL2EnO1xuICAgICAgdmFyIG1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKTtcbiAgICAgIHZhciB1cmwgPSByZXEuZ2V0VVJMKCk7XG4gICAgICB2YXIgc3RhdHVzID0gcmVzID8gcmVzLmdldFN0YXR1cygpIDogJ24vYSc7XG4gICAgICB2YXIgYm9keSA9IHJlcyA/IHJlcy5nZXRCb2R5KCkgfHwgJycgOiAnbi9hJztcbiAgICAgIG1lc3NhZ2UgKz0gXCIsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFwiLmNvbmNhdChtZXRob2QsIFwiLCB1cmw6IFwiKS5jb25jYXQodXJsLCBcIiwgcmVzcG9uc2UgY29kZTogXCIpLmNvbmNhdChzdGF0dXMsIFwiLCByZXNwb25zZSB0ZXh0OiBcIikuY29uY2F0KGJvZHksIFwiLCByZXF1ZXN0IGlkOiBcIikuY29uY2F0KHJlcXVlc3RJZCwgXCIpXCIpO1xuICAgIH1cblxuICAgIF90aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRGV0YWlsZWRFcnJvcik7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG52YXIgX2RlZmF1bHQgPSBEZXRhaWxlZEVycm9yO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmVuYWJsZURlYnVnTG9nID0gZW5hYmxlRGVidWdMb2c7XG5leHBvcnRzLmxvZyA9IGxvZztcblxuLyogZXNsaW50IG5vLWNvbnNvbGU6IFwib2ZmXCIgKi9cbnZhciBpc0VuYWJsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gZW5hYmxlRGVidWdMb2coKSB7XG4gIGlzRW5hYmxlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIGxvZyhtc2cpIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHJldHVybjtcbiAgY29uc29sZS5sb2cobXNnKTtcbn0iLCJcInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZGVmYXVsdCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG4vKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFwib2ZmXCIgKi9cblxuXG52YXIgTm9vcFVybFN0b3JhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb29wVXJsU3RvcmFnZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9vcFVybFN0b3JhZ2UpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKE5vb3BVcmxTdG9yYWdlLCBbe1xuICAgIGtleTogXCJsaXN0QWxsVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0QWxsVXBsb2FkcygpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaW5kVXBsb2Fkc0J5RmluZ2VycHJpbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KGZpbmdlcnByaW50KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZVVwbG9hZCh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFVwbG9hZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRVcGxvYWQoZmluZ2VycHJpbnQsIHVwbG9hZCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9vcFVybFN0b3JhZ2U7XG59KCk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IE5vb3BVcmxTdG9yYWdlOyIsIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX2pzQmFzZSA9IHJlcXVpcmUoXCJqcy1iYXNlNjRcIik7XG5cbnZhciBfdXJsUGFyc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJ1cmwtcGFyc2VcIikpO1xuXG52YXIgX2Vycm9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiLi9lcnJvclwiKSk7XG5cbnZhciBfbG9nZ2VyID0gcmVxdWlyZShcIi4vbG9nZ2VyXCIpO1xuXG52YXIgX3V1aWQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCIuL3V1aWRcIikpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcbiAgICBhcnIyW2ldID0gYXJyW2ldO1xuICB9XG5cbiAgcmV0dXJuIGFycjI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG52YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG4gIGVuZHBvaW50OiBudWxsLFxuICB1cGxvYWRVcmw6IG51bGwsXG4gIG1ldGFkYXRhOiB7fSxcbiAgZmluZ2VycHJpbnQ6IG51bGwsXG4gIHVwbG9hZFNpemU6IG51bGwsXG4gIG9uUHJvZ3Jlc3M6IG51bGwsXG4gIG9uQ2h1bmtDb21wbGV0ZTogbnVsbCxcbiAgb25TdWNjZXNzOiBudWxsLFxuICBvbkVycm9yOiBudWxsLFxuICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IG51bGwsXG4gIG92ZXJyaWRlUGF0Y2hNZXRob2Q6IGZhbHNlLFxuICBoZWFkZXJzOiB7fSxcbiAgYWRkUmVxdWVzdElkOiBmYWxzZSxcbiAgb25CZWZvcmVSZXF1ZXN0OiBudWxsLFxuICBvbkFmdGVyUmVzcG9uc2U6IG51bGwsXG4gIG9uU2hvdWxkUmV0cnk6IG51bGwsXG4gIGNodW5rU2l6ZTogSW5maW5pdHksXG4gIHJldHJ5RGVsYXlzOiBbMCwgMTAwMCwgMzAwMCwgNTAwMF0sXG4gIHBhcmFsbGVsVXBsb2FkczogMSxcbiAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzczogZmFsc2UsXG4gIHVwbG9hZExlbmd0aERlZmVycmVkOiBmYWxzZSxcbiAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiBmYWxzZSxcbiAgdXJsU3RvcmFnZTogbnVsbCxcbiAgZmlsZVJlYWRlcjogbnVsbCxcbiAgaHR0cFN0YWNrOiBudWxsXG59O1xuXG52YXIgQmFzZVVwbG9hZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VVcGxvYWQoZmlsZSwgb3B0aW9ucykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVXBsb2FkKTsgLy8gV2FybiBhYm91dCByZW1vdmVkIG9wdGlvbnMgZnJvbSBwcmV2aW91cyB2ZXJzaW9uc1xuXG5cbiAgICBpZiAoJ3Jlc3VtZScgaW4gb3B0aW9ucykge1xuICAgICAgY29uc29sZS5sb2coJ3R1czogVGhlIGByZXN1bWVgIG9wdGlvbiBoYXMgYmVlbiByZW1vdmVkIGluIHR1cy1qcy1jbGllbnQgdjIuIFBsZWFzZSB1c2UgdGhlIFVSTCBzdG9yYWdlIEFQSSBpbnN0ZWFkLicpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICB9IC8vIFRoZSBkZWZhdWx0IG9wdGlvbnMgd2lsbCBhbHJlYWR5IGJlIGFkZGVkIGZyb20gdGhlIHdyYXBwZXIgY2xhc3Nlcy5cblxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9uczsgLy8gQ2FzdCBjaHVua1NpemUgdG8gaW50ZWdlclxuXG4gICAgdGhpcy5vcHRpb25zLmNodW5rU2l6ZSA9IE51bWJlcih0aGlzLm9wdGlvbnMuY2h1bmtTaXplKTsgLy8gVGhlIHN0b3JhZ2UgbW9kdWxlIHVzZWQgdG8gc3RvcmUgVVJMc1xuXG4gICAgdGhpcy5fdXJsU3RvcmFnZSA9IHRoaXMub3B0aW9ucy51cmxTdG9yYWdlOyAvLyBUaGUgdW5kZXJseWluZyBGaWxlL0Jsb2Igb2JqZWN0XG5cbiAgICB0aGlzLmZpbGUgPSBmaWxlOyAvLyBUaGUgVVJMIGFnYWluc3Qgd2hpY2ggdGhlIGZpbGUgd2lsbCBiZSB1cGxvYWRlZFxuXG4gICAgdGhpcy51cmwgPSBudWxsOyAvLyBUaGUgdW5kZXJseWluZyByZXF1ZXN0IG9iamVjdCBmb3IgdGhlIGN1cnJlbnQgUEFUQ0ggcmVxdWVzdFxuXG4gICAgdGhpcy5fcmVxID0gbnVsbDsgLy8gVGhlIGZpbmdlcnBpbnJ0IGZvciB0aGUgY3VycmVudCBmaWxlIChzZXQgYWZ0ZXIgc3RhcnQoKSlcblxuICAgIHRoaXMuX2ZpbmdlcnByaW50ID0gbnVsbDsgLy8gVGhlIGtleSB0aGF0IHRoZSBVUkwgc3RvcmFnZSByZXR1cm5lZCB3aGVuIHNhdmluZyBhbiBVUkwgd2l0aCBhIGZpbmdlcnByaW50LFxuXG4gICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IG51bGw7IC8vIFRoZSBvZmZzZXQgdXNlZCBpbiB0aGUgY3VycmVudCBQQVRDSCByZXF1ZXN0XG5cbiAgICB0aGlzLl9vZmZzZXQgPSBudWxsOyAvLyBUcnVlIGlmIHRoZSBjdXJyZW50IFBBVENIIHJlcXVlc3QgaGFzIGJlZW4gYWJvcnRlZFxuXG4gICAgdGhpcy5fYWJvcnRlZCA9IGZhbHNlOyAvLyBUaGUgZmlsZSdzIHNpemUgaW4gYnl0ZXNcblxuICAgIHRoaXMuX3NpemUgPSBudWxsOyAvLyBUaGUgU291cmNlIG9iamVjdCB3aGljaCB3aWxsIHdyYXAgYXJvdW5kIHRoZSBnaXZlbiBmaWxlIGFuZCBwcm92aWRlcyB1c1xuICAgIC8vIHdpdGggYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZ2V0dGluZyBpdHMgc2l6ZSBhbmQgc2xpY2UgY2h1bmtzIGZyb20gaXRzXG4gICAgLy8gY29udGVudCBhbGxvd2luZyB1cyB0byBlYXNpbHkgaGFuZGxlIEZpbGVzLCBCbG9icywgQnVmZmVycyBhbmQgU3RyZWFtcy5cblxuICAgIHRoaXMuX3NvdXJjZSA9IG51bGw7IC8vIFRoZSBjdXJyZW50IGNvdW50IG9mIGF0dGVtcHRzIHdoaWNoIGhhdmUgYmVlbiBtYWRlLiBaZXJvIGluZGljYXRlcyBub25lLlxuXG4gICAgdGhpcy5fcmV0cnlBdHRlbXB0ID0gMDsgLy8gVGhlIHRpbWVvdXQncyBJRCB3aGljaCBpcyB1c2VkIHRvIGRlbGF5IHRoZSBuZXh0IHJldHJ5XG5cbiAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsOyAvLyBUaGUgb2Zmc2V0IG9mIHRoZSByZW1vdGUgdXBsb2FkIGJlZm9yZSB0aGUgbGF0ZXN0IGF0dGVtcHQgd2FzIHN0YXJ0ZWQuXG5cbiAgICB0aGlzLl9vZmZzZXRCZWZvcmVSZXRyeSA9IDA7IC8vIEFuIGFycmF5IG9mIEJhc2VVcGxvYWQgaW5zdGFuY2VzIHdoaWNoIGFyZSB1c2VkIGZvciB1cGxvYWRpbmcgdGhlIGRpZmZlcmVudFxuICAgIC8vIHBhcnRzLCBpZiB0aGUgcGFyYWxsZWxVcGxvYWRzIG9wdGlvbiBpcyB1c2VkLlxuXG4gICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzID0gbnVsbDsgLy8gQW4gYXJyYXkgb2YgdXBsb2FkIFVSTHMgd2hpY2ggYXJlIHVzZWQgZm9yIHVwbG9hZGluZyB0aGUgZGlmZmVyZW50XG4gICAgLy8gcGFydHMsIGlmIHRoZSBwYXJhbGxlbFVwbG9hZHMgb3B0aW9uIGlzIHVzZWQuXG5cbiAgICB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBVc2UgdGhlIFRlcm1pbmF0aW9uIGV4dGVuc2lvbiB0byBkZWxldGUgYW4gdXBsb2FkIGZyb20gdGhlIHNlcnZlciBieSBzZW5kaW5nIGEgREVMRVRFXG4gICAqIHJlcXVlc3QgdG8gdGhlIHNwZWNpZmllZCB1cGxvYWQgVVJMLiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHNlcnZlciBzdXBwb3J0cyB0aGVcbiAgICogVGVybWluYXRpb24gZXh0ZW5zaW9uLiBJZiB0aGUgYG9wdGlvbnMucmV0cnlEZWxheXNgIHByb3BlcnR5IGlzIHNldCwgdGhlIG1ldGhvZCB3aWxsXG4gICAqIGFsc28gcmV0cnkgaWYgYW4gZXJyb3Igb2N1cnJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSB1cGxvYWQncyBVUkwgd2hpY2ggd2lsbCBiZSB0ZXJtaW5hdGVkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBvcHRpb25zIGZvciBpbmZsdWVuY2luZyBIVFRQIHJlcXVlc3RzLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVVwbG9hZCwgW3tcbiAgICBrZXk6IFwiZmluZFByZXZpb3VzVXBsb2Fkc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kUHJldmlvdXNVcGxvYWRzKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5maW5nZXJwcmludCh0aGlzLmZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLl91cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludChmaW5nZXJwcmludCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzdW1lRnJvbVByZXZpb3VzVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc3VtZUZyb21QcmV2aW91c1VwbG9hZChwcmV2aW91c1VwbG9hZCkge1xuICAgICAgdGhpcy51cmwgPSBwcmV2aW91c1VwbG9hZC51cGxvYWRVcmwgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IHByZXZpb3VzVXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscyB8fCBudWxsO1xuICAgICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IHByZXZpb3VzVXBsb2FkLnVybFN0b3JhZ2VLZXk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBmaWxlID0gdGhpcy5maWxlO1xuXG4gICAgICBpZiAoIWZpbGUpIHtcbiAgICAgICAgdGhpcy5fZW1pdEVycm9yKG5ldyBFcnJvcigndHVzOiBubyBmaWxlIG9yIHN0cmVhbSB0byB1cGxvYWQgcHJvdmlkZWQnKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCAmJiAhdGhpcy5vcHRpb25zLnVwbG9hZFVybCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IG5laXRoZXIgYW4gZW5kcG9pbnQgb3IgYW4gdXBsb2FkIFVSTCBpcyBwcm92aWRlZCcpKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXRyeURlbGF5cyA9IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5cztcblxuICAgICAgaWYgKHJldHJ5RGVsYXlzICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHJ5RGVsYXlzKSAhPT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IHRoZSBgcmV0cnlEZWxheXNgIG9wdGlvbiBtdXN0IGVpdGhlciBiZSBhbiBhcnJheSBvciBudWxsJykpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxKSB7XG4gICAgICAgIC8vIFRlc3Qgd2hpY2ggb3B0aW9ucyBhcmUgaW5jb21wYXRpYmxlIHdpdGggcGFyYWxsZWwgdXBsb2Fkcy5cbiAgICAgICAgWyd1cGxvYWRVcmwnLCAndXBsb2FkU2l6ZScsICd1cGxvYWRMZW5ndGhEZWZlcnJlZCddLmZvckVhY2goZnVuY3Rpb24gKG9wdGlvbk5hbWUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMyLm9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIF90aGlzMi5fZW1pdEVycm9yKG5ldyBFcnJvcihcInR1czogY2Fubm90IHVzZSB0aGUgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiIG9wdGlvbiB3aGVuIHBhcmFsbGVsVXBsb2FkcyBpcyBlbmFibGVkXCIpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmZpbmdlcnByaW50KGZpbGUsIHRoaXMub3B0aW9ucykudGhlbihmdW5jdGlvbiAoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgaWYgKGZpbmdlcnByaW50ID09IG51bGwpIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKCdObyBmaW5nZXJwcmludCB3YXMgY2FsY3VsYXRlZCBtZWFuaW5nIHRoYXQgdGhlIHVwbG9hZCBjYW5ub3QgYmUgc3RvcmVkIGluIHRoZSBVUkwgc3RvcmFnZS4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAoMCwgX2xvZ2dlci5sb2cpKFwiQ2FsY3VsYXRlZCBmaW5nZXJwcmludDogXCIuY29uY2F0KGZpbmdlcnByaW50KSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczIuX2ZpbmdlcnByaW50ID0gZmluZ2VycHJpbnQ7XG5cbiAgICAgICAgaWYgKF90aGlzMi5fc291cmNlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi5fc291cmNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMi5vcHRpb25zLmZpbGVSZWFkZXIub3BlbkZpbGUoZmlsZSwgX3RoaXMyLm9wdGlvbnMuY2h1bmtTaXplKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICBfdGhpczIuX3NvdXJjZSA9IHNvdXJjZTsgLy8gSWYgdGhlIHVwbG9hZCB3YXMgY29uZmlndXJlZCB0byB1c2UgbXVsdGlwbGUgcmVxdWVzdHMgb3IgaWYgd2UgcmVzdW1lIGZyb21cbiAgICAgICAgLy8gYW4gdXBsb2FkIHdoaWNoIHVzZWQgbXVsdGlwbGUgcmVxdWVzdHMsIHdlIHN0YXJ0IGEgcGFyYWxsZWwgdXBsb2FkLlxuXG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5wYXJhbGxlbFVwbG9hZHMgPiAxIHx8IF90aGlzMi5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwpIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0UGFyYWxsZWxVcGxvYWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3N0YXJ0U2luZ2xlVXBsb2FkKCk7XG4gICAgICAgIH1cbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBfdGhpczIuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYXRlIHRoZSB1cGxvYWRpbmcgcHJvY2VkdXJlIGZvciBhIHBhcmFsbGVsaXplZCB1cGxvYWQsIHdoZXJlIG9uZSBmaWxlIGlzIHNwbGl0IGludG9cbiAgICAgKiBtdWx0aXBsZSByZXF1ZXN0IHdoaWNoIGFyZSBydW4gaW4gcGFyYWxsZWwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFBhcmFsbGVsVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zdGFydFBhcmFsbGVsVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3NpemUgPSB0aGlzLl9zb3VyY2Uuc2l6ZTtcbiAgICAgIHZhciB0b3RhbFNpemUgPSB0aGlzLl9zaXplO1xuICAgICAgdmFyIHRvdGFsUHJvZ3Jlc3MgPSAwO1xuICAgICAgdGhpcy5fcGFyYWxsZWxVcGxvYWRzID0gW107XG4gICAgICB2YXIgcGFydENvdW50ID0gdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzICE9IG51bGwgPyB0aGlzLl9wYXJhbGxlbFVwbG9hZFVybHMubGVuZ3RoIDogdGhpcy5vcHRpb25zLnBhcmFsbGVsVXBsb2FkczsgLy8gVGhlIGlucHV0IGZpbGUgd2lsbCBiZSBzcGxpdCBpbnRvIG11bHRpcGxlIHNsaWNlcyB3aGljaCBhcmUgdXBsb2FkZWQgaW4gc2VwYXJhdGVcbiAgICAgIC8vIHJlcXVlc3RzLiBIZXJlIHdlIGdlbmVyYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIGZvciB0aGUgc2xpY2VzLlxuXG4gICAgICB2YXIgcGFydHMgPSBzcGxpdFNpemVJbnRvUGFydHModGhpcy5fc291cmNlLnNpemUsIHBhcnRDb3VudCwgdGhpcy5fcGFyYWxsZWxVcGxvYWRVcmxzKTsgLy8gQ3JlYXRlIGFuIGVtcHR5IGxpc3QgZm9yIHN0b3JpbmcgdGhlIHVwbG9hZCBVUkxzXG5cbiAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscyA9IG5ldyBBcnJheShwYXJ0cy5sZW5ndGgpOyAvLyBHZW5lcmF0ZSBhIHByb21pc2UgZm9yIGVhY2ggc2xpY2UgdGhhdCB3aWxsIGJlIHJlc29sdmUgaWYgdGhlIHJlc3BlY3RpdmVcbiAgICAgIC8vIHVwbG9hZCBpcyBjb21wbGV0ZWQuXG5cbiAgICAgIHZhciB1cGxvYWRzID0gcGFydHMubWFwKGZ1bmN0aW9uIChwYXJ0LCBpbmRleCkge1xuICAgICAgICB2YXIgbGFzdFBhcnRQcm9ncmVzcyA9IDA7XG4gICAgICAgIHJldHVybiBfdGhpczMuX3NvdXJjZS5zbGljZShwYXJ0LnN0YXJ0LCBwYXJ0LmVuZCkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYudmFsdWU7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIC8vIE1lcmdlIHdpdGggdGhlIHVzZXIgc3VwcGxpZWQgb3B0aW9ucyBidXQgb3ZlcndyaXRlIHNvbWUgdmFsdWVzLlxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIF90aGlzMy5vcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgLy8gSWYgYXZhaWxhYmxlLCB0aGUgcGFydGlhbCB1cGxvYWQgc2hvdWxkIGJlIHJlc3VtZWQgZnJvbSBhIHByZXZpb3VzIFVSTC5cbiAgICAgICAgICAgICAgdXBsb2FkVXJsOiBwYXJ0LnVwbG9hZFVybCB8fCBudWxsLFxuICAgICAgICAgICAgICAvLyBXZSB0YWtlIG1hbnVhbGx5IGNhcmUgb2YgcmVzdW1pbmcgZm9yIHBhcnRpYWwgdXBsb2Fkcywgc28gdGhleSBzaG91bGRcbiAgICAgICAgICAgICAgLy8gbm90IGJlIHN0b3JlZCBpbiB0aGUgVVJMIHN0b3JhZ2UuXG4gICAgICAgICAgICAgIHN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gdG8gbm90IGNhdXNlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICAgICAgICAgICAgICBtZXRhZGF0YToge30sXG4gICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGVhZGVyIHRvIGluZGljYXRlIHRoZSB0aGlzIGlzIGEgcGFydGlhbCB1cGxvYWQuXG4gICAgICAgICAgICAgIGhlYWRlcnM6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgX3RoaXMzLm9wdGlvbnMuaGVhZGVycyksIHt9LCB7XG4gICAgICAgICAgICAgICAgJ1VwbG9hZC1Db25jYXQnOiAncGFydGlhbCdcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIC8vIFJlamVjdCBvciByZXNvbHZlIHRoZSBwcm9taXNlIGlmIHRoZSB1cGxvYWQgZXJyb3JzIG9yIGNvbXBsZXRlcy5cbiAgICAgICAgICAgICAgb25TdWNjZXNzOiByZXNvbHZlLFxuICAgICAgICAgICAgICBvbkVycm9yOiByZWplY3QsXG4gICAgICAgICAgICAgIC8vIEJhc2VkIGluIHRoZSBwcm9ncmVzcyBmb3IgdGhpcyBwYXJ0aWFsIHVwbG9hZCwgY2FsY3VsYXRlIHRoZSBwcm9ncmVzc1xuICAgICAgICAgICAgICAvLyBmb3IgdGhlIGVudGlyZSBmaW5hbCB1cGxvYWQuXG4gICAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IGZ1bmN0aW9uIG9uUHJvZ3Jlc3MobmV3UGFydFByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdG90YWxQcm9ncmVzcyA9IHRvdGFsUHJvZ3Jlc3MgLSBsYXN0UGFydFByb2dyZXNzICsgbmV3UGFydFByb2dyZXNzO1xuICAgICAgICAgICAgICAgIGxhc3RQYXJ0UHJvZ3Jlc3MgPSBuZXdQYXJ0UHJvZ3Jlc3M7XG5cbiAgICAgICAgICAgICAgICBfdGhpczMuX2VtaXRQcm9ncmVzcyh0b3RhbFByb2dyZXNzLCB0b3RhbFNpemUpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAvLyBXYWl0IHVudGlsIGV2ZXJ5IHBhcnRpYWwgdXBsb2FkIGhhcyBhbiB1cGxvYWQgVVJMLCBzbyB3ZSBjYW4gYWRkXG4gICAgICAgICAgICAgIC8vIHRoZW0gdG8gdGhlIFVSTCBzdG9yYWdlLlxuICAgICAgICAgICAgICBfb25VcGxvYWRVcmxBdmFpbGFibGU6IGZ1bmN0aW9uIF9vblVwbG9hZFVybEF2YWlsYWJsZSgpIHtcbiAgICAgICAgICAgICAgICBfdGhpczMuX3BhcmFsbGVsVXBsb2FkVXJsc1tpbmRleF0gPSB1cGxvYWQudXJsOyAvLyBUZXN0IGlmIGFsbCB1cGxvYWRzIGhhdmUgcmVjZWl2ZWQgYW4gVVJMXG5cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMzLl9wYXJhbGxlbFVwbG9hZFVybHMuZmlsdGVyKGZ1bmN0aW9uICh1KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gQm9vbGVhbih1KTtcbiAgICAgICAgICAgICAgICB9KS5sZW5ndGggPT09IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgX3RoaXMzLl9zYXZlVXBsb2FkSW5VcmxTdG9yYWdlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHVwbG9hZCA9IG5ldyBCYXNlVXBsb2FkKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHVwbG9hZC5zdGFydCgpOyAvLyBTdG9yZSB0aGUgdXBsb2FkIGluIGFuIGFycmF5LCBzbyB3ZSBjYW4gbGF0ZXIgYWJvcnQgdGhlbSBpZiBuZWNlc3NhcnkuXG5cbiAgICAgICAgICAgIF90aGlzMy5fcGFyYWxsZWxVcGxvYWRzLnB1c2godXBsb2FkKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHZhciByZXE7IC8vIFdhaXQgdW50aWwgYWxsIHBhcnRpYWwgdXBsb2FkcyBhcmUgZmluaXNoZWQgYW5kIHdlIGNhbiBzZW5kIHRoZSBQT1NUIHJlcXVlc3QgZm9yXG4gICAgICAvLyBjcmVhdGluZyB0aGUgZmluYWwgdXBsb2FkLlxuXG4gICAgICBQcm9taXNlLmFsbCh1cGxvYWRzKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVxID0gX3RoaXMzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIF90aGlzMy5vcHRpb25zLmVuZHBvaW50KTtcbiAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUNvbmNhdCcsIFwiZmluYWw7XCIuY29uY2F0KF90aGlzMy5fcGFyYWxsZWxVcGxvYWRVcmxzLmpvaW4oJyAnKSkpOyAvLyBBZGQgbWV0YWRhdGEgaWYgdmFsdWVzIGhhdmUgYmVlbiBhZGRlZFxuXG4gICAgICAgIHZhciBtZXRhZGF0YSA9IGVuY29kZU1ldGFkYXRhKF90aGlzMy5vcHRpb25zLm1ldGFkYXRhKTtcblxuICAgICAgICBpZiAobWV0YWRhdGEgIT09ICcnKSB7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLU1ldGFkYXRhJywgbWV0YWRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF90aGlzMy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXMzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIGNyZWF0aW5nIHVwbG9hZCcpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvY2F0aW9uID0gcmVzLmdldEhlYWRlcignTG9jYXRpb24nKTtcblxuICAgICAgICBpZiAobG9jYXRpb24gPT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogaW52YWxpZCBvciBtaXNzaW5nIExvY2F0aW9uIGhlYWRlcicpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLnVybCA9IHJlc29sdmVVcmwoX3RoaXMzLm9wdGlvbnMuZW5kcG9pbnQsIGxvY2F0aW9uKTtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIkNyZWF0ZWQgdXBsb2FkIGF0IFwiLmNvbmNhdChfdGhpczMudXJsKSk7XG5cbiAgICAgICAgX3RoaXMzLl9lbWl0U3VjY2VzcygpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMy5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhdGUgdGhlIHVwbG9hZGluZyBwcm9jZWR1cmUgZm9yIGEgbm9uLXBhcmFsbGVsIHVwbG9hZC4gSGVyZSB0aGUgZW50aXJlIGZpbGUgaXNcbiAgICAgKiB1cGxvYWRlZCBpbiBhIHNlcXVlbnRpYWwgbWF0dGVyLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc3RhcnRTaW5nbGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0U2luZ2xlVXBsb2FkKCkge1xuICAgICAgLy8gRmlyc3QsIHdlIGxvb2sgYXQgdGhlIHVwbG9hZExlbmd0aERlZmVycmVkIG9wdGlvbi5cbiAgICAgIC8vIE5leHQsIHdlIGNoZWNrIGlmIHRoZSBjYWxsZXIgaGFzIHN1cHBsaWVkIGEgbWFudWFsIHVwbG9hZCBzaXplLlxuICAgICAgLy8gRmluYWxseSwgd2UgdHJ5IHRvIHVzZSB0aGUgY2FsY3VsYXRlZCBzaXplIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3NpemUgPSBOdW1iZXIodGhpcy5vcHRpb25zLnVwbG9hZFNpemUpO1xuXG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4odGhpcy5fc2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IGNhbm5vdCBjb252ZXJ0IGB1cGxvYWRTaXplYCBvcHRpb24gaW50byBhIG51bWJlcicpKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2l6ZSA9IHRoaXMuX3NvdXJjZS5zaXplO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaXplID09IG51bGwpIHtcbiAgICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKFwidHVzOiBjYW5ub3QgYXV0b21hdGljYWxseSBkZXJpdmUgdXBsb2FkJ3Mgc2l6ZSBmcm9tIGlucHV0LiBTcGVjaWZ5IGl0IG1hbnVhbGx5IHVzaW5nIHRoZSBgdXBsb2FkU2l6ZWAgb3B0aW9uIG9yIHVzZSB0aGUgYHVwbG9hZExlbmd0aERlZmVycmVkYCBvcHRpb25cIikpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IC8vIFJlc2V0IHRoZSBhYm9ydGVkIGZsYWcgd2hlbiB0aGUgdXBsb2FkIGlzIHN0YXJ0ZWQgb3IgZWxzZSB0aGVcbiAgICAgIC8vIF9wZXJmb3JtVXBsb2FkIHdpbGwgc3RvcCBiZWZvcmUgc2VuZGluZyBhIHJlcXVlc3QgaWYgdGhlIHVwbG9hZCBoYXMgYmVlblxuICAgICAgLy8gYWJvcnRlZCBwcmV2aW91c2x5LlxuXG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSBmYWxzZTsgLy8gVGhlIHVwbG9hZCBoYWQgYmVlbiBzdGFydGVkIHByZXZpb3VzbHkgYW5kIHdlIHNob3VsZCByZXVzZSB0aGlzIFVSTC5cblxuICAgICAgaWYgKHRoaXMudXJsICE9IG51bGwpIHtcbiAgICAgICAgKDAsIF9sb2dnZXIubG9nKShcIlJlc3VtaW5nIHVwbG9hZCBmcm9tIHByZXZpb3VzIFVSTDogXCIuY29uY2F0KHRoaXMudXJsKSk7XG5cbiAgICAgICAgdGhpcy5fcmVzdW1lVXBsb2FkKCk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBBIFVSTCBoYXMgbWFudWFsbHkgYmVlbiBzcGVjaWZpZWQsIHNvIHdlIHRyeSB0byByZXN1bWVcblxuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZFVybCAhPSBudWxsKSB7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJSZXN1bWluZyB1cGxvYWQgZnJvbSBwcm92aWRlZCBVUkw6IFwiLmNvbmNhdCh0aGlzLm9wdGlvbnMudXBsb2FkVXJsKSk7XG4gICAgICAgIHRoaXMudXJsID0gdGhpcy5vcHRpb25zLnVwbG9hZFVybDtcblxuICAgICAgICB0aGlzLl9yZXN1bWVVcGxvYWQoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIEFuIHVwbG9hZCBoYXMgbm90IHN0YXJ0ZWQgZm9yIHRoZSBmaWxlIHlldCwgc28gd2Ugc3RhcnQgYSBuZXcgb25lXG5cblxuICAgICAgKDAsIF9sb2dnZXIubG9nKSgnQ3JlYXRpbmcgYSBuZXcgdXBsb2FkJyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVVwbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBYm9ydCBhbnkgcnVubmluZyByZXF1ZXN0IGFuZCBzdG9wIHRoZSBjdXJyZW50IHVwbG9hZC4gQWZ0ZXIgYWJvcnQgaXMgY2FsbGVkLCBubyBldmVudFxuICAgICAqIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIGFueW1vcmUuIFlvdSBjYW4gdXNlIHRoZSBgc3RhcnRgIG1ldGhvZCB0byByZXN1bWUgdGhlIHVwbG9hZFxuICAgICAqIGFnYWluLlxuICAgICAqIElmIGBzaG91bGRUZXJtaW5hdGVgIGlzIHRydWUsIHRoZSBgdGVybWluYXRlYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byByZW1vdmUgdGhlXG4gICAgICogY3VycmVudCB1cGxvYWQgZnJvbSB0aGUgc2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRUZXJtaW5hdGUgVHJ1ZSBpZiB0aGUgdXBsb2FkIHNob3VsZCBiZSBkZWxldGVkIGZyb20gdGhlIHNlcnZlci5cbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB3aWxsIGJlIHJlc29sdmVkL3JlamVjdGVkIHdoZW4gdGhlIHJlcXVlc3RzIGZpbmlzaC5cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImFib3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFib3J0KHNob3VsZFRlcm1pbmF0ZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7IC8vIFN0b3AgYW55IHBhcmFsbGVsIHBhcnRpYWwgdXBsb2FkcywgdGhhdCBoYXZlIGJlZW4gc3RhcnRlZCBpbiBfc3RhcnRQYXJhbGxlbFVwbG9hZHMuXG5cblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2FkcyAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3BhcmFsbGVsVXBsb2Fkcy5mb3JFYWNoKGZ1bmN0aW9uICh1cGxvYWQpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoc2hvdWxkVGVybWluYXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIFN0b3AgYW55IGN1cnJlbnQgcnVubmluZyByZXF1ZXN0LlxuXG5cbiAgICAgIGlmICh0aGlzLl9yZXEgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcmVxLmFib3J0KCk7XG5cbiAgICAgICAgdGhpcy5fc291cmNlLmNsb3NlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Fib3J0ZWQgPSB0cnVlOyAvLyBTdG9wIGFueSB0aW1lb3V0IHVzZWQgZm9yIGluaXRpYXRpbmcgYSByZXRyeS5cblxuICAgICAgaWYgKHRoaXMuX3JldHJ5VGltZW91dCAhPSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXRyeVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl9yZXRyeVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNob3VsZFRlcm1pbmF0ZSB8fCB0aGlzLnVybCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIEJhc2VVcGxvYWQudGVybWluYXRlKHRoaXMudXJsLCB0aGlzLm9wdGlvbnMpIC8vIFJlbW92ZSBlbnRyeSBmcm9tIHRoZSBVUkwgc3RvcmFnZSBzaW5jZSB0aGUgdXBsb2FkIFVSTCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuX3JlbW92ZUZyb21VcmxTdG9yYWdlKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRIdHRwRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsIG1lc3NhZ2UsIGNhdXNpbmdFcnIpIHtcbiAgICAgIHRoaXMuX2VtaXRFcnJvcihuZXcgX2Vycm9yLmRlZmF1bHQobWVzc2FnZSwgY2F1c2luZ0VyciwgcmVxLCByZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2VtaXRFcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW1pdEVycm9yKGVycikge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7IC8vIERvIG5vdCBlbWl0IGVycm9ycywgZS5nLiBmcm9tIGFib3J0ZWQgSFRUUCByZXF1ZXN0cywgaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdG9wcGVkLlxuXG5cbiAgICAgIGlmICh0aGlzLl9hYm9ydGVkKSByZXR1cm47IC8vIENoZWNrIGlmIHdlIHNob3VsZCByZXRyeSwgd2hlbiBlbmFibGVkLCBiZWZvcmUgc2VuZGluZyB0aGUgZXJyb3IgdG8gdGhlIHVzZXIuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmV0cnlEZWxheXMgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSB3aWxsIHJlc2V0IHRoZSBhdHRlbXB0IGNvdW50ZXIgaWZcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFscmVhZHkgYWJsZSB0byBjb25uZWN0IHRvIHRoZSBzZXJ2ZXIgKG9mZnNldCAhPSBudWxsKSBhbmRcbiAgICAgICAgLy8gLSB3ZSB3ZXJlIGFibGUgdG8gdXBsb2FkIGEgc21hbGwgY2h1bmsgb2YgZGF0YSB0byB0aGUgc2VydmVyXG4gICAgICAgIHZhciBzaG91bGRSZXNldERlbGF5cyA9IHRoaXMuX29mZnNldCAhPSBudWxsICYmIHRoaXMuX29mZnNldCA+IHRoaXMuX29mZnNldEJlZm9yZVJldHJ5O1xuXG4gICAgICAgIGlmIChzaG91bGRSZXNldERlbGF5cykge1xuICAgICAgICAgIHRoaXMuX3JldHJ5QXR0ZW1wdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkUmV0cnkoZXJyLCB0aGlzLl9yZXRyeUF0dGVtcHQsIHRoaXMub3B0aW9ucykpIHtcbiAgICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLm9wdGlvbnMucmV0cnlEZWxheXNbdGhpcy5fcmV0cnlBdHRlbXB0KytdO1xuICAgICAgICAgIHRoaXMuX29mZnNldEJlZm9yZVJldHJ5ID0gdGhpcy5fb2Zmc2V0O1xuICAgICAgICAgIHRoaXMuX3JldHJ5VGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM1LnN0YXJ0KCk7XG4gICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5vbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2hlcyBub3RpZmljYXRpb24gaWYgdGhlIHVwbG9hZCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgY29tcGxldGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdFN1Y2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRTdWNjZXNzKCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2Vzcykge1xuICAgICAgICAvLyBSZW1vdmUgc3RvcmVkIGZpbmdlcnByaW50IGFuZCBjb3JyZXNwb25kaW5nIGVuZHBvaW50LiBUaGlzIGNhdXNlc1xuICAgICAgICAvLyBuZXcgdXBsb2FkcyBvZiB0aGUgc2FtZSBmaWxlIHRvIGJlIHRyZWF0ZWQgYXMgYSBkaWZmZXJlbnQgZmlsZS5cbiAgICAgICAgdGhpcy5fcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25TdWNjZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblN1Y2Nlc3MoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGRhdGEgaGFzIGJlZW4gc2VudCB0byB0aGUgc2VydmVyLiBUaGlzXG4gICAgICogZGF0YSBtYXkgbm90IGhhdmUgYmVlbiBhY2NlcHRlZCBieSB0aGUgc2VydmVyIHlldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1NlbnQgIE51bWJlciBvZiBieXRlcyBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVzVG90YWwgVG90YWwgbnVtYmVyIG9mIGJ5dGVzIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9lbWl0UHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRQcm9ncmVzcyhieXRlc1NlbnQsIGJ5dGVzVG90YWwpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uUHJvZ3Jlc3MoYnl0ZXNTZW50LCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHVibGlzaGVzIG5vdGlmaWNhdGlvbiB3aGVuIGEgY2h1bmsgb2YgZGF0YSBoYXMgYmVlbiBzZW50IHRvIHRoZSBzZXJ2ZXJcbiAgICAgKiBhbmQgYWNjZXB0ZWQgYnkgdGhlIHNlcnZlci5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY2h1bmtTaXplICBTaXplIG9mIHRoZSBjaHVuayB0aGF0IHdhcyBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc0FjY2VwdGVkIFRvdGFsIG51bWJlciBvZiBieXRlcyB0aGF0IGhhdmUgYmVlblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlcHRlZCBieSB0aGUgc2VydmVyLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBieXRlc1RvdGFsIFRvdGFsIG51bWJlciBvZiBieXRlcyB0byBiZSBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfZW1pdENodW5rQ29tcGxldGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VtaXRDaHVua0NvbXBsZXRlKGNodW5rU2l6ZSwgYnl0ZXNBY2NlcHRlZCwgYnl0ZXNUb3RhbCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMub25DaHVua0NvbXBsZXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vbkNodW5rQ29tcGxldGUoY2h1bmtTaXplLCBieXRlc0FjY2VwdGVkLCBieXRlc1RvdGFsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IHVwbG9hZCB1c2luZyB0aGUgY3JlYXRpb24gZXh0ZW5zaW9uIGJ5IHNlbmRpbmcgYSBQT1NUXG4gICAgICogcmVxdWVzdCB0byB0aGUgZW5kcG9pbnQuIEFmdGVyIHN1Y2Nlc3NmdWwgY3JlYXRpb24gdGhlIGZpbGUgd2lsbCBiZVxuICAgICAqIHVwbG9hZGVkXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9jcmVhdGVVcGxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVVwbG9hZCgpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbmRwb2ludCkge1xuICAgICAgICB0aGlzLl9lbWl0RXJyb3IobmV3IEVycm9yKCd0dXM6IHVuYWJsZSB0byBjcmVhdGUgdXBsb2FkIGJlY2F1c2Ugbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQnKSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoJ1BPU1QnLCB0aGlzLm9wdGlvbnMuZW5kcG9pbnQpO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1EZWZlci1MZW5ndGgnLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1MZW5ndGgnLCB0aGlzLl9zaXplKTtcbiAgICAgIH0gLy8gQWRkIG1ldGFkYXRhIGlmIHZhbHVlcyBoYXZlIGJlZW4gYWRkZWRcblxuXG4gICAgICB2YXIgbWV0YWRhdGEgPSBlbmNvZGVNZXRhZGF0YSh0aGlzLm9wdGlvbnMubWV0YWRhdGEpO1xuXG4gICAgICBpZiAobWV0YWRhdGEgIT09ICcnKSB7XG4gICAgICAgIHJlcS5zZXRIZWFkZXIoJ1VwbG9hZC1NZXRhZGF0YScsIG1ldGFkYXRhKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByb21pc2U7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uICYmICF0aGlzLm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICAgICAgcHJvbWlzZSA9IHRoaXMuX2FkZENodW5rVG9SZXF1ZXN0KHJlcSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlID0gdGhpcy5fc2VuZFJlcXVlc3QocmVxLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHJlcy5nZXRTdGF0dXMoKSwgMjAwKSkge1xuICAgICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQnKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhdGlvbiA9IHJlcy5nZXRIZWFkZXIoJ0xvY2F0aW9uJyk7XG5cbiAgICAgICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHtcbiAgICAgICAgICBfdGhpczYuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IGludmFsaWQgb3IgbWlzc2luZyBMb2NhdGlvbiBoZWFkZXInKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi51cmwgPSByZXNvbHZlVXJsKF90aGlzNi5vcHRpb25zLmVuZHBvaW50LCBsb2NhdGlvbik7XG4gICAgICAgICgwLCBfbG9nZ2VyLmxvZykoXCJDcmVhdGVkIHVwbG9hZCBhdCBcIi5jb25jYXQoX3RoaXM2LnVybCkpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3RoaXM2Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgX3RoaXM2Lm9wdGlvbnMuX29uVXBsb2FkVXJsQXZhaWxhYmxlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM2Ll9zaXplID09PSAwKSB7XG4gICAgICAgICAgLy8gTm90aGluZyB0byB1cGxvYWQgYW5kIGZpbGUgd2FzIHN1Y2Nlc3NmdWxseSBjcmVhdGVkXG4gICAgICAgICAgX3RoaXM2Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgX3RoaXM2Ll9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzNi5fc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpO1xuXG4gICAgICAgIGlmIChfdGhpczYub3B0aW9ucy51cGxvYWREYXRhRHVyaW5nQ3JlYXRpb24pIHtcbiAgICAgICAgICBfdGhpczYuX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczYuX29mZnNldCA9IDA7XG5cbiAgICAgICAgICBfdGhpczYuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzNi5fZW1pdEh0dHBFcnJvcihyZXEsIG51bGwsICd0dXM6IGZhaWxlZCB0byBjcmVhdGUgdXBsb2FkJywgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgICAqIFRyeSB0byByZXN1bWUgYW4gZXhpc3RpbmcgdXBsb2FkLiBGaXJzdCBhIEhFQUQgcmVxdWVzdCB3aWxsIGJlIHNlbnRcbiAgICAgKiB0byByZXRyaWV2ZSB0aGUgb2Zmc2V0LiBJZiB0aGUgcmVxdWVzdCBmYWlscyBhIG5ldyB1cGxvYWQgd2lsbCBiZVxuICAgICAqIGNyZWF0ZWQuIEluIHRoZSBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCByZXNwb25zZSB0aGUgZmlsZSB3aWxsIGJlIHVwbG9hZGVkLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfcmVzdW1lVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXN1bWVVcGxvYWQoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcblxuICAgICAgdmFyIHJlcSA9IHRoaXMuX29wZW5SZXF1ZXN0KCdIRUFEJywgdGhpcy51cmwpO1xuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMuX3NlbmRSZXF1ZXN0KHJlcSwgbnVsbCk7XG5cbiAgICAgIHByb21pc2UudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSByZXMuZ2V0U3RhdHVzKCk7XG5cbiAgICAgICAgaWYgKCFpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgMjAwKSkge1xuICAgICAgICAgIGlmIChpblN0YXR1c0NhdGVnb3J5KHN0YXR1cywgNDAwKSkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHN0b3JlZCBmaW5nZXJwcmludCBhbmQgY29ycmVzcG9uZGluZyBlbmRwb2ludCxcbiAgICAgICAgICAgIC8vIG9uIGNsaWVudCBlcnJvcnMgc2luY2UgdGhlIGZpbGUgY2FuIG5vdCBiZSBmb3VuZFxuICAgICAgICAgICAgX3RoaXM3Ll9yZW1vdmVGcm9tVXJsU3RvcmFnZSgpO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIHVwbG9hZCBpcyBsb2NrZWQgKGluZGljYXRlZCBieSB0aGUgNDIzIExvY2tlZCBzdGF0dXMgY29kZSksIHdlXG4gICAgICAgICAgLy8gZW1pdCBhbiBlcnJvciBpbnN0ZWFkIG9mIGRpcmVjdGx5IHN0YXJ0aW5nIGEgbmV3IHVwbG9hZC4gVGhpcyB3YXkgdGhlXG4gICAgICAgICAgLy8gcmV0cnkgbG9naWMgY2FuIGNhdGNoIHRoZSBlcnJvciBhbmQgd2lsbCByZXRyeSB0aGUgdXBsb2FkLiBBbiB1cGxvYWRcbiAgICAgICAgICAvLyBpcyB1c3VhbGx5IGxvY2tlZCBmb3IgYSBzaG9ydCBwZXJpb2Qgb2YgdGltZSBhbmQgd2lsbCBiZSBhdmFpbGFibGVcbiAgICAgICAgICAvLyBhZnRlcndhcmRzLlxuXG5cbiAgICAgICAgICBpZiAoc3RhdHVzID09PSA0MjMpIHtcbiAgICAgICAgICAgIF90aGlzNy5fZW1pdEh0dHBFcnJvcihyZXEsIHJlcywgJ3R1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyJyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV90aGlzNy5vcHRpb25zLmVuZHBvaW50KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBhdHRlbXB0IHRvIGNyZWF0ZSBhIG5ldyB1cGxvYWQgaWYgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IHVuYWJsZSB0byByZXN1bWUgdXBsb2FkIChuZXcgdXBsb2FkIGNhbm5vdCBiZSBjcmVhdGVkIHdpdGhvdXQgYW4gZW5kcG9pbnQpJyk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IC8vIFRyeSB0byBjcmVhdGUgYSBuZXcgdXBsb2FkXG5cblxuICAgICAgICAgIF90aGlzNy51cmwgPSBudWxsO1xuXG4gICAgICAgICAgX3RoaXM3Ll9jcmVhdGVVcGxvYWQoKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzZXQgPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JyksIDEwKTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICBfdGhpczcuX2VtaXRIdHRwRXJyb3IocmVxLCByZXMsICd0dXM6IGludmFsaWQgb3IgbWlzc2luZyBvZmZzZXQgdmFsdWUnKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXJzZUludChyZXMuZ2V0SGVhZGVyKCdVcGxvYWQtTGVuZ3RoJyksIDEwKTtcblxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGxlbmd0aCkgJiYgIV90aGlzNy5vcHRpb25zLnVwbG9hZExlbmd0aERlZmVycmVkKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgbGVuZ3RoIHZhbHVlJyk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIF90aGlzNy5vcHRpb25zLl9vblVwbG9hZFVybEF2YWlsYWJsZSgpO1xuICAgICAgICB9IC8vIFVwbG9hZCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBsZXRlZCBhbmQgd2UgZG8gbm90IG5lZWQgdG8gc2VuZCBhZGRpdGlvbmFsXG4gICAgICAgIC8vIGRhdGEgdG8gdGhlIHNlcnZlclxuXG5cbiAgICAgICAgaWYgKG9mZnNldCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgX3RoaXM3Ll9lbWl0UHJvZ3Jlc3MobGVuZ3RoLCBsZW5ndGgpO1xuXG4gICAgICAgICAgX3RoaXM3Ll9lbWl0U3VjY2VzcygpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM3Ll9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgICAgX3RoaXM3Ll9wZXJmb3JtVXBsb2FkKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXM3Ll9lbWl0SHR0cEVycm9yKHJlcSwgbnVsbCwgJ3R1czogZmFpbGVkIHRvIHJlc3VtZSB1cGxvYWQnLCBlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHVwbG9hZGluZyB0aGUgZmlsZSB1c2luZyBQQVRDSCByZXF1ZXN0cy4gVGhlIGZpbGUgd2lsbCBiZSBkaXZpZGVkXG4gICAgICogaW50byBjaHVua3MgYXMgc3BlY2lmaWVkIGluIHRoZSBjaHVua1NpemUgb3B0aW9uLiBEdXJpbmcgdGhlIHVwbG9hZFxuICAgICAqIHRoZSBvblByb2dyZXNzIGV2ZW50IGhhbmRsZXIgbWF5IGJlIGludm9rZWQgbXVsdGlwbGUgdGltZXMuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9wZXJmb3JtVXBsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wZXJmb3JtVXBsb2FkKCkge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7IC8vIElmIHRoZSB1cGxvYWQgaGFzIGJlZW4gYWJvcnRlZCwgd2Ugd2lsbCBub3Qgc2VuZCB0aGUgbmV4dCBQQVRDSCByZXF1ZXN0LlxuICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgaWYgdGhlIGFib3J0IG1ldGhvZCB3YXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrLCBzdWNoXG4gICAgICAvLyBhcyBvbkNodW5rQ29tcGxldGUgb3Igb25Qcm9ncmVzcy5cblxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXE7IC8vIFNvbWUgYnJvd3NlciBhbmQgc2VydmVycyBtYXkgbm90IHN1cHBvcnQgdGhlIFBBVENIIG1ldGhvZC4gRm9yIHRob3NlXG4gICAgICAvLyBjYXNlcywgeW91IGNhbiB0ZWxsIHR1cy1qcy1jbGllbnQgdG8gdXNlIGEgUE9TVCByZXF1ZXN0IHdpdGggdGhlXG4gICAgICAvLyBYLUhUVFAtTWV0aG9kLU92ZXJyaWRlIGhlYWRlciBmb3Igc2ltdWxhdGluZyBhIFBBVENIIHJlcXVlc3QuXG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcnJpZGVQYXRjaE1ldGhvZCkge1xuICAgICAgICByZXEgPSB0aGlzLl9vcGVuUmVxdWVzdCgnUE9TVCcsIHRoaXMudXJsKTtcbiAgICAgICAgcmVxLnNldEhlYWRlcignWC1IVFRQLU1ldGhvZC1PdmVycmlkZScsICdQQVRDSCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVxID0gdGhpcy5fb3BlblJlcXVlc3QoJ1BBVENIJywgdGhpcy51cmwpO1xuICAgICAgfVxuXG4gICAgICByZXEuc2V0SGVhZGVyKCdVcGxvYWQtT2Zmc2V0JywgdGhpcy5fb2Zmc2V0KTtcblxuICAgICAgdmFyIHByb21pc2UgPSB0aGlzLl9hZGRDaHVua1RvUmVxdWVzdChyZXEpO1xuXG4gICAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIWluU3RhdHVzQ2F0ZWdvcnkocmVzLmdldFN0YXR1cygpLCAyMDApKSB7XG4gICAgICAgICAgX3RoaXM4Ll9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHVwbG9hZGluZyBjaHVuaycpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM4Ll9oYW5kbGVVcGxvYWRSZXNwb25zZShyZXEsIHJlcyk7XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gRG9uJ3QgZW1pdCBhbiBlcnJvciBpZiB0aGUgdXBsb2FkIHdhcyBhYm9ydGVkIG1hbnVhbGx5XG4gICAgICAgIGlmIChfdGhpczguX2Fib3J0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczguX2VtaXRIdHRwRXJyb3IocmVxLCBudWxsLCBcInR1czogZmFpbGVkIHRvIHVwbG9hZCBjaHVuayBhdCBvZmZzZXQgXCIuY29uY2F0KF90aGlzOC5fb2Zmc2V0KSwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBfYWRkQ2h1bmt0b1JlcXVlc3QgcmVhZHMgYSBjaHVuayBmcm9tIHRoZSBzb3VyY2UgYW5kIHNlbmRzIGl0IHVzaW5nIHRoZVxuICAgICAqIHN1cHBsaWVkIHJlcXVlc3Qgb2JqZWN0LiBJdCB3aWxsIG5vdCBoYW5kbGUgdGhlIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfYWRkQ2h1bmtUb1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZENodW5rVG9SZXF1ZXN0KHJlcSkge1xuICAgICAgdmFyIF90aGlzOSA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBlbmQgPSB0aGlzLl9vZmZzZXQgKyB0aGlzLm9wdGlvbnMuY2h1bmtTaXplO1xuICAgICAgcmVxLnNldFByb2dyZXNzSGFuZGxlcihmdW5jdGlvbiAoYnl0ZXNTZW50KSB7XG4gICAgICAgIF90aGlzOS5fZW1pdFByb2dyZXNzKHN0YXJ0ICsgYnl0ZXNTZW50LCBfdGhpczkuX3NpemUpO1xuICAgICAgfSk7XG4gICAgICByZXEuc2V0SGVhZGVyKCdDb250ZW50LVR5cGUnLCAnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpOyAvLyBUaGUgc3BlY2lmaWVkIGNodW5rU2l6ZSBtYXkgYmUgSW5maW5pdHkgb3IgdGhlIGNhbGNsdWF0ZWQgZW5kIHBvc2l0aW9uXG4gICAgICAvLyBtYXkgZXhjZWVkIHRoZSBmaWxlJ3Mgc2l6ZS4gSW4gYm90aCBjYXNlcywgd2UgbGltaXQgdGhlIGVuZCBwb3NpdGlvbiB0b1xuICAgICAgLy8gdGhlIGlucHV0J3MgdG90YWwgc2l6ZSBmb3Igc2ltcGxlciBjYWxjdWxhdGlvbnMgYW5kIGNvcnJlY3RuZXNzLlxuXG4gICAgICBpZiAoKGVuZCA9PT0gSW5maW5pdHkgfHwgZW5kID4gdGhpcy5fc2l6ZSkgJiYgIXRoaXMub3B0aW9ucy51cGxvYWRMZW5ndGhEZWZlcnJlZCkge1xuICAgICAgICBlbmQgPSB0aGlzLl9zaXplO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpLnRoZW4oZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgZG9uZSA9IF9yZWYyLmRvbmU7IC8vIElmIHRoZSB1cGxvYWQgbGVuZ3RoIGlzIGRlZmVycmVkLCB0aGUgdXBsb2FkIHNpemUgd2FzIG5vdCBzcGVjaWZpZWQgZHVyaW5nXG4gICAgICAgIC8vIHVwbG9hZCBjcmVhdGlvbi4gU28sIGlmIHRoZSBmaWxlIHJlYWRlciBpcyBkb25lIHJlYWRpbmcsIHdlIGtub3cgdGhlIHRvdGFsXG4gICAgICAgIC8vIHVwbG9hZCBzaXplIGFuZCBjYW4gdGVsbCB0aGUgdHVzIHNlcnZlci5cblxuICAgICAgICBpZiAoX3RoaXM5Lm9wdGlvbnMudXBsb2FkTGVuZ3RoRGVmZXJyZWQgJiYgZG9uZSkge1xuICAgICAgICAgIF90aGlzOS5fc2l6ZSA9IF90aGlzOS5fb2Zmc2V0ICsgKHZhbHVlICYmIHZhbHVlLnNpemUgPyB2YWx1ZS5zaXplIDogMCk7XG4gICAgICAgICAgcmVxLnNldEhlYWRlcignVXBsb2FkLUxlbmd0aCcsIF90aGlzOS5fc2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5Ll9zZW5kUmVxdWVzdChyZXEpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM5Ll9lbWl0UHJvZ3Jlc3MoX3RoaXM5Ll9vZmZzZXQsIF90aGlzOS5fc2l6ZSk7XG5cbiAgICAgICAgcmV0dXJuIF90aGlzOS5fc2VuZFJlcXVlc3QocmVxLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogX2hhbmRsZVVwbG9hZFJlc3BvbnNlIGlzIHVzZWQgYnkgcmVxdWVzdHMgdGhhdCBoYXZlbiBiZWVuIHNlbnQgdXNpbmcgX2FkZENodW5rVG9SZXF1ZXN0XG4gICAgICogYW5kIGFscmVhZHkgaGF2ZSByZWNlaXZlZCBhIHJlc3BvbnNlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfaGFuZGxlVXBsb2FkUmVzcG9uc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2hhbmRsZVVwbG9hZFJlc3BvbnNlKHJlcSwgcmVzKSB7XG4gICAgICB2YXIgb2Zmc2V0ID0gcGFyc2VJbnQocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpLCAxMCk7XG5cbiAgICAgIGlmIChOdW1iZXIuaXNOYU4ob2Zmc2V0KSkge1xuICAgICAgICB0aGlzLl9lbWl0SHR0cEVycm9yKHJlcSwgcmVzLCAndHVzOiBpbnZhbGlkIG9yIG1pc3Npbmcgb2Zmc2V0IHZhbHVlJyk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9lbWl0UHJvZ3Jlc3Mob2Zmc2V0LCB0aGlzLl9zaXplKTtcblxuICAgICAgdGhpcy5fZW1pdENodW5rQ29tcGxldGUob2Zmc2V0IC0gdGhpcy5fb2Zmc2V0LCBvZmZzZXQsIHRoaXMuX3NpemUpO1xuXG4gICAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG5cbiAgICAgIGlmIChvZmZzZXQgPT09IHRoaXMuX3NpemUpIHtcbiAgICAgICAgLy8gWWF5LCBmaW5hbGx5IGRvbmUgOilcbiAgICAgICAgdGhpcy5fZW1pdFN1Y2Nlc3MoKTtcblxuICAgICAgICB0aGlzLl9zb3VyY2UuY2xvc2UoKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BlcmZvcm1VcGxvYWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IEhUVFAgcmVxdWVzdCBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gbWV0aG9kIGFuZCBVUkwuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9vcGVuUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb3BlblJlcXVlc3QobWV0aG9kLCB1cmwpIHtcbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdChtZXRob2QsIHVybCwgdGhpcy5vcHRpb25zKTtcbiAgICAgIHRoaXMuX3JlcSA9IHJlcTtcbiAgICAgIHJldHVybiByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGUgZW50cnkgaW4gdGhlIFVSTCBzdG9yYWdlLCBpZiBpdCBoYXMgYmVlbiBzYXZlZCBiZWZvcmUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9yZW1vdmVGcm9tVXJsU3RvcmFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVtb3ZlRnJvbVVybFN0b3JhZ2UoKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG5cbiAgICAgIGlmICghdGhpcy5fdXJsU3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlLnJlbW92ZVVwbG9hZCh0aGlzLl91cmxTdG9yYWdlS2V5KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgX3RoaXMxMC5fZW1pdEVycm9yKGVycik7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdXJsU3RvcmFnZUtleSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgdXBsb2FkIFVSTCB0byB0aGUgVVJMIHN0b3JhZ2UsIGlmIHBvc3NpYmxlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJfc2F2ZVVwbG9hZEluVXJsU3RvcmFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2F2ZVVwbG9hZEluVXJsU3RvcmFnZSgpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpczsgLy8gT25seSBpZiBhIGZpbmdlcnByaW50IHdhcyBjYWxjdWxhdGVkIGZvciB0aGUgaW5wdXQgKGkuZS4gbm90IGEgc3RyZWFtKSwgd2UgY2FuIHN0b3JlIHRoZSB1cGxvYWQgVVJMLlxuXG5cbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0b3JlRmluZ2VycHJpbnRGb3JSZXN1bWluZyB8fCAhdGhpcy5fZmluZ2VycHJpbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RvcmVkVXBsb2FkID0ge1xuICAgICAgICBzaXplOiB0aGlzLl9zaXplLFxuICAgICAgICBtZXRhZGF0YTogdGhpcy5vcHRpb25zLm1ldGFkYXRhLFxuICAgICAgICBjcmVhdGlvblRpbWU6IG5ldyBEYXRlKCkudG9TdHJpbmcoKVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX3BhcmFsbGVsVXBsb2Fkcykge1xuICAgICAgICAvLyBTYXZlIG11bHRpcGxlIFVSTHMgaWYgdGhlIHBhcmFsbGVsVXBsb2FkcyBvcHRpb24gaXMgdXNlZCAuLi5cbiAgICAgICAgc3RvcmVkVXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscyA9IHRoaXMuX3BhcmFsbGVsVXBsb2FkVXJscztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIC4uLiBvdGhlcndpc2Ugd2UganVzdCBzYXZlIHRoZSBvbmUgYXZhaWxhYmxlIFVSTC5cbiAgICAgICAgc3RvcmVkVXBsb2FkLnVwbG9hZFVybCA9IHRoaXMudXJsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl91cmxTdG9yYWdlLmFkZFVwbG9hZCh0aGlzLl9maW5nZXJwcmludCwgc3RvcmVkVXBsb2FkKS50aGVuKGZ1bmN0aW9uICh1cmxTdG9yYWdlS2V5KSB7XG4gICAgICAgIF90aGlzMTEuX3VybFN0b3JhZ2VLZXkgPSB1cmxTdG9yYWdlS2V5O1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIF90aGlzMTEuX2VtaXRFcnJvcihlcnIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcIl9zZW5kUmVxdWVzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2VuZFJlcXVlc3QocmVxKSB7XG4gICAgICB2YXIgYm9keSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIHRoaXMub3B0aW9ucyk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwidGVybWluYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRlcm1pbmF0ZSh1cmwpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZXEgPSBvcGVuUmVxdWVzdCgnREVMRVRFJywgdXJsLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBzZW5kUmVxdWVzdChyZXEsIG51bGwsIG9wdGlvbnMpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICAvLyBBIDIwNCByZXNwb25zZSBpbmRpY2F0ZXMgYSBzdWNjZXNzZnVsbCByZXF1ZXN0XG4gICAgICAgIGlmIChyZXMuZ2V0U3RhdHVzKCkgPT09IDIwNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBfZXJyb3IuZGVmYXVsdCgndHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZCcsIG51bGwsIHJlcSwgcmVzKTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoIShlcnIgaW5zdGFuY2VvZiBfZXJyb3IuZGVmYXVsdCkpIHtcbiAgICAgICAgICBlcnIgPSBuZXcgX2Vycm9yLmRlZmF1bHQoJ3R1czogZmFpbGVkIHRvIHRlcm1pbmF0ZSB1cGxvYWQnLCBlcnIsIHJlcSwgbnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXNob3VsZFJldHJ5KGVyciwgMCwgb3B0aW9ucykpIHtcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gLy8gSW5zdGVhZCBvZiBrZWVwaW5nIHRyYWNrIG9mIHRoZSByZXRyeSBhdHRlbXB0cywgd2UgcmVtb3ZlIHRoZSBmaXJzdCBlbGVtZW50IGZyb20gdGhlIGRlbGF5c1xuICAgICAgICAvLyBhcnJheS4gSWYgdGhlIGFycmF5IGlzIGVtcHR5LCBhbGwgcmV0cnkgYXR0ZW1wdHMgYXJlIHVzZWQgdXAgYW5kIHdlIHdpbGwgYnViYmxlIHVwIHRoZSBlcnJvci5cbiAgICAgICAgLy8gV2UgcmVjdXJzaXZlbHkgY2FsbCB0aGUgdGVybWluYXRlIGZ1bmN0aW9uIHdpbGwgcmVtb3ZpbmcgZWxlbWVudHMgZnJvbSB0aGUgcmV0cnlEZWxheXMgYXJyYXkuXG5cblxuICAgICAgICB2YXIgZGVsYXkgPSBvcHRpb25zLnJldHJ5RGVsYXlzWzBdO1xuICAgICAgICB2YXIgcmVtYWluaW5nRGVsYXlzID0gb3B0aW9ucy5yZXRyeURlbGF5cy5zbGljZSgxKTtcblxuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgcmV0cnlEZWxheXM6IHJlbWFpbmluZ0RlbGF5c1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBCYXNlVXBsb2FkLnRlcm1pbmF0ZSh1cmwsIG5ld09wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVXBsb2FkO1xufSgpO1xuXG5mdW5jdGlvbiBlbmNvZGVNZXRhZGF0YShtZXRhZGF0YSkge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMobWV0YWRhdGEpLm1hcChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICB2YXIgX3JlZjQgPSBfc2xpY2VkVG9BcnJheShfcmVmMywgMiksXG4gICAgICAgIGtleSA9IF9yZWY0WzBdLFxuICAgICAgICB2YWx1ZSA9IF9yZWY0WzFdO1xuXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGtleSwgXCIgXCIpLmNvbmNhdChfanNCYXNlLkJhc2U2NC5lbmNvZGUoU3RyaW5nKHZhbHVlKSkpO1xuICB9KS5qb2luKCcsJyk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gc3RhdHVzIGlzIGluIHRoZSByYW5nZSBvZiB0aGUgZXhwZWN0ZWQgY2F0ZWdvcnkuXG4gKiBGb3IgZXhhbXBsZSwgb25seSBhIHN0YXR1cyBiZXR3ZWVuIDIwMCBhbmQgMjk5IHdpbGwgc2F0aXNmeSB0aGUgY2F0ZWdvcnkgMjAwLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIGNhdGVnb3J5KSB7XG4gIHJldHVybiBzdGF0dXMgPj0gY2F0ZWdvcnkgJiYgc3RhdHVzIDwgY2F0ZWdvcnkgKyAxMDA7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgc3BlY2lmaWVkIG1ldGhvZCBhbmQgVVJMLlxuICogVGhlIG5lY2Vzc2FyeSBoZWFkZXJzIHRoYXQgYXJlIGluY2x1ZGVkIGluIGV2ZXJ5IHJlcXVlc3RcbiAqIHdpbGwgYmUgYWRkZWQsIGluY2x1ZGluZyB0aGUgcmVxdWVzdCBJRC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIG9wZW5SZXF1ZXN0KG1ldGhvZCwgdXJsLCBvcHRpb25zKSB7XG4gIHZhciByZXEgPSBvcHRpb25zLmh0dHBTdGFjay5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgdXJsKTtcbiAgcmVxLnNldEhlYWRlcignVHVzLVJlc3VtYWJsZScsICcxLjAuMCcpO1xuICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgT2JqZWN0LmVudHJpZXMoaGVhZGVycykuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICB2YXIgX3JlZjYgPSBfc2xpY2VkVG9BcnJheShfcmVmNSwgMiksXG4gICAgICAgIG5hbWUgPSBfcmVmNlswXSxcbiAgICAgICAgdmFsdWUgPSBfcmVmNlsxXTtcblxuICAgIHJlcS5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xuICB9KTtcblxuICBpZiAob3B0aW9ucy5hZGRSZXF1ZXN0SWQpIHtcbiAgICB2YXIgcmVxdWVzdElkID0gKDAsIF91dWlkLmRlZmF1bHQpKCk7XG4gICAgcmVxLnNldEhlYWRlcignWC1SZXF1ZXN0LUlEJywgcmVxdWVzdElkKTtcbiAgfVxuXG4gIHJldHVybiByZXE7XG59XG4vKipcbiAqIFNlbmQgYSByZXF1ZXN0IHdpdGggdGhlIHByb3ZpZGVkIGJvZHkgd2hpbGUgaW52b2tpbmcgdGhlIG9uQmVmb3JlUmVxdWVzdFxuICogYW5kIG9uQWZ0ZXJSZXNwb25zZSBjYWxsYmFja3MuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzZW5kUmVxdWVzdChyZXEsIGJvZHksIG9wdGlvbnMpIHtcbiAgdmFyIG9uQmVmb3JlUmVxdWVzdFByb21pc2UgPSB0eXBlb2Ygb3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QocmVxKSkgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgcmV0dXJuIG9uQmVmb3JlUmVxdWVzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJlcS5zZW5kKGJvZHkpLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgdmFyIG9uQWZ0ZXJSZXNwb25zZVByb21pc2UgPSB0eXBlb2Ygb3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgPyBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UocmVxLCByZXMpKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgcmV0dXJuIG9uQWZ0ZXJSZXNwb25zZVByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfSk7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBicm93c2VyIHJ1bm5pbmcgdGhpcyBjb2RlIGhhcyBpbnRlcm5ldCBhY2Nlc3MuXG4gKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYWx3YXlzIHJldHVybiB0cnVlIGluIHRoZSBub2RlLmpzIGVudmlyb25tZW50XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBpc09ubGluZSgpIHtcbiAgdmFyIG9ubGluZSA9IHRydWU7XG5cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICduYXZpZ2F0b3InIGluIHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yLm9uTGluZSA9PT0gZmFsc2UpIHtcbiAgICBvbmxpbmUgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBvbmxpbmU7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCBpdCBpcyBvayB0byByZXRyeSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgdGhlIGVycm9yIHJldHVybmVkIGZyb20gdGhlIGxhc3QgcmVxdWVzdFxuICogQHBhcmFtIHtudW1iZXJ9IHJldHJ5QXR0ZW1wdCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByZXF1ZXN0IGhhcyBhbHJlYWR5IGJlZW4gcmV0cmllZFxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgdHVzIFVwbG9hZCBvcHRpb25zXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzaG91bGRSZXRyeShlcnIsIHJldHJ5QXR0ZW1wdCwgb3B0aW9ucykge1xuICAvLyBXZSBvbmx5IGF0dGVtcHQgYSByZXRyeSBpZlxuICAvLyAtIHJldHJ5RGVsYXlzIG9wdGlvbiBpcyBzZXRcbiAgLy8gLSB3ZSBkaWRuJ3QgZXhjZWVkIHRoZSBtYXhpdW0gbnVtYmVyIG9mIHJldHJpZXMsIHlldCwgYW5kXG4gIC8vIC0gdGhpcyBlcnJvciB3YXMgY2F1c2VkIGJ5IGEgcmVxdWVzdCBvciBpdCdzIHJlc3BvbnNlIGFuZFxuICAvLyAtIHRoZSBlcnJvciBpcyBzZXJ2ZXIgZXJyb3IgKGkuZS4gbm90IGEgc3RhdHVzIDR4eCBleGNlcHQgYSA0MDkgb3IgNDIzKSBvclxuICAvLyBhIG9uU2hvdWxkUmV0cnkgaXMgc3BlY2lmaWVkIGFuZCByZXR1cm5zIHRydWVcbiAgLy8gLSB0aGUgYnJvd3NlciBkb2VzIG5vdCBpbmRpY2F0ZSB0aGF0IHdlIGFyZSBvZmZsaW5lXG4gIGlmIChvcHRpb25zLnJldHJ5RGVsYXlzID09IG51bGwgfHwgcmV0cnlBdHRlbXB0ID49IG9wdGlvbnMucmV0cnlEZWxheXMubGVuZ3RoIHx8IGVyci5vcmlnaW5hbFJlcXVlc3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm9uU2hvdWxkUmV0cnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5vblNob3VsZFJldHJ5KGVyciwgcmV0cnlBdHRlbXB0LCBvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBzdGF0dXMgPSBlcnIub3JpZ2luYWxSZXNwb25zZSA/IGVyci5vcmlnaW5hbFJlc3BvbnNlLmdldFN0YXR1cygpIDogMDtcbiAgcmV0dXJuICghaW5TdGF0dXNDYXRlZ29yeShzdGF0dXMsIDQwMCkgfHwgc3RhdHVzID09PSA0MDkgfHwgc3RhdHVzID09PSA0MjMpICYmIGlzT25saW5lKCk7XG59XG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBsaW5rIGdpdmVuIHRoZSBvcmlnaW4gYXMgc291cmNlLiBGb3IgZXhhbXBsZSxcbiAqIGlmIGEgSFRUUCByZXF1ZXN0IHRvIGh0dHA6Ly9leGFtcGxlLmNvbS9maWxlcy8gcmV0dXJucyBhIExvY2F0aW9uXG4gKiBoZWFkZXIgd2l0aCB0aGUgdmFsdWUgL3VwbG9hZC9hYmMsIHRoZSByZXNvbHZlZCBVUkwgd2lsbCBiZTpcbiAqIGh0dHA6Ly9leGFtcGxlLmNvbS91cGxvYWQvYWJjXG4gKi9cblxuXG5mdW5jdGlvbiByZXNvbHZlVXJsKG9yaWdpbiwgbGluaykge1xuICByZXR1cm4gbmV3IF91cmxQYXJzZS5kZWZhdWx0KGxpbmssIG9yaWdpbikudG9TdHJpbmcoKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBmb3IgdGhlIHBhcnRzIGlmIGFuIHVwbG9hZFxuICogaXMgc3BsaXQgaW50byBtdWx0aXBsZSBwYXJhbGxlbCByZXF1ZXN0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdG90YWxTaXplIFRoZSBieXRlIHNpemUgb2YgdGhlIHVwbG9hZCwgd2hpY2ggd2lsbCBiZSBzcGxpdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBwYXJ0Q291bnQgVGhlIG51bWJlciBpbiBob3cgbWFueSBwYXJ0cyB0aGUgdXBsb2FkIHdpbGwgYmUgc3BsaXQuXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBwcmV2aW91c1VybHMgVGhlIHVwbG9hZCBVUkxzIGZvciBwcmV2aW91cyBwYXJ0cy5cbiAqIEByZXR1cm4ge29iamVjdFtdfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuXG5mdW5jdGlvbiBzcGxpdFNpemVJbnRvUGFydHModG90YWxTaXplLCBwYXJ0Q291bnQsIHByZXZpb3VzVXJscykge1xuICB2YXIgcGFydFNpemUgPSBNYXRoLmZsb29yKHRvdGFsU2l6ZSAvIHBhcnRDb3VudCk7XG4gIHZhciBwYXJ0cyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFydENvdW50OyBpKyspIHtcbiAgICBwYXJ0cy5wdXNoKHtcbiAgICAgIHN0YXJ0OiBwYXJ0U2l6ZSAqIGksXG4gICAgICBlbmQ6IHBhcnRTaXplICogKGkgKyAxKVxuICAgIH0pO1xuICB9XG5cbiAgcGFydHNbcGFydENvdW50IC0gMV0uZW5kID0gdG90YWxTaXplOyAvLyBBdHRhY2ggVVJMcyBmcm9tIHByZXZpb3VzIHVwbG9hZHMsIGlmIGF2YWlsYWJsZS5cblxuICBpZiAocHJldmlvdXNVcmxzKSB7XG4gICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbiAocGFydCwgaW5kZXgpIHtcbiAgICAgIHBhcnQudXBsb2FkVXJsID0gcHJldmlvdXNVcmxzW2luZGV4XSB8fCBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5CYXNlVXBsb2FkLmRlZmF1bHRPcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG52YXIgX2RlZmF1bHQgPSBCYXNlVXBsb2FkO1xuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmRlZmF1bHQgPSB1dWlkO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgVVVJRCB2NCBiYXNlZCBvbiByYW5kb20gbnVtYmVycy4gV2UgaW50ZW50aW9hbmxseSB1c2UgdGhlIGxlc3NcbiAqIHNlY3VyZSBNYXRoLnJhbmRvbSBmdW5jdGlvbiBoZXJlIHNpbmNlIHRoZSBtb3JlIHNlY3VyZSBjcnlwdG8uZ2V0UmFuZG9tTnVtYmVyc1xuICogaXMgbm90IGF2YWlsYWJsZSBvbiBhbGwgcGxhdGZvcm1zLlxuICogVGhpcyBpcyBub3QgYSBwcm9ibGVtIGZvciB1cyBzaW5jZSB3ZSB1c2UgdGhlIFVVSUQgb25seSBmb3IgZ2VuZXJhdGluZyBhXG4gKiByZXF1ZXN0IElELCBzbyB3ZSBjYW4gY29ycmVsYXRlIHNlcnZlciBsb2dzIHRvIGNsaWVudCBlcnJvcnMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyB0YWtlbiBmcm9tIGZvbGxvd2luZyBzaXRlOlxuICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2NyZWF0ZS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdFxuICpcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGdlbmVyYXRlIFVVSURcbiAqL1xuZnVuY3Rpb24gdXVpZCgpIHtcbiAgLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbiAoYykge1xuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcbiAgICB2YXIgdiA9IGMgPT09ICd4JyA/IHIgOiByICYgMHgzIHwgMHg4O1xuICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgfSk7XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIGJ1aWxkRnVsbFBhdGggPSByZXF1aXJlKCcuLi9jb3JlL2J1aWxkRnVsbFBhdGgnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsJyk7XG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xudmFyIHBhcnNlUHJvdG9jb2wgPSByZXF1aXJlKCcuLi9oZWxwZXJzL3BhcnNlUHJvdG9jb2wnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgIHZhciBvbkNhbmNlbGVkO1xuICAgIGZ1bmN0aW9uIGRvbmUoKSB7XG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi51bnN1YnNjcmliZShvbkNhbmNlbGVkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcbiAgICAgICAgY29uZmlnLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIG9uQ2FuY2VsZWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSAmJiB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGZ1bGxQYXRoLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKGZ1bmN0aW9uIF9yZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICBkb25lKCk7XG4gICAgICB9LCBmdW5jdGlvbiBfcmVqZWN0KGVycikge1xuICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgfSwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoJ29ubG9hZGVuZCcgaW4gcmVxdWVzdCkge1xuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcbiAgICAgIHJlcXVlc3Qub25sb2FkZW5kID0gb25sb2FkZW5kO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXG4gICAgICByZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCB8fCByZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVhZHlzdGF0ZSBoYW5kbGVyIGlzIGNhbGxpbmcgYmVmb3JlIG9uZXJyb3Igb3Igb250aW1lb3V0IGhhbmRsZXJzLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgY2FsbCBvbmxvYWRlbmQgb24gdGhlIG5leHQgJ3RpY2snXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJyb3dzZXIgcmVxdWVzdCBjYW5jZWxsYXRpb24gKGFzIG9wcG9zZWQgdG8gYSBtYW51YWwgY2FuY2VsbGF0aW9uKVxuICAgIHJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uIGhhbmRsZUFib3J0KCkge1xuICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdSZXF1ZXN0IGFib3J0ZWQnLCBBeGlvc0Vycm9yLkVDT05OQUJPUlRFRCwgY29uZmlnLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKCdOZXR3b3JrIEVycm9yJywgQXhpb3NFcnJvci5FUlJfTkVUV09SSywgY29uZmlnLCByZXF1ZXN0LCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHZhciB0aW1lb3V0RXJyb3JNZXNzYWdlID0gY29uZmlnLnRpbWVvdXQgPyAndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnIDogJ3RpbWVvdXQgZXhjZWVkZWQnO1xuICAgICAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWwgfHwgdHJhbnNpdGlvbmFsRGVmYXVsdHM7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KG5ldyBBeGlvc0Vycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICB0cmFuc2l0aW9uYWwuY2xhcmlmeVRpbWVvdXRFcnJvciA/IEF4aW9zRXJyb3IuRVRJTUVET1VUIDogQXhpb3NFcnJvci5FQ09OTkFCT1JURUQsXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG4gICAgICBvbkNhbmNlbGVkID0gZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWplY3QoIWNhbmNlbCB8fCAoY2FuY2VsICYmIGNhbmNlbC50eXBlKSA/IG5ldyBDYW5jZWxlZEVycm9yKCkgOiBjYW5jZWwpO1xuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfTtcblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XG4gICAgICBpZiAoY29uZmlnLnNpZ25hbCkge1xuICAgICAgICBjb25maWcuc2lnbmFsLmFib3J0ZWQgPyBvbkNhbmNlbGVkKCkgOiBjb25maWcuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBwcm90b2NvbCA9IHBhcnNlUHJvdG9jb2woZnVsbFBhdGgpO1xuXG4gICAgaWYgKHByb3RvY29sICYmIFsgJ2h0dHAnLCAnaHR0cHMnLCAnZmlsZScgXS5pbmRleE9mKHByb3RvY29sKSA9PT0gLTEpIHtcbiAgICAgIHJlamVjdChuZXcgQXhpb3NFcnJvcignVW5zdXBwb3J0ZWQgcHJvdG9jb2wgJyArIHByb3RvY29sICsgJzonLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVRVUVTVCwgY29uZmlnKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgQXhpb3MgPSByZXF1aXJlKCcuL2NvcmUvQXhpb3MnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vY29yZS9tZXJnZUNvbmZpZycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbiAgaW5zdGFuY2UuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGRlZmF1bHRDb25maWcsIGluc3RhbmNlQ29uZmlnKSk7XG4gIH07XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxlZEVycm9yJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5heGlvcy5WRVJTSU9OID0gcmVxdWlyZSgnLi9lbnYvZGF0YScpLnZlcnNpb247XG5heGlvcy50b0Zvcm1EYXRhID0gcmVxdWlyZSgnLi9oZWxwZXJzL3RvRm9ybURhdGEnKTtcblxuLy8gRXhwb3NlIEF4aW9zRXJyb3IgY2xhc3NcbmF4aW9zLkF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9saWIvY29yZS9BeGlvc0Vycm9yJyk7XG5cbi8vIGFsaWFzIGZvciBDYW5jZWxlZEVycm9yIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5heGlvcy5DYW5jZWwgPSBheGlvcy5DYW5jZWxlZEVycm9yO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FuY2VsZWRFcnJvciA9IHJlcXVpcmUoJy4vQ2FuY2VsZWRFcnJvcicpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG5cbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4oZnVuY3Rpb24oY2FuY2VsKSB7XG4gICAgaWYgKCF0b2tlbi5fbGlzdGVuZXJzKSByZXR1cm47XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbCA9IHRva2VuLl9saXN0ZW5lcnMubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdG9rZW4uX2xpc3RlbmVyc1tpXShjYW5jZWwpO1xuICAgIH1cbiAgICB0b2tlbi5fbGlzdGVuZXJzID0gbnVsbDtcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgdGhpcy5wcm9taXNlLnRoZW4gPSBmdW5jdGlvbihvbmZ1bGZpbGxlZCkge1xuICAgIHZhciBfcmVzb2x2ZTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xuICAgICAgX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgIH0pLnRoZW4ob25mdWxmaWxsZWQpO1xuXG4gICAgcHJvbWlzZS5jYW5jZWwgPSBmdW5jdGlvbiByZWplY3QoKSB7XG4gICAgICB0b2tlbi51bnN1YnNjcmliZShfcmVzb2x2ZSk7XG4gICAgfTtcblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbGVkRXJyb3IobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGVkRXJyb3JgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXG4gKi9cbkNhbmNlbFRva2VuLnByb3RvdHlwZS50aHJvd0lmUmVxdWVzdGVkID0gZnVuY3Rpb24gdGhyb3dJZlJlcXVlc3RlZCgpIHtcbiAgaWYgKHRoaXMucmVhc29uKSB7XG4gICAgdGhyb3cgdGhpcy5yZWFzb247XG4gIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXG4gKi9cblxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICBsaXN0ZW5lcih0aGlzLnJlYXNvbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xuICAgIHRoaXMuX2xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIFVuc3Vic2NyaWJlIGZyb20gdGhlIGNhbmNlbCBzaWduYWxcbiAqL1xuXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiB1bnN1YnNjcmliZShsaXN0ZW5lcikge1xuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICB0aGlzLl9saXN0ZW5lcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBBIGBDYW5jZWxlZEVycm9yYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbGVkRXJyb3IobWVzc2FnZSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXEtbnVsbCxlcWVxZXFcbiAgQXhpb3NFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UgPT0gbnVsbCA/ICdjYW5jZWxlZCcgOiBtZXNzYWdlLCBBeGlvc0Vycm9yLkVSUl9DQU5DRUxFRCk7XG4gIHRoaXMubmFtZSA9ICdDYW5jZWxlZEVycm9yJztcbn1cblxudXRpbHMuaW5oZXJpdHMoQ2FuY2VsZWRFcnJvciwgQXhpb3NFcnJvciwge1xuICBfX0NBTkNFTF9fOiB0cnVlXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWxlZEVycm9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4vYnVpbGRGdWxsUGF0aCcpO1xudmFyIHZhbGlkYXRvciA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvdmFsaWRhdG9yJyk7XG5cbnZhciB2YWxpZGF0b3JzID0gdmFsaWRhdG9yLnZhbGlkYXRvcnM7XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWdPclVybCwgY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnT3JVcmwgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuICAgIGNvbmZpZy51cmwgPSBjb25maWdPclVybDtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgdmFyIHRyYW5zaXRpb25hbCA9IGNvbmZpZy50cmFuc2l0aW9uYWw7XG5cbiAgaWYgKHRyYW5zaXRpb25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsaWRhdG9yLmFzc2VydE9wdGlvbnModHJhbnNpdGlvbmFsLCB7XG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcbiAgICAgIGZvcmNlZEpTT05QYXJzaW5nOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pLFxuICAgICAgY2xhcmlmeVRpbWVvdXRFcnJvcjogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKVxuICAgIH0sIGZhbHNlKTtcbiAgfVxuXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcbiAgdmFyIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHZhciBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSB0cnVlO1xuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBpZiAodHlwZW9mIGludGVyY2VwdG9yLnJ1bldoZW4gPT09ICdmdW5jdGlvbicgJiYgaW50ZXJjZXB0b3IucnVuV2hlbihjb25maWcpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyAmJiBpbnRlcmNlcHRvci5zeW5jaHJvbm91cztcblxuICAgIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4gPSBbXTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdmFyIHByb21pc2U7XG5cbiAgaWYgKCFzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMpIHtcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuXG4gICAgQXJyYXkucHJvdG90eXBlLnVuc2hpZnQuYXBwbHkoY2hhaW4sIHJlcXVlc3RJbnRlcmNlcHRvckNoYWluKTtcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xuXG4gICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cblxuXG4gIHZhciBuZXdDb25maWcgPSBjb25maWc7XG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICB2YXIgb25GdWxmaWxsZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xuICAgIHZhciBvblJlamVjdGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB0cnkge1xuICAgICAgbmV3Q29uZmlnID0gb25GdWxmaWxsZWQobmV3Q29uZmlnKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgb25SZWplY3RlZChlcnJvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0cnkge1xuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICB9XG5cbiAgd2hpbGUgKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICByZXR1cm4gYnVpbGRVUkwoZnVsbFBhdGgsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IChjb25maWcgfHwge30pLmRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUhUVFBNZXRob2QoaXNGb3JtKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGh0dHBNZXRob2QodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XG4gICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICBoZWFkZXJzOiBpc0Zvcm0gPyB7XG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdtdWx0aXBhcnQvZm9ybS1kYXRhJ1xuICAgICAgICB9IDoge30sXG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KSk7XG4gICAgfTtcbiAgfVxuXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZ2VuZXJhdGVIVFRQTWV0aG9kKCk7XG5cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZCArICdGb3JtJ10gPSBnZW5lcmF0ZUhUVFBNZXRob2QodHJ1ZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xuZnVuY3Rpb24gQXhpb3NFcnJvcihtZXNzYWdlLCBjb2RlLCBjb25maWcsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIEVycm9yLmNhbGwodGhpcyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIHRoaXMubmFtZSA9ICdBeGlvc0Vycm9yJztcbiAgY29kZSAmJiAodGhpcy5jb2RlID0gY29kZSk7XG4gIGNvbmZpZyAmJiAodGhpcy5jb25maWcgPSBjb25maWcpO1xuICByZXF1ZXN0ICYmICh0aGlzLnJlcXVlc3QgPSByZXF1ZXN0KTtcbiAgcmVzcG9uc2UgJiYgKHRoaXMucmVzcG9uc2UgPSByZXNwb25zZSk7XG59XG5cbnV0aWxzLmluaGVyaXRzKEF4aW9zRXJyb3IsIEVycm9yLCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvLyBTdGFuZGFyZFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgLy8gTWljcm9zb2Z0XG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvbixcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXG4gICAgICAvLyBNb3ppbGxhXG4gICAgICBmaWxlTmFtZTogdGhpcy5maWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcbiAgICAgIGNvbHVtbk51bWJlcjogdGhpcy5jb2x1bW5OdW1iZXIsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIC8vIEF4aW9zXG4gICAgICBjb25maWc6IHRoaXMuY29uZmlnLFxuICAgICAgY29kZTogdGhpcy5jb2RlLFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXG4gICAgfTtcbiAgfVxufSk7XG5cbnZhciBwcm90b3R5cGUgPSBBeGlvc0Vycm9yLnByb3RvdHlwZTtcbnZhciBkZXNjcmlwdG9ycyA9IHt9O1xuXG5bXG4gICdFUlJfQkFEX09QVElPTl9WQUxVRScsXG4gICdFUlJfQkFEX09QVElPTicsXG4gICdFQ09OTkFCT1JURUQnLFxuICAnRVRJTUVET1VUJyxcbiAgJ0VSUl9ORVRXT1JLJyxcbiAgJ0VSUl9GUl9UT09fTUFOWV9SRURJUkVDVFMnLFxuICAnRVJSX0RFUFJFQ0FURUQnLFxuICAnRVJSX0JBRF9SRVNQT05TRScsXG4gICdFUlJfQkFEX1JFUVVFU1QnLFxuICAnRVJSX0NBTkNFTEVEJ1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbl0uZm9yRWFjaChmdW5jdGlvbihjb2RlKSB7XG4gIGRlc2NyaXB0b3JzW2NvZGVdID0ge3ZhbHVlOiBjb2RlfTtcbn0pO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBeGlvc0Vycm9yLCBkZXNjcmlwdG9ycyk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCAnaXNBeGlvc0Vycm9yJywge3ZhbHVlOiB0cnVlfSk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5BeGlvc0Vycm9yLmZyb20gPSBmdW5jdGlvbihlcnJvciwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSwgY3VzdG9tUHJvcHMpIHtcbiAgdmFyIGF4aW9zRXJyb3IgPSBPYmplY3QuY3JlYXRlKHByb3RvdHlwZSk7XG5cbiAgdXRpbHMudG9GbGF0T2JqZWN0KGVycm9yLCBheGlvc0Vycm9yLCBmdW5jdGlvbiBmaWx0ZXIob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAhPT0gRXJyb3IucHJvdG90eXBlO1xuICB9KTtcblxuICBBeGlvc0Vycm9yLmNhbGwoYXhpb3NFcnJvciwgZXJyb3IubWVzc2FnZSwgY29kZSwgY29uZmlnLCByZXF1ZXN0LCByZXNwb25zZSk7XG5cbiAgYXhpb3NFcnJvci5uYW1lID0gZXJyb3IubmFtZTtcblxuICBjdXN0b21Qcm9wcyAmJiBPYmplY3QuYXNzaWduKGF4aW9zRXJyb3IsIGN1c3RvbVByb3BzKTtcblxuICByZXR1cm4gYXhpb3NFcnJvcjtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3NFcnJvcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIENhbmNlbGVkRXJyb3IgPSByZXF1aXJlKCcuLi9jYW5jZWwvQ2FuY2VsZWRFcnJvcicpO1xuXG4vKipcbiAqIFRocm93cyBhIGBDYW5jZWxlZEVycm9yYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxuXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xuICAgIHRocm93IG5ldyBDYW5jZWxlZEVycm9yKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgIGNvbmZpZyxcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgY29uZmlnLFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEuY2FsbChcbiAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBDb25maWctc3BlY2lmaWMgbWVyZ2UtZnVuY3Rpb24gd2hpY2ggY3JlYXRlcyBhIG5ldyBjb25maWctb2JqZWN0XG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzFcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBOZXcgb2JqZWN0IHJlc3VsdGluZyBmcm9tIG1lcmdpbmcgY29uZmlnMiB0byBjb25maWcxXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgY29uZmlnMiA9IGNvbmZpZzIgfHwge307XG4gIHZhciBjb25maWcgPSB7fTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURlZXBQcm9wZXJ0aWVzKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUoY29uZmlnMVtwcm9wXSwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiB2YWx1ZUZyb21Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcbiAgICB9XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcyW3Byb3BdKSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMocHJvcCkge1xuICAgIGlmIChwcm9wIGluIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMVtwcm9wXSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lcmdlTWFwID0ge1xuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdtZXRob2QnOiB2YWx1ZUZyb21Db25maWcyLFxuICAgICdkYXRhJzogdmFsdWVGcm9tQ29uZmlnMixcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zZm9ybVJlcXVlc3QnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0cmFuc2Zvcm1SZXNwb25zZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd0aW1lb3V0JzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndGltZW91dE1lc3NhZ2UnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdhZGFwdGVyJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAncmVzcG9uc2VUeXBlJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICd4c3JmSGVhZGVyTmFtZSc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ29uVXBsb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdkZWNvbXByZXNzJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAnbWF4Q29udGVudExlbmd0aCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdiZWZvcmVSZWRpcmVjdCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3RyYW5zcG9ydCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ2h0dHBzQWdlbnQnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdjYW5jZWxUb2tlbic6IGRlZmF1bHRUb0NvbmZpZzIsXG4gICAgJ3NvY2tldFBhdGgnOiBkZWZhdWx0VG9Db25maWcyLFxuICAgICdyZXNwb25zZUVuY29kaW5nJzogZGVmYXVsdFRvQ29uZmlnMixcbiAgICAndmFsaWRhdGVTdGF0dXMnOiBtZXJnZURpcmVjdEtleXNcbiAgfTtcblxuICB1dGlscy5mb3JFYWNoKE9iamVjdC5rZXlzKGNvbmZpZzEpLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSksIGZ1bmN0aW9uIGNvbXB1dGVDb25maWdWYWx1ZShwcm9wKSB7XG4gICAgdmFyIG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcbiAgICB2YXIgY29uZmlnVmFsdWUgPSBtZXJnZShwcm9wKTtcbiAgICAodXRpbHMuaXNVbmRlZmluZWQoY29uZmlnVmFsdWUpICYmIG1lcmdlICE9PSBtZXJnZURpcmVjdEtleXMpIHx8IChjb25maWdbcHJvcF0gPSBjb25maWdWYWx1ZSk7XG4gIH0pO1xuXG4gIHJldHVybiBjb25maWc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4vQXhpb3NFcnJvcicpO1xuXG4vKipcbiAqIFJlc29sdmUgb3IgcmVqZWN0IGEgUHJvbWlzZSBiYXNlZCBvbiByZXNwb25zZSBzdGF0dXMuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZSBBIGZ1bmN0aW9uIHRoYXQgcmVzb2x2ZXMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3QgQSBmdW5jdGlvbiB0aGF0IHJlamVjdHMgdGhlIHByb21pc2UuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKSB7XG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QobmV3IEF4aW9zRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgW0F4aW9zRXJyb3IuRVJSX0JBRF9SRVFVRVNULCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0VdW01hdGguZmxvb3IocmVzcG9uc2Uuc3RhdHVzIC8gMTAwKSAtIDRdLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICB2YXIgY29udGV4dCA9IHRoaXMgfHwgZGVmYXVsdHM7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuLmNhbGwoY29udGV4dCwgZGF0YSwgaGVhZGVycyk7XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG52YXIgQXhpb3NFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvQXhpb3NFcnJvcicpO1xudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gcmVxdWlyZSgnLi90cmFuc2l0aW9uYWwnKTtcbnZhciB0b0Zvcm1EYXRhID0gcmVxdWlyZSgnLi4vaGVscGVycy90b0Zvcm1EYXRhJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4uL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xuICBpZiAodXRpbHMuaXNTdHJpbmcocmF3VmFsdWUpKSB7XG4gICAgdHJ5IHtcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xuICAgICAgcmV0dXJuIHV0aWxzLnRyaW0ocmF3VmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuXG4gIHRyYW5zaXRpb25hbDogdHJhbnNpdGlvbmFsRGVmYXVsdHMsXG5cbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQWNjZXB0Jyk7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgdmFyIGlzT2JqZWN0UGF5bG9hZCA9IHV0aWxzLmlzT2JqZWN0KGRhdGEpO1xuICAgIHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ107XG5cbiAgICB2YXIgaXNGaWxlTGlzdDtcblxuICAgIGlmICgoaXNGaWxlTGlzdCA9IHV0aWxzLmlzRmlsZUxpc3QoZGF0YSkpIHx8IChpc09iamVjdFBheWxvYWQgJiYgY29udGVudFR5cGUgPT09ICdtdWx0aXBhcnQvZm9ybS1kYXRhJykpIHtcbiAgICAgIHZhciBfRm9ybURhdGEgPSB0aGlzLmVudiAmJiB0aGlzLmVudi5Gb3JtRGF0YTtcbiAgICAgIHJldHVybiB0b0Zvcm1EYXRhKGlzRmlsZUxpc3QgPyB7J2ZpbGVzW10nOiBkYXRhfSA6IGRhdGEsIF9Gb3JtRGF0YSAmJiBuZXcgX0Zvcm1EYXRhKCkpO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3RQYXlsb2FkIHx8IGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgdmFyIHRyYW5zaXRpb25hbCA9IHRoaXMudHJhbnNpdGlvbmFsIHx8IGRlZmF1bHRzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IEF4aW9zRXJyb3IuZnJvbShlLCBBeGlvc0Vycm9yLkVSUl9CQURfUkVTUE9OU0UsIHRoaXMsIG51bGwsIHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIC8qKlxuICAgKiBBIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIHRvIGFib3J0IGEgcmVxdWVzdC4gSWYgc2V0IHRvIDAgKGRlZmF1bHQpIGFcbiAgICogdGltZW91dCBpcyBub3QgY3JlYXRlZC5cbiAgICovXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuICBtYXhCb2R5TGVuZ3RoOiAtMSxcblxuICBlbnY6IHtcbiAgICBGb3JtRGF0YTogcmVxdWlyZSgnLi9lbnYvRm9ybURhdGEnKVxuICB9LFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH0sXG5cbiAgaGVhZGVyczoge1xuICAgIGNvbW1vbjoge1xuICAgICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gICAgfVxuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2lsZW50SlNPTlBhcnNpbmc6IHRydWUsXG4gIGZvcmNlZEpTT05QYXJzaW5nOiB0cnVlLFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcInZlcnNpb25cIjogXCIwLjI3LjJcIlxufTsiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHZhbCkuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZCtcXC0uXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gdXRpbHMuaXNPYmplY3QocGF5bG9hZCkgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHN0cmljdFxubW9kdWxlLmV4cG9ydHMgPSBudWxsO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZVByb3RvY29sKHVybCkge1xuICB2YXIgbWF0Y2ggPSAvXihbLStcXHddezEsMjV9KSg6P1xcL1xcL3w6KS8uZXhlYyh1cmwpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbnZlcnQgYSBkYXRhIG9iamVjdCB0byBGb3JtRGF0YVxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHBhcmFtIHs/T2JqZWN0fSBbZm9ybURhdGFdXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICoqL1xuXG5mdW5jdGlvbiB0b0Zvcm1EYXRhKG9iaiwgZm9ybURhdGEpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGZvcm1EYXRhID0gZm9ybURhdGEgfHwgbmV3IEZvcm1EYXRhKCk7XG5cbiAgdmFyIHN0YWNrID0gW107XG5cbiAgZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICBpZiAodXRpbHMuaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXIodmFsdWUpIHx8IHV0aWxzLmlzVHlwZWRBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgQmxvYiA9PT0gJ2Z1bmN0aW9uJyA/IG5ldyBCbG9iKFt2YWx1ZV0pIDogQnVmZmVyLmZyb20odmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkKGRhdGEsIHBhcmVudEtleSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KGRhdGEpIHx8IHV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgIGlmIChzdGFjay5pbmRleE9mKGRhdGEpICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBFcnJvcignQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkIGluICcgKyBwYXJlbnRLZXkpO1xuICAgICAgfVxuXG4gICAgICBzdGFjay5wdXNoKGRhdGEpO1xuXG4gICAgICB1dGlscy5mb3JFYWNoKGRhdGEsIGZ1bmN0aW9uIGVhY2godmFsdWUsIGtleSkge1xuICAgICAgICBpZiAodXRpbHMuaXNVbmRlZmluZWQodmFsdWUpKSByZXR1cm47XG4gICAgICAgIHZhciBmdWxsS2V5ID0gcGFyZW50S2V5ID8gcGFyZW50S2V5ICsgJy4nICsga2V5IDoga2V5O1xuICAgICAgICB2YXIgYXJyO1xuXG4gICAgICAgIGlmICh2YWx1ZSAmJiAhcGFyZW50S2V5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBpZiAodXRpbHMuZW5kc1dpdGgoa2V5LCAne30nKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmVuZHNXaXRoKGtleSwgJ1tdJykgJiYgKGFyciA9IHV0aWxzLnRvQXJyYXkodmFsdWUpKSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgICAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICF1dGlscy5pc1VuZGVmaW5lZChlbCkgJiYgZm9ybURhdGEuYXBwZW5kKGZ1bGxLZXksIGNvbnZlcnRWYWx1ZShlbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnVpbGQodmFsdWUsIGZ1bGxLZXkpO1xuICAgICAgfSk7XG5cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3JtRGF0YS5hcHBlbmQocGFyZW50S2V5LCBjb252ZXJ0VmFsdWUoZGF0YSkpO1xuICAgIH1cbiAgfVxuXG4gIGJ1aWxkKG9iaik7XG5cbiAgcmV0dXJuIGZvcm1EYXRhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvRm9ybURhdGE7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBWRVJTSU9OID0gcmVxdWlyZSgnLi4vZW52L2RhdGEnKS52ZXJzaW9uO1xudmFyIEF4aW9zRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL0F4aW9zRXJyb3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB7fTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblsnb2JqZWN0JywgJ2Jvb2xlYW4nLCAnbnVtYmVyJywgJ2Z1bmN0aW9uJywgJ3N0cmluZycsICdzeW1ib2wnXS5mb3JFYWNoKGZ1bmN0aW9uKHR5cGUsIGkpIHtcbiAgdmFsaWRhdG9yc1t0eXBlXSA9IGZ1bmN0aW9uIHZhbGlkYXRvcih0aGluZykge1xuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xuICB9O1xufSk7XG5cbnZhciBkZXByZWNhdGVkV2FybmluZ3MgPSB7fTtcblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yIC0gc2V0IHRvIGZhbHNlIGlmIHRoZSB0cmFuc2l0aW9uYWwgb3B0aW9uIGhhcyBiZWVuIHJlbW92ZWRcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSBtZXNzYWdlIC0gc29tZSBtZXNzYWdlIHdpdGggYWRkaXRpb25hbCBpbmZvXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFwnJyArIG9wdCArICdcXCcnICsgZGVzYyArIChtZXNzYWdlID8gJy4gJyArIG1lc3NhZ2UgOiAnJyk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIG9wdCwgb3B0cykge1xuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XG4gICAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShvcHQsICcgaGFzIGJlZW4gcmVtb3ZlZCcgKyAodmVyc2lvbiA/ICcgaW4gJyArIHZlcnNpb24gOiAnJykpLFxuICAgICAgICBBeGlvc0Vycm9yLkVSUl9ERVBSRUNBVEVEXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh2ZXJzaW9uICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgQXhpb3NFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICB9XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgdmFyIG9wdCA9IGtleXNbaV07XG4gICAgdmFyIHZhbGlkYXRvciA9IHNjaGVtYVtvcHRdO1xuICAgIGlmICh2YWxpZGF0b3IpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcbiAgICAgIHZhciByZXN1bHQgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRpb25zKTtcbiAgICAgIGlmIChyZXN1bHQgIT09IHRydWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF4aW9zRXJyb3IoJ29wdGlvbiAnICsgb3B0ICsgJyBtdXN0IGJlICcgKyByZXN1bHQsIEF4aW9zRXJyb3IuRVJSX0JBRF9PUFRJT05fVkFMVUUpO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBBeGlvc0Vycm9yKCdVbmtub3duIG9wdGlvbiAnICsgb3B0LCBBeGlvc0Vycm9yLkVSUl9CQURfT1BUSU9OKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbnZhciBraW5kT2YgPSAoZnVuY3Rpb24oY2FjaGUpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgdmFyIHN0ciA9IHRvU3RyaW5nLmNhbGwodGhpbmcpO1xuICAgIHJldHVybiBjYWNoZVtzdHJdIHx8IChjYWNoZVtzdHJdID0gc3RyLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpKTtcbiAgfTtcbn0pKE9iamVjdC5jcmVhdGUobnVsbCkpO1xuXG5mdW5jdGlvbiBraW5kT2ZUZXN0KHR5cGUpIHtcbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIGlzS2luZE9mKHRoaW5nKSB7XG4gICAgcmV0dXJuIGtpbmRPZih0aGluZykgPT09IHR5cGU7XG4gIH07XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmZmVyKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwpICYmIHZhbC5jb25zdHJ1Y3RvciAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsLmNvbnN0cnVjdG9yKVxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzQXJyYXlCdWZmZXIgPSBraW5kT2ZUZXN0KCdBcnJheUJ1ZmZlcicpO1xuXG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWwpIHtcbiAgaWYgKGtpbmRPZih2YWwpICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG52YXIgaXNEYXRlID0ga2luZE9mVGVzdCgnRGF0ZScpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRmlsZSA9IGtpbmRPZlRlc3QoJ0ZpbGUnKTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc0Jsb2IgPSBraW5kT2ZUZXN0KCdCbG9iJyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlTGlzdFxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xudmFyIGlzRmlsZUxpc3QgPSBraW5kT2ZUZXN0KCdGaWxlTGlzdCcpO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpbmcgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh0aGluZykge1xuICB2YXIgcGF0dGVybiA9ICdbb2JqZWN0IEZvcm1EYXRhXSc7XG4gIHJldHVybiB0aGluZyAmJiAoXG4gICAgKHR5cGVvZiBGb3JtRGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiB0aGluZyBpbnN0YW5jZW9mIEZvcm1EYXRhKSB8fFxuICAgIHRvU3RyaW5nLmNhbGwodGhpbmcpID09PSBwYXR0ZXJuIHx8XG4gICAgKGlzRnVuY3Rpb24odGhpbmcudG9TdHJpbmcpICYmIHRoaW5nLnRvU3RyaW5nKCkgPT09IHBhdHRlcm4pXG4gICk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbnZhciBpc1VSTFNlYXJjaFBhcmFtcyA9IGtpbmRPZlRlc3QoJ1VSTFNlYXJjaFBhcmFtcycpO1xuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqIG5hdGl2ZXNjcmlwdFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05hdGl2ZVNjcmlwdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ05TJykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChyZXN1bHRba2V5XSkgJiYgaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHt9LCB2YWwpO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh2YWwpKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbi8qKlxuICogUmVtb3ZlIGJ5dGUgb3JkZXIgbWFya2VyLiBUaGlzIGNhdGNoZXMgRUYgQkIgQkYgKHRoZSBVVEYtOCBCT00pXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbnRlbnQgd2l0aCBCT01cbiAqIEByZXR1cm4ge3N0cmluZ30gY29udGVudCB2YWx1ZSB3aXRob3V0IEJPTVxuICovXG5mdW5jdGlvbiBzdHJpcEJPTShjb250ZW50KSB7XG4gIGlmIChjb250ZW50LmNoYXJDb2RlQXQoMCkgPT09IDB4RkVGRikge1xuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEluaGVyaXQgdGhlIHByb3RvdHlwZSBtZXRob2RzIGZyb20gb25lIGNvbnN0cnVjdG9yIGludG8gYW5vdGhlclxuICogQHBhcmFtIHtmdW5jdGlvbn0gY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvcHNdXG4gKiBAcGFyYW0ge29iamVjdH0gW2Rlc2NyaXB0b3JzXVxuICovXG5cbmZ1bmN0aW9uIGluaGVyaXRzKGNvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yLCBwcm9wcywgZGVzY3JpcHRvcnMpIHtcbiAgY29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNvbnN0cnVjdG9yLnByb3RvdHlwZSwgZGVzY3JpcHRvcnMpO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjb25zdHJ1Y3RvcjtcbiAgcHJvcHMgJiYgT2JqZWN0LmFzc2lnbihjb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIG9iamVjdCB3aXRoIGRlZXAgcHJvdG90eXBlIGNoYWluIHRvIGEgZmxhdCBvYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmogc291cmNlIG9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IFtkZXN0T2JqXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZpbHRlcl1cbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblxuZnVuY3Rpb24gdG9GbGF0T2JqZWN0KHNvdXJjZU9iaiwgZGVzdE9iaiwgZmlsdGVyKSB7XG4gIHZhciBwcm9wcztcbiAgdmFyIGk7XG4gIHZhciBwcm9wO1xuICB2YXIgbWVyZ2VkID0ge307XG5cbiAgZGVzdE9iaiA9IGRlc3RPYmogfHwge307XG5cbiAgZG8ge1xuICAgIHByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoc291cmNlT2JqKTtcbiAgICBpID0gcHJvcHMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0gPiAwKSB7XG4gICAgICBwcm9wID0gcHJvcHNbaV07XG4gICAgICBpZiAoIW1lcmdlZFtwcm9wXSkge1xuICAgICAgICBkZXN0T2JqW3Byb3BdID0gc291cmNlT2JqW3Byb3BdO1xuICAgICAgICBtZXJnZWRbcHJvcF0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBzb3VyY2VPYmogPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoc291cmNlT2JqKTtcbiAgfSB3aGlsZSAoc291cmNlT2JqICYmICghZmlsdGVyIHx8IGZpbHRlcihzb3VyY2VPYmosIGRlc3RPYmopKSAmJiBzb3VyY2VPYmogIT09IE9iamVjdC5wcm90b3R5cGUpO1xuXG4gIHJldHVybiBkZXN0T2JqO1xufVxuXG4vKlxuICogZGV0ZXJtaW5lcyB3aGV0aGVyIGEgc3RyaW5nIGVuZHMgd2l0aCB0aGUgY2hhcmFjdGVycyBvZiBhIHNwZWNpZmllZCBzdHJpbmdcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWFyY2hTdHJpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb249IDBdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZW5kc1dpdGgoc3RyLCBzZWFyY2hTdHJpbmcsIHBvc2l0aW9uKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA+IHN0ci5sZW5ndGgpIHtcbiAgICBwb3NpdGlvbiA9IHN0ci5sZW5ndGg7XG4gIH1cbiAgcG9zaXRpb24gLT0gc2VhcmNoU3RyaW5nLmxlbmd0aDtcbiAgdmFyIGxhc3RJbmRleCA9IHN0ci5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xufVxuXG5cbi8qKlxuICogUmV0dXJucyBuZXcgYXJyYXkgZnJvbSBhcnJheSBsaWtlIG9iamVjdFxuICogQHBhcmFtIHsqfSBbdGhpbmddXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkodGhpbmcpIHtcbiAgaWYgKCF0aGluZykgcmV0dXJuIG51bGw7XG4gIHZhciBpID0gdGhpbmcubGVuZ3RoO1xuICBpZiAoaXNVbmRlZmluZWQoaSkpIHJldHVybiBudWxsO1xuICB2YXIgYXJyID0gbmV3IEFycmF5KGkpO1xuICB3aGlsZSAoaS0tID4gMCkge1xuICAgIGFycltpXSA9IHRoaW5nW2ldO1xuICB9XG4gIHJldHVybiBhcnI7XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG52YXIgaXNUeXBlZEFycmF5ID0gKGZ1bmN0aW9uKFR5cGVkQXJyYXkpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgcmV0dXJuIFR5cGVkQXJyYXkgJiYgdGhpbmcgaW5zdGFuY2VvZiBUeXBlZEFycmF5O1xuICB9O1xufSkodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihVaW50OEFycmF5KSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT00sXG4gIGluaGVyaXRzOiBpbmhlcml0cyxcbiAgdG9GbGF0T2JqZWN0OiB0b0ZsYXRPYmplY3QsXG4gIGtpbmRPZjoga2luZE9mLFxuICBraW5kT2ZUZXN0OiBraW5kT2ZUZXN0LFxuICBlbmRzV2l0aDogZW5kc1dpdGgsXG4gIHRvQXJyYXk6IHRvQXJyYXksXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuICBpc0ZpbGVMaXN0OiBpc0ZpbGVMaXN0XG59O1xuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7IF9fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG5pZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgIT0gbnVsbCAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHZhciBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGhcbiAgICApXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8vXG4vLyBUSElTIEZJTEUgSVMgQVVUT01BVElDQUxMWSBHRU5FUkFURUQhIERPIE5PVCBFRElUIEJZIEhBTkQhXG4vL1xuO1xuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKVxuICAgICAgICA6IHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZFxuICAgICAgICAgICAgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzExOVxuICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBleGlzdGluZyB2ZXJzaW9uIGZvciBub0NvbmZsaWN0KClcbiAgICAgICAgICAgICAgICB2YXIgX0Jhc2U2NCA9IGdsb2JhbC5CYXNlNjQ7XG4gICAgICAgICAgICAgICAgdmFyIGdCYXNlNjQgPSBmYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgZ0Jhc2U2NC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBnbG9iYWwuQmFzZTY0ID0gX0Jhc2U2NDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdCYXNlNjQ7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsLk1ldGVvcikgeyAvLyBNZXRlb3IuanNcbiAgICAgICAgICAgICAgICAgICAgQmFzZTY0ID0gZ0Jhc2U2NDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2xvYmFsLkJhc2U2NCA9IGdCYXNlNjQ7XG4gICAgICAgICAgICB9KSgpO1xufSgodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnID8gc2VsZlxuICAgIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3dcbiAgICAgICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFxuICAgICAgICAgICAgOiB0aGlzKSwgZnVuY3Rpb24gKCkge1xuICAgICd1c2Ugc3RyaWN0JztcbiAgICAvKipcbiAgICAgKiAgYmFzZTY0LnRzXG4gICAgICpcbiAgICAgKiAgTGljZW5zZWQgdW5kZXIgdGhlIEJTRCAzLUNsYXVzZSBMaWNlbnNlLlxuICAgICAqICAgIGh0dHA6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9CU0QtMy1DbGF1c2VcbiAgICAgKlxuICAgICAqICBSZWZlcmVuY2VzOlxuICAgICAqICAgIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0XG4gICAgICpcbiAgICAgKiBAYXV0aG9yIERhbiBLb2dhaSAoaHR0cHM6Ly9naXRodWIuY29tL2RhbmtvZ2FpKVxuICAgICAqL1xuICAgIHZhciB2ZXJzaW9uID0gJzMuNy4yJztcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCB1c2UgbG93ZXJjYXNlIGB2ZXJzaW9uYC5cbiAgICAgKi9cbiAgICB2YXIgVkVSU0lPTiA9IHZlcnNpb247XG4gICAgdmFyIF9oYXNhdG9iID0gdHlwZW9mIGF0b2IgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIF9oYXNidG9hID0gdHlwZW9mIGJ0b2EgPT09ICdmdW5jdGlvbic7XG4gICAgdmFyIF9oYXNCdWZmZXIgPSB0eXBlb2YgQnVmZmVyID09PSAnZnVuY3Rpb24nO1xuICAgIHZhciBfVEQgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICdmdW5jdGlvbicgPyBuZXcgVGV4dERlY29kZXIoKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgX1RFID0gdHlwZW9mIFRleHRFbmNvZGVyID09PSAnZnVuY3Rpb24nID8gbmV3IFRleHRFbmNvZGVyKCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGI2NGNoID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcbiAgICB2YXIgYjY0Y2hzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYjY0Y2gpO1xuICAgIHZhciBiNjR0YWIgPSAoZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHRhYiA9IHt9O1xuICAgICAgICBhLmZvckVhY2goZnVuY3Rpb24gKGMsIGkpIHsgcmV0dXJuIHRhYltjXSA9IGk7IH0pO1xuICAgICAgICByZXR1cm4gdGFiO1xuICAgIH0pKGI2NGNocyk7XG4gICAgdmFyIGI2NHJlID0gL14oPzpbQS1aYS16XFxkK1xcL117NH0pKj8oPzpbQS1aYS16XFxkK1xcL117Mn0oPzo9PSk/fFtBLVphLXpcXGQrXFwvXXszfT0/KT8kLztcbiAgICB2YXIgX2Zyb21DQyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYmluZChTdHJpbmcpO1xuICAgIHZhciBfVThBZnJvbSA9IHR5cGVvZiBVaW50OEFycmF5LmZyb20gPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBVaW50OEFycmF5LmZyb20uYmluZChVaW50OEFycmF5KVxuICAgICAgICA6IGZ1bmN0aW9uIChpdCwgZm4pIHtcbiAgICAgICAgICAgIGlmIChmbiA9PT0gdm9pZCAwKSB7IGZuID0gZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHg7IH07IH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpdCwgMCkubWFwKGZuKSk7XG4gICAgICAgIH07XG4gICAgdmFyIF9ta1VyaVNhZmUgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBzcmNcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpLnJlcGxhY2UoL1srXFwvXS9nLCBmdW5jdGlvbiAobTApIHsgcmV0dXJuIG0wID09ICcrJyA/ICctJyA6ICdfJzsgfSk7IH07XG4gICAgdmFyIF90aWR5QjY0ID0gZnVuY3Rpb24gKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvW15BLVphLXowLTlcXCtcXC9dL2csICcnKTsgfTtcbiAgICAvKipcbiAgICAgKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBidG9hYFxuICAgICAqL1xuICAgIHZhciBidG9hUG9seWZpbGwgPSBmdW5jdGlvbiAoYmluKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgICAgIHZhciB1MzIsIGMwLCBjMSwgYzIsIGFzYyA9ICcnO1xuICAgICAgICB2YXIgcGFkID0gYmluLmxlbmd0aCAlIDM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluLmxlbmd0aDspIHtcbiAgICAgICAgICAgIGlmICgoYzAgPSBiaW4uY2hhckNvZGVBdChpKyspKSA+IDI1NSB8fFxuICAgICAgICAgICAgICAgIChjMSA9IGJpbi5jaGFyQ29kZUF0KGkrKykpID4gMjU1IHx8XG4gICAgICAgICAgICAgICAgKGMyID0gYmluLmNoYXJDb2RlQXQoaSsrKSkgPiAyNTUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjaGFyYWN0ZXIgZm91bmQnKTtcbiAgICAgICAgICAgIHUzMiA9IChjMCA8PCAxNikgfCAoYzEgPDwgOCkgfCBjMjtcbiAgICAgICAgICAgIGFzYyArPSBiNjRjaHNbdTMyID4+IDE4ICYgNjNdXG4gICAgICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDEyICYgNjNdXG4gICAgICAgICAgICAgICAgKyBiNjRjaHNbdTMyID4+IDYgJiA2M11cbiAgICAgICAgICAgICAgICArIGI2NGNoc1t1MzIgJiA2M107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhZCA/IGFzYy5zbGljZSgwLCBwYWQgLSAzKSArIFwiPT09XCIuc3Vic3RyaW5nKHBhZCkgOiBhc2M7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBkb2VzIHdoYXQgYHdpbmRvdy5idG9hYCBvZiB3ZWIgYnJvd3NlcnMgZG8uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGJpbiBiaW5hcnkgc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0LWVuY29kZWQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIF9idG9hID0gX2hhc2J0b2EgPyBmdW5jdGlvbiAoYmluKSB7IHJldHVybiBidG9hKGJpbik7IH1cbiAgICAgICAgOiBfaGFzQnVmZmVyID8gZnVuY3Rpb24gKGJpbikgeyByZXR1cm4gQnVmZmVyLmZyb20oYmluLCAnYmluYXJ5JykudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9XG4gICAgICAgICAgICA6IGJ0b2FQb2x5ZmlsbDtcbiAgICB2YXIgX2Zyb21VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uICh1OGEpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKHU4YSkudG9TdHJpbmcoJ2Jhc2U2NCcpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKHU4YSkge1xuICAgICAgICAgICAgLy8gY2YuIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEyNzEwMDAxL2hvdy10by1jb252ZXJ0LXVpbnQ4LWFycmF5LXRvLWJhc2U2NC1lbmNvZGVkLXN0cmluZy8xMjcxMzMyNiMxMjcxMzMyNlxuICAgICAgICAgICAgdmFyIG1heGFyZ3MgPSAweDEwMDA7XG4gICAgICAgICAgICB2YXIgc3RycyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSB1OGEubGVuZ3RoOyBpIDwgbDsgaSArPSBtYXhhcmdzKSB7XG4gICAgICAgICAgICAgICAgc3Rycy5wdXNoKF9mcm9tQ0MuYXBwbHkobnVsbCwgdThhLnN1YmFycmF5KGksIGkgKyBtYXhhcmdzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9idG9hKHN0cnMuam9pbignJykpO1xuICAgICAgICB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgVWludDhBcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbdXJsc2FmZV0gVVJMLWFuZC1maWxlbmFtZS1zYWZlIGEgbGEgUkZDNDY0OCDCpzVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGZyb21VaW50OEFycmF5ID0gZnVuY3Rpb24gKHU4YSwgdXJsc2FmZSkge1xuICAgICAgICBpZiAodXJsc2FmZSA9PT0gdm9pZCAwKSB7IHVybHNhZmUgPSBmYWxzZTsgfVxuICAgICAgICByZXR1cm4gdXJsc2FmZSA/IF9ta1VyaVNhZmUoX2Zyb21VaW50OEFycmF5KHU4YSkpIDogX2Zyb21VaW50OEFycmF5KHU4YSk7XG4gICAgfTtcbiAgICAvLyBUaGlzIHRyaWNrIGlzIGZvdW5kIGJyb2tlbiBodHRwczovL2dpdGh1Yi5jb20vZGFua29nYWkvanMtYmFzZTY0L2lzc3Vlcy8xMzBcbiAgICAvLyBjb25zdCB1dG9iID0gKHNyYzogc3RyaW5nKSA9PiB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3JjKSk7XG4gICAgLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuICAgIHZhciBjYl91dG9iID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgdmFyIGNjID0gYy5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgcmV0dXJuIGNjIDwgMHg4MCA/IGNcbiAgICAgICAgICAgICAgICA6IGNjIDwgMHg4MDAgPyAoX2Zyb21DQygweGMwIHwgKGNjID4+PiA2KSlcbiAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpXG4gICAgICAgICAgICAgICAgICAgIDogKF9mcm9tQ0MoMHhlMCB8ICgoY2MgPj4+IDEyKSAmIDB4MGYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoY2MgJiAweDNmKSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNjID0gMHgxMDAwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgwKSAtIDB4RDgwMCkgKiAweDQwMFxuICAgICAgICAgICAgICAgICsgKGMuY2hhckNvZGVBdCgxKSAtIDB4REMwMCk7XG4gICAgICAgICAgICByZXR1cm4gKF9mcm9tQ0MoMHhmMCB8ICgoY2MgPj4+IDE4KSAmIDB4MDcpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKChjYyA+Pj4gMTIpICYgMHgzZikpXG4gICAgICAgICAgICAgICAgKyBfZnJvbUNDKDB4ODAgfCAoKGNjID4+PiA2KSAmIDB4M2YpKVxuICAgICAgICAgICAgICAgICsgX2Zyb21DQygweDgwIHwgKGNjICYgMHgzZikpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHJlX3V0b2IgPSAvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGRl18W15cXHgwMC1cXHg3Rl0vZztcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTggc3RyaW5nXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVVRGLTE2IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciB1dG9iID0gZnVuY3Rpb24gKHUpIHsgcmV0dXJuIHUucmVwbGFjZShyZV91dG9iLCBjYl91dG9iKTsgfTtcbiAgICAvL1xuICAgIHZhciBfZW5jb2RlID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIChzKSB7IHJldHVybiBCdWZmZXIuZnJvbShzLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfVxuICAgICAgICA6IF9URVxuICAgICAgICAgICAgPyBmdW5jdGlvbiAocykgeyByZXR1cm4gX2Zyb21VaW50OEFycmF5KF9URS5lbmNvZGUocykpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChzKSB7IHJldHVybiBfYnRvYSh1dG9iKHMpKTsgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIGEgQmFzZTY0IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1cmxzYWZlXSBpZiBgdHJ1ZWAgbWFrZSB0aGUgcmVzdWx0IFVSTC1zYWZlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gQmFzZTY0IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBlbmNvZGUgPSBmdW5jdGlvbiAoc3JjLCB1cmxzYWZlKSB7XG4gICAgICAgIGlmICh1cmxzYWZlID09PSB2b2lkIDApIHsgdXJsc2FmZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB1cmxzYWZlXG4gICAgICAgICAgICA/IF9ta1VyaVNhZmUoX2VuY29kZShzcmMpKVxuICAgICAgICAgICAgOiBfZW5jb2RlKHNyYyk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIFVURi04LWVuY29kZWQgc3RyaW5nIHRvIFVSTC1zYWZlIEJhc2U2NCBSRkM0NjQ4IMKnNS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBCYXNlNjQgc3RyaW5nXG4gICAgICovXG4gICAgdmFyIGVuY29kZVVSSSA9IGZ1bmN0aW9uIChzcmMpIHsgcmV0dXJuIGVuY29kZShzcmMsIHRydWUpOyB9O1xuICAgIC8vIFRoaXMgdHJpY2sgaXMgZm91bmQgYnJva2VuIGh0dHBzOi8vZ2l0aHViLmNvbS9kYW5rb2dhaS9qcy1iYXNlNjQvaXNzdWVzLzEzMFxuICAgIC8vIGNvbnN0IGJ0b3UgPSAoc3JjOiBzdHJpbmcpID0+IGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoc3JjKSk7XG4gICAgLy8gcmV2ZXJ0aW5nIGdvb2Qgb2xkIGZhdGlvbmVkIHJlZ2V4cFxuICAgIHZhciByZV9idG91ID0gL1tcXHhDMC1cXHhERl1bXFx4ODAtXFx4QkZdfFtcXHhFMC1cXHhFRl1bXFx4ODAtXFx4QkZdezJ9fFtcXHhGMC1cXHhGN11bXFx4ODAtXFx4QkZdezN9L2c7XG4gICAgdmFyIGNiX2J0b3UgPSBmdW5jdGlvbiAoY2NjYykge1xuICAgICAgICBzd2l0Y2ggKGNjY2MubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgdmFyIGNwID0gKCgweDA3ICYgY2NjYy5jaGFyQ29kZUF0KDApKSA8PCAxOClcbiAgICAgICAgICAgICAgICAgICAgfCAoKDB4M2YgJiBjY2NjLmNoYXJDb2RlQXQoMSkpIDw8IDEyKVxuICAgICAgICAgICAgICAgICAgICB8ICgoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgyKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgzKSksIG9mZnNldCA9IGNwIC0gMHgxMDAwMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gKF9mcm9tQ0MoKG9mZnNldCA+Pj4gMTApICsgMHhEODAwKVxuICAgICAgICAgICAgICAgICAgICArIF9mcm9tQ0MoKG9mZnNldCAmIDB4M0ZGKSArIDB4REMwMCkpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgwZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgMTIpXG4gICAgICAgICAgICAgICAgICAgIHwgKCgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDEpKSA8PCA2KVxuICAgICAgICAgICAgICAgICAgICB8ICgweDNmICYgY2NjYy5jaGFyQ29kZUF0KDIpKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJvbUNDKCgoMHgxZiAmIGNjY2MuY2hhckNvZGVBdCgwKSkgPDwgNilcbiAgICAgICAgICAgICAgICAgICAgfCAoMHgzZiAmIGNjY2MuY2hhckNvZGVBdCgxKSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaG91bGQgaGF2ZSBiZWVuIGludGVybmFsIHVzZSBvbmx5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzcmMgVVRGLTE2IHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBidG91ID0gZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGIucmVwbGFjZShyZV9idG91LCBjYl9idG91KTsgfTtcbiAgICAvKipcbiAgICAgKiBwb2x5ZmlsbCB2ZXJzaW9uIG9mIGBhdG9iYFxuICAgICAqL1xuICAgIHZhciBhdG9iUG9seWZpbGwgPSBmdW5jdGlvbiAoYXNjKSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdwb2x5ZmlsbGVkJyk7XG4gICAgICAgIGFzYyA9IGFzYy5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICAgICAgaWYgKCFiNjRyZS50ZXN0KGFzYykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgYmFzZTY0LicpO1xuICAgICAgICBhc2MgKz0gJz09Jy5zbGljZSgyIC0gKGFzYy5sZW5ndGggJiAzKSk7XG4gICAgICAgIHZhciB1MjQsIGJpbiA9ICcnLCByMSwgcjI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXNjLmxlbmd0aDspIHtcbiAgICAgICAgICAgIHUyNCA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldIDw8IDE4XG4gICAgICAgICAgICAgICAgfCBiNjR0YWJbYXNjLmNoYXJBdChpKyspXSA8PCAxMlxuICAgICAgICAgICAgICAgIHwgKHIxID0gYjY0dGFiW2FzYy5jaGFyQXQoaSsrKV0pIDw8IDZcbiAgICAgICAgICAgICAgICB8IChyMiA9IGI2NHRhYlthc2MuY2hhckF0KGkrKyldKTtcbiAgICAgICAgICAgIGJpbiArPSByMSA9PT0gNjQgPyBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSlcbiAgICAgICAgICAgICAgICA6IHIyID09PSA2NCA/IF9mcm9tQ0ModTI0ID4+IDE2ICYgMjU1LCB1MjQgPj4gOCAmIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgOiBfZnJvbUNDKHUyNCA+PiAxNiAmIDI1NSwgdTI0ID4+IDggJiAyNTUsIHUyNCAmIDI1NSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGRvZXMgd2hhdCBgd2luZG93LmF0b2JgIG9mIHdlYiBicm93c2VycyBkby5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXNjIEJhc2U2NC1lbmNvZGVkIHN0cmluZ1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IGJpbmFyeSBzdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgX2F0b2IgPSBfaGFzYXRvYiA/IGZ1bmN0aW9uIChhc2MpIHsgcmV0dXJuIGF0b2IoX3RpZHlCNjQoYXNjKSk7IH1cbiAgICAgICAgOiBfaGFzQnVmZmVyID8gZnVuY3Rpb24gKGFzYykgeyByZXR1cm4gQnVmZmVyLmZyb20oYXNjLCAnYmFzZTY0JykudG9TdHJpbmcoJ2JpbmFyeScpOyB9XG4gICAgICAgICAgICA6IGF0b2JQb2x5ZmlsbDtcbiAgICAvL1xuICAgIHZhciBfdG9VaW50OEFycmF5ID0gX2hhc0J1ZmZlclxuICAgICAgICA/IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfVThBZnJvbShCdWZmZXIuZnJvbShhLCAnYmFzZTY0JykpOyB9XG4gICAgICAgIDogZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF9VOEFmcm9tKF9hdG9iKGEpLCBmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5jaGFyQ29kZUF0KDApOyB9KTsgfTtcbiAgICAvKipcbiAgICAgKiBjb252ZXJ0cyBhIEJhc2U2NCBzdHJpbmcgdG8gYSBVaW50OEFycmF5LlxuICAgICAqL1xuICAgIHZhciB0b1VpbnQ4QXJyYXkgPSBmdW5jdGlvbiAoYSkgeyByZXR1cm4gX3RvVWludDhBcnJheShfdW5VUkkoYSkpOyB9O1xuICAgIC8vXG4gICAgdmFyIF9kZWNvZGUgPSBfaGFzQnVmZmVyXG4gICAgICAgID8gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIEJ1ZmZlci5mcm9tKGEsICdiYXNlNjQnKS50b1N0cmluZygndXRmOCcpOyB9XG4gICAgICAgIDogX1REXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChhKSB7IHJldHVybiBfVEQuZGVjb2RlKF90b1VpbnQ4QXJyYXkoYSkpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChhKSB7IHJldHVybiBidG91KF9hdG9iKGEpKTsgfTtcbiAgICB2YXIgX3VuVVJJID0gZnVuY3Rpb24gKGEpIHsgcmV0dXJuIF90aWR5QjY0KGEucmVwbGFjZSgvWy1fXS9nLCBmdW5jdGlvbiAobTApIHsgcmV0dXJuIG0wID09ICctJyA/ICcrJyA6ICcvJzsgfSkpOyB9O1xuICAgIC8qKlxuICAgICAqIGNvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIFVURi04IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3JjIEJhc2U2NCBzdHJpbmcuICBCb3RoIG5vcm1hbCBhbmQgVVJMLXNhZmUgYXJlIHN1cHBvcnRlZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFVURi04IHN0cmluZ1xuICAgICAqL1xuICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbiAoc3JjKSB7IHJldHVybiBfZGVjb2RlKF91blVSSShzcmMpKTsgfTtcbiAgICAvKipcbiAgICAgKiBjaGVjayBpZiBhIHZhbHVlIGlzIGEgdmFsaWQgQmFzZTY0IHN0cmluZ1xuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzcmMgYSB2YWx1ZSB0byBjaGVja1xuICAgICAgKi9cbiAgICB2YXIgaXNWYWxpZCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcyA9IHNyYy5yZXBsYWNlKC9cXHMrL2csICcnKS5yZXBsYWNlKC89ezAsMn0kLywgJycpO1xuICAgICAgICByZXR1cm4gIS9bXlxcczAtOWEtekEtWlxcKy9dLy50ZXN0KHMpIHx8ICEvW15cXHMwLTlhLXpBLVpcXC1fXS8udGVzdChzKTtcbiAgICB9O1xuICAgIC8vXG4gICAgdmFyIF9ub0VudW0gPSBmdW5jdGlvbiAodikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHYsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleHRlbmQgU3RyaW5nLnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgZXh0ZW5kU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FkZCA9IGZ1bmN0aW9uIChuYW1lLCBib2R5KSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3RyaW5nLnByb3RvdHlwZSwgbmFtZSwgX25vRW51bShib2R5KSk7IH07XG4gICAgICAgIF9hZGQoJ2Zyb21CYXNlNjQnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkZWNvZGUodGhpcyk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NCcsIGZ1bmN0aW9uICh1cmxzYWZlKSB7IHJldHVybiBlbmNvZGUodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGVuY29kZSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgICAgIF9hZGQoJ3RvQmFzZTY0VVJMJywgZnVuY3Rpb24gKCkgeyByZXR1cm4gZW5jb2RlKHRoaXMsIHRydWUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9VaW50OEFycmF5JywgZnVuY3Rpb24gKCkgeyByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGV4dGVuZCBVaW50OEFycmF5LnByb3RvdHlwZSB3aXRoIHJlbGV2YW50IG1ldGhvZHNcbiAgICAgKi9cbiAgICB2YXIgZXh0ZW5kVWludDhBcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hZGQgPSBmdW5jdGlvbiAobmFtZSwgYm9keSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFVpbnQ4QXJyYXkucHJvdG90eXBlLCBuYW1lLCBfbm9FbnVtKGJvZHkpKTsgfTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjQnLCBmdW5jdGlvbiAodXJsc2FmZSkgeyByZXR1cm4gZnJvbVVpbnQ4QXJyYXkodGhpcywgdXJsc2FmZSk7IH0pO1xuICAgICAgICBfYWRkKCd0b0Jhc2U2NFVSSScsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZyb21VaW50OEFycmF5KHRoaXMsIHRydWUpOyB9KTtcbiAgICAgICAgX2FkZCgndG9CYXNlNjRVUkwnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmcm9tVWludDhBcnJheSh0aGlzLCB0cnVlKTsgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBleHRlbmQgQnVpbHRpbiBwcm90b3R5cGVzIHdpdGggcmVsZXZhbnQgbWV0aG9kc1xuICAgICAqL1xuICAgIHZhciBleHRlbmRCdWlsdGlucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXh0ZW5kU3RyaW5nKCk7XG4gICAgICAgIGV4dGVuZFVpbnQ4QXJyYXkoKTtcbiAgICB9O1xuICAgIHZhciBnQmFzZTY0ID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uLFxuICAgICAgICBWRVJTSU9OOiBWRVJTSU9OLFxuICAgICAgICBhdG9iOiBfYXRvYixcbiAgICAgICAgYXRvYlBvbHlmaWxsOiBhdG9iUG9seWZpbGwsXG4gICAgICAgIGJ0b2E6IF9idG9hLFxuICAgICAgICBidG9hUG9seWZpbGw6IGJ0b2FQb2x5ZmlsbCxcbiAgICAgICAgZnJvbUJhc2U2NDogZGVjb2RlLFxuICAgICAgICB0b0Jhc2U2NDogZW5jb2RlLFxuICAgICAgICBlbmNvZGU6IGVuY29kZSxcbiAgICAgICAgZW5jb2RlVVJJOiBlbmNvZGVVUkksXG4gICAgICAgIGVuY29kZVVSTDogZW5jb2RlVVJJLFxuICAgICAgICB1dG9iOiB1dG9iLFxuICAgICAgICBidG91OiBidG91LFxuICAgICAgICBkZWNvZGU6IGRlY29kZSxcbiAgICAgICAgaXNWYWxpZDogaXNWYWxpZCxcbiAgICAgICAgZnJvbVVpbnQ4QXJyYXk6IGZyb21VaW50OEFycmF5LFxuICAgICAgICB0b1VpbnQ4QXJyYXk6IHRvVWludDhBcnJheSxcbiAgICAgICAgZXh0ZW5kU3RyaW5nOiBleHRlbmRTdHJpbmcsXG4gICAgICAgIGV4dGVuZFVpbnQ4QXJyYXk6IGV4dGVuZFVpbnQ4QXJyYXksXG4gICAgICAgIGV4dGVuZEJ1aWx0aW5zOiBleHRlbmRCdWlsdGluc1xuICAgIH07XG4gICAgLy9cbiAgICAvLyBleHBvcnQgQmFzZTY0IHRvIHRoZSBuYW1lc3BhY2VcbiAgICAvL1xuICAgIC8vIEVTNSBpcyB5ZXQgdG8gaGF2ZSBPYmplY3QuYXNzaWduKCkgdGhhdCBtYXkgbWFrZSB0cmFuc3BpbGVycyB1bmhhcHB5LlxuICAgIC8vIGdCYXNlNjQuQmFzZTY0ID0gT2JqZWN0LmFzc2lnbih7fSwgZ0Jhc2U2NCk7XG4gICAgZ0Jhc2U2NC5CYXNlNjQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhnQmFzZTY0KS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7IHJldHVybiBnQmFzZTY0LkJhc2U2NFtrXSA9IGdCYXNlNjRba107IH0pO1xuICAgIHJldHVybiBnQmFzZTY0O1xufSkpO1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuICBpZiAoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiZcbiAgICAgIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJlxuICAgICAgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIC8vIFRoaXMgZW52aXJvbm1lbnQgaGFzIGEgbmF0aXZlICVJdGVyYXRvclByb3RvdHlwZSU7IHVzZSBpdCBpbnN0ZWFkXG4gICAgLy8gb2YgdGhlIHBvbHlmaWxsLlxuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPVxuICAgIEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIGRlZmluZShHcCwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gIGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCBHZW5lcmF0b3JGdW5jdGlvbik7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKFxuICAgIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sLFxuICAgIFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICApO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3JcbiAgICAgID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHxcbiAgICAgICAgLy8gRm9yIHRoZSBuYXRpdmUgR2VuZXJhdG9yRnVuY3Rpb24gY29uc3RydWN0b3IsIHRoZSBiZXN0IHdlIGNhblxuICAgICAgICAvLyBkbyBpcyB0byBjaGVjayBpdHMgLm5hbWUgcHJvcGVydHkuXG4gICAgICAgIChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkgPT09IFwiR2VuZXJhdG9yRnVuY3Rpb25cIlxuICAgICAgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbihnZW5GdW4pIHtcbiAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgICAgIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPVxuICAgICAgICAvLyBJZiBlbnF1ZXVlIGhhcyBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byB3YWl0IHVudGlsXG4gICAgICAgIC8vIGFsbCBwcmV2aW91cyBQcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQgYmVmb3JlIGNhbGxpbmcgaW52b2tlLFxuICAgICAgICAvLyBzbyB0aGF0IHJlc3VsdHMgYXJlIGFsd2F5cyBkZWxpdmVyZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIuIElmXG4gICAgICAgIC8vIGVucXVldWUgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUsIHRoZW4gaXQgaXMgaW1wb3J0YW50IHRvXG4gICAgICAgIC8vIGNhbGwgaW52b2tlIGltbWVkaWF0ZWx5LCB3aXRob3V0IHdhaXRpbmcgb24gYSBjYWxsYmFjayB0byBmaXJlLFxuICAgICAgICAvLyBzbyB0aGF0IHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gaGFzIHRoZSBvcHBvcnR1bml0eSB0byBkb1xuICAgICAgICAvLyBhbnkgbmVjZXNzYXJ5IHNldHVwIGluIGEgcHJlZGljdGFibGUgd2F5LiBUaGlzIHByZWRpY3RhYmlsaXR5XG4gICAgICAgIC8vIGlzIHdoeSB0aGUgUHJvbWlzZSBjb25zdHJ1Y3RvciBzeW5jaHJvbm91c2x5IGludm9rZXMgaXRzXG4gICAgICAgIC8vIGV4ZWN1dG9yIGNhbGxiYWNrLCBhbmQgd2h5IGFzeW5jIGZ1bmN0aW9ucyBzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGV4ZWN1dGUgY29kZSBiZWZvcmUgdGhlIGZpcnN0IGF3YWl0LiBTaW5jZSB3ZSBpbXBsZW1lbnQgc2ltcGxlXG4gICAgICAgIC8vIGFzeW5jIGZ1bmN0aW9ucyBpbiB0ZXJtcyBvZiBhc3luYyBnZW5lcmF0b3JzLCBpdCBpcyBlc3BlY2lhbGx5XG4gICAgICAgIC8vIGltcG9ydGFudCB0byBnZXQgdGhpcyByaWdodCwgZXZlbiB0aG91Z2ggaXQgcmVxdWlyZXMgY2FyZS5cbiAgICAgICAgcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsXG4gICAgICAgICAgLy8gQXZvaWQgcHJvcGFnYXRpbmcgZmFpbHVyZXMgdG8gUHJvbWlzZXMgcmV0dXJuZWQgYnkgbGF0ZXJcbiAgICAgICAgICAvLyBpbnZvY2F0aW9ucyBvZiB0aGUgaXRlcmF0b3IuXG4gICAgICAgICAgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmdcbiAgICAgICAgKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7XG4gICAgfVxuXG4gICAgLy8gRGVmaW5lIHRoZSB1bmlmaWVkIGhlbHBlciBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGltcGxlbWVudCAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIChzZWUgZGVmaW5lSXRlcmF0b3JNZXRob2RzKS5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcbiAgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KTtcblxuICBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gVGhlIHJvb3QgZW50cnkgb2JqZWN0IChlZmZlY3RpdmVseSBhIHRyeSBzdGF0ZW1lbnQgd2l0aG91dCBhIGNhdGNoXG4gICAgLy8gb3IgYSBmaW5hbGx5IGJsb2NrKSBnaXZlcyB1cyBhIHBsYWNlIHRvIHN0b3JlIHZhbHVlcyB0aHJvd24gZnJvbVxuICAgIC8vIGxvY2F0aW9ucyB3aGVyZSB0aGVyZSBpcyBubyBlbmNsb3NpbmcgdHJ5IHN0YXRlbWVudC5cbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG4gICAga2V5cy5yZXZlcnNlKCk7XG5cbiAgICAvLyBSYXRoZXIgdGhhbiByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggYSBuZXh0IG1ldGhvZCwgd2Uga2VlcFxuICAgIC8vIHRoaW5ncyBzaW1wbGUgYW5kIHJldHVybiB0aGUgbmV4dCBmdW5jdGlvbiBpdHNlbGYuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG4gICAgICAgIGlmIChrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgbmV4dC52YWx1ZSA9IGtleTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUbyBhdm9pZCBjcmVhdGluZyBhbiBhZGRpdGlvbmFsIG9iamVjdCwgd2UganVzdCBoYW5nIHRoZSAudmFsdWVcbiAgICAgIC8vIGFuZCAuZG9uZSBwcm9wZXJ0aWVzIG9mZiB0aGUgbmV4dCBmdW5jdGlvbiBvYmplY3QgaXRzZWxmLiBUaGlzXG4gICAgICAvLyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgbWluaWZpZXIgd2lsbCBub3QgYW5vbnltaXplIHRoZSBmdW5jdGlvbi5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuICAgICAgaWYgKGl0ZXJhdG9yTWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYWJsZS5uZXh0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhYmxlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHtcbiAgICAgICAgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYW4gaXRlcmF0b3Igd2l0aCBubyB2YWx1ZXMuXG4gICAgcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9O1xuICB9XG4gIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzO1xuXG4gIGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgLy8gTm90IHN1cmUgYWJvdXQgdGhlIG9wdGltYWwgb3JkZXIgb2YgdGhlc2UgY29uZGl0aW9uczpcbiAgICAgICAgICBpZiAobmFtZS5jaGFyQXQoMCkgPT09IFwidFwiICYmXG4gICAgICAgICAgICAgIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICFpc05hTigrbmFtZS5zbGljZSgxKSkpIHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISEgY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICAvLyBFeGNlcHRpb24gdGhyb3duIG91dHNpZGUgb2YgYW55IHRyeSBibG9jayB0aGF0IGNvdWxkIGhhbmRsZVxuICAgICAgICAgIC8vIGl0LCBzbyBzZXQgdGhlIGNvbXBsZXRpb24gdmFsdWUgb2YgdGhlIGVudGlyZSBmdW5jdGlvbiB0b1xuICAgICAgICAgIC8vIHRocm93IHRoZSBleGNlcHRpb24uXG4gICAgICAgICAgcmV0dXJuIGhhbmRsZShcImVuZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIik7XG4gICAgICAgICAgdmFyIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpO1xuXG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uKHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmXG4gICAgICAgICAgICB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiZcbiAgICAgICAgICAodHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgIHR5cGUgPT09IFwiY29udGludWVcIikgJiZcbiAgICAgICAgICBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJlxuICAgICAgICAgIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGZpbmFsbHkgZW50cnkgaWYgY29udHJvbCBpcyBub3QganVtcGluZyB0byBhXG4gICAgICAgIC8vIGxvY2F0aW9uIG91dHNpZGUgdGhlIHRyeS9jYXRjaCBibG9jay5cbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8XG4gICAgICAgICAgcmVjb3JkLnR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICB0aGlzLm5leHQgPSByZWNvcmQuYXJnO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICB0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gXCJlbmRcIjtcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIgJiYgYWZ0ZXJMb2MpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gYWZ0ZXJMb2M7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG5cbiAgICBmaW5pc2g6IGZ1bmN0aW9uKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24odHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVGhlIGNvbnRleHQuY2F0Y2ggbWV0aG9kIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIGxvY2F0aW9uXG4gICAgICAvLyBhcmd1bWVudCB0aGF0IGNvcnJlc3BvbmRzIHRvIGEga25vd24gY2F0Y2ggYmxvY2suXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcblxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAvLyBEZWxpYmVyYXRlbHkgZm9yZ2V0IHRoZSBsYXN0IHNlbnQgdmFsdWUgc28gdGhhdCB3ZSBkb24ndFxuICAgICAgICAvLyBhY2NpZGVudGFsbHkgcGFzcyBpdCBvbiB0byB0aGUgZGVsZWdhdGUuXG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG5cbiAgLy8gUmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZVxuICAvLyBvciBub3QsIHJldHVybiB0aGUgcnVudGltZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZGVjbGFyZSB0aGUgdmFyaWFibGVcbiAgLy8gcmVnZW5lcmF0b3JSdW50aW1lIGluIHRoZSBvdXRlciBzY29wZSwgd2hpY2ggYWxsb3dzIHRoaXMgbW9kdWxlIHRvIGJlXG4gIC8vIGluamVjdGVkIGVhc2lseSBieSBgYmluL3JlZ2VuZXJhdG9yIC0taW5jbHVkZS1ydW50aW1lIHNjcmlwdC5qc2AuXG4gIHJldHVybiBleHBvcnRzO1xuXG59KFxuICAvLyBJZiB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGUsIHVzZSBtb2R1bGUuZXhwb3J0c1xuICAvLyBhcyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIG5hbWVzcGFjZS4gT3RoZXJ3aXNlIGNyZWF0ZSBhIG5ldyBlbXB0eVxuICAvLyBvYmplY3QuIEVpdGhlciB3YXksIHRoZSByZXN1bHRpbmcgb2JqZWN0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplXG4gIC8vIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgdmFyaWFibGUgYXQgdGhlIHRvcCBvZiB0aGlzIGZpbGUuXG4gIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9XG4pKTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIC8vIFRoaXMgbW9kdWxlIHNob3VsZCBub3QgYmUgcnVubmluZyBpbiBzdHJpY3QgbW9kZSwgc28gdGhlIGFib3ZlXG4gIC8vIGFzc2lnbm1lbnQgc2hvdWxkIGFsd2F5cyB3b3JrIHVubGVzcyBzb21ldGhpbmcgaXMgbWlzY29uZmlndXJlZC4gSnVzdFxuICAvLyBpbiBjYXNlIHJ1bnRpbWUuanMgYWNjaWRlbnRhbGx5IHJ1bnMgaW4gc3RyaWN0IG1vZGUsIGluIG1vZGVybiBlbmdpbmVzXG4gIC8vIHdlIGNhbiBleHBsaWNpdGx5IGFjY2VzcyBnbG9iYWxUaGlzLiBJbiBvbGRlciBlbmdpbmVzIHdlIGNhbiBlc2NhcGVcbiAgLy8gc3RyaWN0IG1vZGUgdXNpbmcgYSBnbG9iYWwgRnVuY3Rpb24gY2FsbC4gVGhpcyBjb3VsZCBjb25jZWl2YWJseSBmYWlsXG4gIC8vIGlmIGEgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgZm9yYmlkcyB1c2luZyBGdW5jdGlvbiwgYnV0IGluIHRoYXQgY2FzZVxuICAvLyB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzIHRvIGZpeCB0aGUgYWNjaWRlbnRhbCBzdHJpY3QgbW9kZSBwcm9ibGVtLiBJZlxuICAvLyB5b3UndmUgbWlzY29uZmlndXJlZCB5b3VyIGJ1bmRsZXIgdG8gZm9yY2Ugc3RyaWN0IG1vZGUgYW5kIGFwcGxpZWQgYVxuICAvLyBDU1AgdG8gZm9yYmlkIEZ1bmN0aW9uLCBhbmQgeW91J3JlIG5vdCB3aWxsaW5nIHRvIGZpeCBlaXRoZXIgb2YgdGhvc2VcbiAgLy8gcHJvYmxlbXMsIHBsZWFzZSBkZXRhaWwgeW91ciB1bmlxdWUgcHJlZGljYW1lbnQgaW4gYSBHaXRIdWIgaXNzdWUuXG4gIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gXCJvYmplY3RcIikge1xuICAgIGdsb2JhbFRoaXMucmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbiAgfSBlbHNlIHtcbiAgICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UncmUgcmVxdWlyZWQgdG8gYWRkIGEgcG9ydCBudW1iZXIuXG4gKlxuICogQHNlZSBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RlZmF1bHQtcG9ydFxuICogQHBhcmFtIHtOdW1iZXJ8U3RyaW5nfSBwb3J0IFBvcnQgbnVtYmVyIHdlIG5lZWQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm90b2NvbCBQcm90b2NvbCB3ZSBuZWVkIHRvIGNoZWNrIGFnYWluc3QuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gSXMgaXQgYSBkZWZhdWx0IHBvcnQgZm9yIHRoZSBnaXZlbiBwcm90b2NvbFxuICogQGFwaSBwcml2YXRlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcmVxdWlyZWQocG9ydCwgcHJvdG9jb2wpIHtcbiAgcHJvdG9jb2wgPSBwcm90b2NvbC5zcGxpdCgnOicpWzBdO1xuICBwb3J0ID0gK3BvcnQ7XG5cbiAgaWYgKCFwb3J0KSByZXR1cm4gZmFsc2U7XG5cbiAgc3dpdGNoIChwcm90b2NvbCkge1xuICAgIGNhc2UgJ2h0dHAnOlxuICAgIGNhc2UgJ3dzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gODA7XG5cbiAgICBjYXNlICdodHRwcyc6XG4gICAgY2FzZSAnd3NzJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNDQzO1xuXG4gICAgY2FzZSAnZnRwJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gMjE7XG5cbiAgICBjYXNlICdnb3BoZXInOlxuICAgIHJldHVybiBwb3J0ICE9PSA3MDtcblxuICAgIGNhc2UgJ2ZpbGUnOlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBwb3J0ICE9PSAwO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHJlcXVpcmVkID0gcmVxdWlyZSgncmVxdWlyZXMtcG9ydCcpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgY29udHJvbE9yV2hpdGVzcGFjZSA9IC9eW1xceDAwLVxceDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdKy9cbiAgLCBDUkhUTEYgPSAvW1xcblxcclxcdF0vZ1xuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOlxcL1xcLy9cbiAgLCBwb3J0ID0gLzpcXGQrJC9cbiAgLCBwcm90b2NvbHJlID0gL14oW2Etel1bYS16MC05ListXSo6KT8oXFwvXFwvKT8oW1xcXFwvXSspPyhbXFxTXFxzXSopL2lcbiAgLCB3aW5kb3dzRHJpdmVMZXR0ZXIgPSAvXlthLXpBLVpdOi87XG5cbi8qKlxuICogUmVtb3ZlIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBBIG5ldyBzdHJpbmcgcmVwcmVzZW50aW5nIGBzdHJgIHN0cmlwcGVkIG9mIGNvbnRyb2xcbiAqICAgICBjaGFyYWN0ZXJzIGFuZCB3aGl0ZXNwYWNlIGZyb20gaXRzIGJlZ2lubmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdHJpbUxlZnQoc3RyKSB7XG4gIHJldHVybiAoc3RyID8gc3RyIDogJycpLnRvU3RyaW5nKCkucmVwbGFjZShjb250cm9sT3JXaGl0ZXNwYWNlLCAnJyk7XG59XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBydWxlcyBmb3IgdGhlIFVSTCBwYXJzZXIsIGl0IGluZm9ybXMgdGhlIHBhcnNlclxuICogYWJvdXQ6XG4gKlxuICogMC4gVGhlIGNoYXIgaXQgTmVlZHMgdG8gcGFyc2UsIGlmIGl0J3MgYSBzdHJpbmcgaXQgc2hvdWxkIGJlIGRvbmUgdXNpbmdcbiAqICAgIGluZGV4T2YsIFJlZ0V4cCB1c2luZyBleGVjIGFuZCBOYU4gbWVhbnMgc2V0IGFzIGN1cnJlbnQgdmFsdWUuXG4gKiAxLiBUaGUgcHJvcGVydHkgd2Ugc2hvdWxkIHNldCB3aGVuIHBhcnNpbmcgdGhpcyB2YWx1ZS5cbiAqIDIuIEluZGljYXRpb24gaWYgaXQncyBiYWNrd2FyZHMgb3IgZm9yd2FyZCBwYXJzaW5nLCB3aGVuIHNldCBhcyBudW1iZXIgaXQnc1xuICogICAgdGhlIHZhbHVlIG9mIGV4dHJhIGNoYXJzIHRoYXQgc2hvdWxkIGJlIHNwbGl0IG9mZi5cbiAqIDMuIEluaGVyaXQgZnJvbSBsb2NhdGlvbiBpZiBub24gZXhpc3RpbmcgaW4gdGhlIHBhcnNlci5cbiAqIDQuIGB0b0xvd2VyQ2FzZWAgdGhlIHJlc3VsdGluZyB2YWx1ZS5cbiAqL1xudmFyIHJ1bGVzID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIGZ1bmN0aW9uIHNhbml0aXplKGFkZHJlc3MsIHVybCkgeyAgICAgLy8gU2FuaXRpemUgd2hhdCBpcyBsZWZ0IG9mIHRoZSBhZGRyZXNzXG4gICAgcmV0dXJuIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gYWRkcmVzcy5yZXBsYWNlKC9cXFxcL2csICcvJykgOiBhZGRyZXNzO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQqKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGdsb2JhbFZhcjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHdpbmRvdztcbiAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtcbiAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBzZWxmO1xuICBlbHNlIGdsb2JhbFZhciA9IHt9O1xuXG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBwcm90b2NvbCBzY2hlbWUgaXMgc3BlY2lhbC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gVGhlIHByb3RvY29sIHNjaGVtZSBvZiB0aGUgVVJMXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHByb3RvY29sIHNjaGVtZSBpcyBzcGVjaWFsLCBlbHNlIGBmYWxzZWBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzU3BlY2lhbChzY2hlbWUpIHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWUgPT09ICdmaWxlOicgfHxcbiAgICBzY2hlbWUgPT09ICdmdHA6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2h0dHA6JyB8fFxuICAgIHNjaGVtZSA9PT0gJ2h0dHBzOicgfHxcbiAgICBzY2hlbWUgPT09ICd3czonIHx8XG4gICAgc2NoZW1lID09PSAnd3NzOidcbiAgKTtcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiBQcm90b2NvbEV4dHJhY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHByb3BlcnR5IHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIG1hdGNoZWQgaW4gdGhlIFVSTCwgaW4gbG93ZXJjYXNlLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBzbGFzaGVzIGB0cnVlYCBpZiBwcm90b2NvbCBpcyBmb2xsb3dlZCBieSBcIi8vXCIsIGVsc2UgYGZhbHNlYC5cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSByZXN0IFJlc3Qgb2YgdGhlIFVSTCB0aGF0IGlzIG5vdCBwYXJ0IG9mIHRoZSBwcm90b2NvbC5cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gZnJvbSBhIFVSTCB3aXRoL3dpdGhvdXQgZG91YmxlIHNsYXNoIChcIi8vXCIpLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIGV4dHJhY3QgZnJvbS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhdGlvblxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcywgbG9jYXRpb24pIHtcbiAgYWRkcmVzcyA9IHRyaW1MZWZ0KGFkZHJlc3MpO1xuICBhZGRyZXNzID0gYWRkcmVzcy5yZXBsYWNlKENSSFRMRiwgJycpO1xuICBsb2NhdGlvbiA9IGxvY2F0aW9uIHx8IHt9O1xuXG4gIHZhciBtYXRjaCA9IHByb3RvY29scmUuZXhlYyhhZGRyZXNzKTtcbiAgdmFyIHByb3RvY29sID0gbWF0Y2hbMV0gPyBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpIDogJyc7XG4gIHZhciBmb3J3YXJkU2xhc2hlcyA9ICEhbWF0Y2hbMl07XG4gIHZhciBvdGhlclNsYXNoZXMgPSAhIW1hdGNoWzNdO1xuICB2YXIgc2xhc2hlc0NvdW50ID0gMDtcbiAgdmFyIHJlc3Q7XG5cbiAgaWYgKGZvcndhcmRTbGFzaGVzKSB7XG4gICAgaWYgKG90aGVyU2xhc2hlcykge1xuICAgICAgcmVzdCA9IG1hdGNoWzJdICsgbWF0Y2hbM10gKyBtYXRjaFs0XTtcbiAgICAgIHNsYXNoZXNDb3VudCA9IG1hdGNoWzJdLmxlbmd0aCArIG1hdGNoWzNdLmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdCA9IG1hdGNoWzJdICsgbWF0Y2hbNF07XG4gICAgICBzbGFzaGVzQ291bnQgPSBtYXRjaFsyXS5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChvdGhlclNsYXNoZXMpIHtcbiAgICAgIHJlc3QgPSBtYXRjaFszXSArIG1hdGNoWzRdO1xuICAgICAgc2xhc2hlc0NvdW50ID0gbWF0Y2hbM10ubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0ID0gbWF0Y2hbNF1cbiAgICB9XG4gIH1cblxuICBpZiAocHJvdG9jb2wgPT09ICdmaWxlOicpIHtcbiAgICBpZiAoc2xhc2hlc0NvdW50ID49IDIpIHtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKDIpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1NwZWNpYWwocHJvdG9jb2wpKSB7XG4gICAgcmVzdCA9IG1hdGNoWzRdO1xuICB9IGVsc2UgaWYgKHByb3RvY29sKSB7XG4gICAgaWYgKGZvcndhcmRTbGFzaGVzKSB7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZSgyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc2xhc2hlc0NvdW50ID49IDIgJiYgaXNTcGVjaWFsKGxvY2F0aW9uLnByb3RvY29sKSkge1xuICAgIHJlc3QgPSBtYXRjaFs0XTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHByb3RvY29sLFxuICAgIHNsYXNoZXM6IGZvcndhcmRTbGFzaGVzIHx8IGlzU3BlY2lhbChwcm90b2NvbCksXG4gICAgc2xhc2hlc0NvdW50OiBzbGFzaGVzQ291bnQsXG4gICAgcmVzdDogcmVzdFxuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSByZWxhdGl2ZSBVUkwgcGF0aG5hbWUgYWdhaW5zdCBhIGJhc2UgVVJMIHBhdGhuYW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZSBQYXRobmFtZSBvZiB0aGUgcmVsYXRpdmUgVVJMLlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2UgUGF0aG5hbWUgb2YgdGhlIGJhc2UgVVJMLlxuICogQHJldHVybiB7U3RyaW5nfSBSZXNvbHZlZCBwYXRobmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUocmVsYXRpdmUsIGJhc2UpIHtcbiAgaWYgKHJlbGF0aXZlID09PSAnJykgcmV0dXJuIGJhc2U7XG5cbiAgdmFyIHBhdGggPSAoYmFzZSB8fCAnLycpLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLmNvbmNhdChyZWxhdGl2ZS5zcGxpdCgnLycpKVxuICAgICwgaSA9IHBhdGgubGVuZ3RoXG4gICAgLCBsYXN0ID0gcGF0aFtpIC0gMV1cbiAgICAsIHVuc2hpZnQgPSBmYWxzZVxuICAgICwgdXAgPSAwO1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAocGF0aFtpXSA9PT0gJy4nKSB7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKHBhdGhbaV0gPT09ICcuLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBpZiAoaSA9PT0gMCkgdW5zaGlmdCA9IHRydWU7XG4gICAgICBwYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuc2hpZnQpIHBhdGgudW5zaGlmdCgnJyk7XG4gIGlmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgcGF0aC5wdXNoKCcnKTtcblxuICByZXR1cm4gcGF0aC5qb2luKCcvJyk7XG59XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IE9DRC5cbiAqXG4gKiBJdCBpcyB3b3J0aCBub3RpbmcgdGhhdCB3ZSBzaG91bGQgbm90IHVzZSBgVVJMYCBhcyBjbGFzcyBuYW1lIHRvIHByZXZlbnRcbiAqIGNsYXNoZXMgd2l0aCB0aGUgZ2xvYmFsIFVSTCBpbnN0YW5jZSB0aGF0IGdvdCBpbnRyb2R1Y2VkIGluIGJyb3dzZXJzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gcGFyc2UuXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IFtsb2NhdGlvbl0gTG9jYXRpb24gZGVmYXVsdHMgZm9yIHJlbGF0aXZlIHBhdGhzLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBbcGFyc2VyXSBQYXJzZXIgZm9yIHRoZSBxdWVyeSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBVcmwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG4gIGFkZHJlc3MgPSBhZGRyZXNzLnJlcGxhY2UoQ1JIVExGLCAnJyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFVybCkpIHtcbiAgICByZXR1cm4gbmV3IFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKTtcbiAgfVxuXG4gIHZhciByZWxhdGl2ZSwgZXh0cmFjdGVkLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIGluc3RydWN0aW9ucyA9IHJ1bGVzLnNsaWNlKClcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikgcGFyc2VyID0gcXMucGFyc2U7XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIC8vXG4gIC8vIEV4dHJhY3QgcHJvdG9jb2wgaW5mb3JtYXRpb24gYmVmb3JlIHJ1bm5pbmcgdGhlIGluc3RydWN0aW9ucy5cbiAgLy9cbiAgZXh0cmFjdGVkID0gZXh0cmFjdFByb3RvY29sKGFkZHJlc3MgfHwgJycsIGxvY2F0aW9uKTtcbiAgcmVsYXRpdmUgPSAhZXh0cmFjdGVkLnByb3RvY29sICYmICFleHRyYWN0ZWQuc2xhc2hlcztcbiAgdXJsLnNsYXNoZXMgPSBleHRyYWN0ZWQuc2xhc2hlcyB8fCByZWxhdGl2ZSAmJiBsb2NhdGlvbi5zbGFzaGVzO1xuICB1cmwucHJvdG9jb2wgPSBleHRyYWN0ZWQucHJvdG9jb2wgfHwgbG9jYXRpb24ucHJvdG9jb2wgfHwgJyc7XG4gIGFkZHJlc3MgPSBleHRyYWN0ZWQucmVzdDtcblxuICAvL1xuICAvLyBXaGVuIHRoZSBhdXRob3JpdHkgY29tcG9uZW50IGlzIGFic2VudCB0aGUgVVJMIHN0YXJ0cyB3aXRoIGEgcGF0aFxuICAvLyBjb21wb25lbnQuXG4gIC8vXG4gIGlmIChcbiAgICBleHRyYWN0ZWQucHJvdG9jb2wgPT09ICdmaWxlOicgJiYgKFxuICAgICAgZXh0cmFjdGVkLnNsYXNoZXNDb3VudCAhPT0gMiB8fCB3aW5kb3dzRHJpdmVMZXR0ZXIudGVzdChhZGRyZXNzKSkgfHxcbiAgICAoIWV4dHJhY3RlZC5zbGFzaGVzICYmXG4gICAgICAoZXh0cmFjdGVkLnByb3RvY29sIHx8XG4gICAgICAgIGV4dHJhY3RlZC5zbGFzaGVzQ291bnQgPCAyIHx8XG4gICAgICAgICFpc1NwZWNpYWwodXJsLnByb3RvY29sKSkpXG4gICkge1xuICAgIGluc3RydWN0aW9uc1szXSA9IFsvKC4qKS8sICdwYXRobmFtZSddO1xuICB9XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcblxuICAgIGlmICh0eXBlb2YgaW5zdHJ1Y3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFkZHJlc3MgPSBpbnN0cnVjdGlvbihhZGRyZXNzLCB1cmwpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGluZGV4ID0gcGFyc2UgPT09ICdAJ1xuICAgICAgICA/IGFkZHJlc3MubGFzdEluZGV4T2YocGFyc2UpXG4gICAgICAgIDogYWRkcmVzcy5pbmRleE9mKHBhcnNlKTtcblxuICAgICAgaWYgKH5pbmRleCkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpKSB7XG4gICAgICB1cmxba2V5XSA9IGluZGV4WzFdO1xuICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXguaW5kZXgpO1xuICAgIH1cblxuICAgIHVybFtrZXldID0gdXJsW2tleV0gfHwgKFxuICAgICAgcmVsYXRpdmUgJiYgaW5zdHJ1Y3Rpb25bM10gPyBsb2NhdGlvbltrZXldIHx8ICcnIDogJydcbiAgICApO1xuXG4gICAgLy9cbiAgICAvLyBIb3N0bmFtZSwgaG9zdCBhbmQgcHJvdG9jb2wgc2hvdWxkIGJlIGxvd2VyY2FzZWQgc28gdGhleSBjYW4gYmUgdXNlZCB0b1xuICAgIC8vIGNyZWF0ZSBhIHByb3BlciBgb3JpZ2luYC5cbiAgICAvL1xuICAgIGlmIChpbnN0cnVjdGlvbls0XSkgdXJsW2tleV0gPSB1cmxba2V5XS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIElmIHRoZSBVUkwgaXMgcmVsYXRpdmUsIHJlc29sdmUgdGhlIHBhdGhuYW1lIGFnYWluc3QgdGhlIGJhc2UgVVJMLlxuICAvL1xuICBpZiAoXG4gICAgICByZWxhdGl2ZVxuICAgICYmIGxvY2F0aW9uLnNsYXNoZXNcbiAgICAmJiB1cmwucGF0aG5hbWUuY2hhckF0KDApICE9PSAnLydcbiAgICAmJiAodXJsLnBhdGhuYW1lICE9PSAnJyB8fCBsb2NhdGlvbi5wYXRobmFtZSAhPT0gJycpXG4gICkge1xuICAgIHVybC5wYXRobmFtZSA9IHJlc29sdmUodXJsLnBhdGhuYW1lLCBsb2NhdGlvbi5wYXRobmFtZSk7XG4gIH1cblxuICAvL1xuICAvLyBEZWZhdWx0IHRvIGEgLyBmb3IgcGF0aG5hbWUgaWYgbm9uZSBleGlzdHMuIFRoaXMgbm9ybWFsaXplcyB0aGUgVVJMXG4gIC8vIHRvIGFsd2F5cyBoYXZlIGEgL1xuICAvL1xuICBpZiAodXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLnBhdGhuYW1lID0gJy8nICsgdXJsLnBhdGhuYW1lO1xuICB9XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG5cbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5kZXggPSB1cmwuYXV0aC5pbmRleE9mKCc6Jyk7XG5cbiAgICBpZiAofmluZGV4KSB7XG4gICAgICB1cmwudXNlcm5hbWUgPSB1cmwuYXV0aC5zbGljZSgwLCBpbmRleCk7XG4gICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC51c2VybmFtZSkpO1xuXG4gICAgICB1cmwucGFzc3dvcmQgPSB1cmwuYXV0aC5zbGljZShpbmRleCArIDEpO1xuICAgICAgdXJsLnBhc3N3b3JkID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwucGFzc3dvcmQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmwudXNlcm5hbWUgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5hdXRoKSk7XG4gICAgfVxuXG4gICAgdXJsLmF1dGggPSB1cmwucGFzc3dvcmQgPyB1cmwudXNlcm5hbWUgKyc6JysgdXJsLnBhc3N3b3JkIDogdXJsLnVzZXJuYW1lO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAhPT0gJ2ZpbGU6JyAmJiBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJiB1cmwuaG9zdFxuICAgID8gdXJsLnByb3RvY29sICsnLy8nKyB1cmwuaG9zdFxuICAgIDogJ251bGwnO1xuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXJ0ICAgICAgICAgIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgICAgICAgICAgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHBhcmFtIHtCb29sZWFufEZ1bmN0aW9ufSBmbiAgV2hlbiBzZXR0aW5nIHRoZSBxdWVyeSwgaXQgd2lsbCBiZSB0aGUgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgdG8gcGFyc2UgdGhlIHF1ZXJ5LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV2hlbiBzZXR0aW5nIHRoZSBwcm90b2NvbCwgZG91YmxlIHNsYXNoIHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQgZnJvbSB0aGUgZmluYWwgdXJsIGlmIGl0IGlzIHRydWUuXG4gKiBAcmV0dXJucyB7VVJMfSBVUkwgaW5zdGFuY2UgZm9yIGNoYWluaW5nLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXQocGFydCwgdmFsdWUsIGZuKSB7XG4gIHZhciB1cmwgPSB0aGlzO1xuXG4gIHN3aXRjaCAocGFydCkge1xuICAgIGNhc2UgJ3F1ZXJ5JzpcbiAgICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IChmbiB8fCBxcy5wYXJzZSkodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncG9ydCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKCFyZXF1aXJlZCh2YWx1ZSwgdXJsLnByb3RvY29sKSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2hvc3RuYW1lJzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0JzpcbiAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgICBpZiAocG9ydC50ZXN0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnNwbGl0KCc6Jyk7XG4gICAgICAgIHVybC5wb3J0ID0gdmFsdWUucG9wKCk7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlLmpvaW4oJzonKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlO1xuICAgICAgICB1cmwucG9ydCA9ICcnO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3Byb3RvY29sJzpcbiAgICAgIHVybC5wcm90b2NvbCA9IHZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB1cmwuc2xhc2hlcyA9ICFmbjtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncGF0aG5hbWUnOlxuICAgIGNhc2UgJ2hhc2gnOlxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBjaGFyID0gcGFydCA9PT0gJ3BhdGhuYW1lJyA/ICcvJyA6ICcjJztcbiAgICAgICAgdXJsW3BhcnRdID0gdmFsdWUuY2hhckF0KDApICE9PSBjaGFyID8gY2hhciArIHZhbHVlIDogdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAndXNlcm5hbWUnOlxuICAgIGNhc2UgJ3Bhc3N3b3JkJzpcbiAgICAgIHVybFtwYXJ0XSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2F1dGgnOlxuICAgICAgdmFyIGluZGV4ID0gdmFsdWUuaW5kZXhPZignOicpO1xuXG4gICAgICBpZiAofmluZGV4KSB7XG4gICAgICAgIHVybC51c2VybmFtZSA9IHZhbHVlLnNsaWNlKDAsIGluZGV4KTtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh1cmwudXNlcm5hbWUpKTtcblxuICAgICAgICB1cmwucGFzc3dvcmQgPSB2YWx1ZS5zbGljZShpbmRleCArIDEpO1xuICAgICAgICB1cmwucGFzc3dvcmQgPSBlbmNvZGVVUklDb21wb25lbnQoZGVjb2RlVVJJQ29tcG9uZW50KHVybC5wYXNzd29yZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lID0gZW5jb2RlVVJJQ29tcG9uZW50KGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpbnMgPSBydWxlc1tpXTtcblxuICAgIGlmIChpbnNbNF0pIHVybFtpbnNbMV1dID0gdXJsW2luc1sxXV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHVybC5hdXRoID0gdXJsLnBhc3N3b3JkID8gdXJsLnVzZXJuYW1lICsnOicrIHVybC5wYXNzd29yZCA6IHVybC51c2VybmFtZTtcblxuICB1cmwub3JpZ2luID0gdXJsLnByb3RvY29sICE9PSAnZmlsZTonICYmIGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpICYmIHVybC5ob3N0XG4gICAgPyB1cmwucHJvdG9jb2wgKycvLycrIHVybC5ob3N0XG4gICAgOiAnbnVsbCc7XG5cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcblxuICByZXR1cm4gdXJsO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ30gQ29tcGlsZWQgdmVyc2lvbiBvZiB0aGUgVVJMLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaG9zdCA9IHVybC5ob3N0XG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID1cbiAgICBwcm90b2NvbCArXG4gICAgKCh1cmwucHJvdG9jb2wgJiYgdXJsLnNsYXNoZXMpIHx8IGlzU3BlY2lhbCh1cmwucHJvdG9jb2wpID8gJy8vJyA6ICcnKTtcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfSBlbHNlIGlmICh1cmwucGFzc3dvcmQpIHtcbiAgICByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfSBlbHNlIGlmIChcbiAgICB1cmwucHJvdG9jb2wgIT09ICdmaWxlOicgJiZcbiAgICBpc1NwZWNpYWwodXJsLnByb3RvY29sKSAmJlxuICAgICFob3N0ICYmXG4gICAgdXJsLnBhdGhuYW1lICE9PSAnLydcbiAgKSB7XG4gICAgLy9cbiAgICAvLyBBZGQgYmFjayB0aGUgZW1wdHkgdXNlcmluZm8sIG90aGVyd2lzZSB0aGUgb3JpZ2luYWwgaW52YWxpZCBVUkxcbiAgICAvLyBtaWdodCBiZSB0cmFuc2Zvcm1lZCBpbnRvIGEgdmFsaWQgb25lIHdpdGggYHVybC5wYXRobmFtZWAgYXMgaG9zdC5cbiAgICAvL1xuICAgIHJlc3VsdCArPSAnQCc7XG4gIH1cblxuICAvL1xuICAvLyBUcmFpbGluZyBjb2xvbiBpcyByZW1vdmVkIGZyb20gYHVybC5ob3N0YCB3aGVuIGl0IGlzIHBhcnNlZC4gSWYgaXQgc3RpbGxcbiAgLy8gZW5kcyB3aXRoIGEgY29sb24sIHRoZW4gYWRkIGJhY2sgdGhlIHRyYWlsaW5nIGNvbG9uIHRoYXQgd2FzIHJlbW92ZWQuIFRoaXNcbiAgLy8gcHJldmVudHMgYW4gaW52YWxpZCBVUkwgZnJvbSBiZWluZyB0cmFuc2Zvcm1lZCBpbnRvIGEgdmFsaWQgb25lLlxuICAvL1xuICBpZiAoaG9zdFtob3N0Lmxlbmd0aCAtIDFdID09PSAnOicgfHwgKHBvcnQudGVzdCh1cmwuaG9zdG5hbWUpICYmICF1cmwucG9ydCkpIHtcbiAgICBob3N0ICs9ICc6JztcbiAgfVxuXG4gIHJlc3VsdCArPSBob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsIi8vIFRoZSByZWdlbmVyYXRvciBydW50aW1lIGlzIG5lZWRlZCBzaW5jZSB0aGUgdGVzdCB1c2UgZnVuY3Rpb25zXG4vLyB3aXRoIHRoZSBhc3luYy9hd2FpdCBrZXl3b3Jkcy4gU2VlXG4vLyBodHRwczovL2JhYmVsanMuaW8vZG9jcy9lbi9iYWJlbC1wbHVnaW4tdHJhbnNmb3JtLXJlZ2VuZXJhdG9yXG5pbXBvcnQgJ3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZSdcblxuYmVmb3JlRWFjaCgoKSA9PiB7XG4gIC8vIENsZWFyIGxvY2FsU3RvcmFnZSBiZWZvcmUgZXZlcnkgdGVzdCB0byBwcmV2ZW50IHN0b3JlZCBVUkxzIHRvXG4gIC8vIGludGVyZmVyZSB3aXRoIG91ciBzZXR1cC5cbiAgbG9jYWxTdG9yYWdlLmNsZWFyKClcbn0pXG5cbnJlcXVpcmUoJy4vdGVzdC1jb21tb24nKVxucmVxdWlyZSgnLi90ZXN0LWJyb3dzZXItc3BlY2lmaWMnKVxucmVxdWlyZSgnLi90ZXN0LXBhcmFsbGVsLXVwbG9hZHMnKVxucmVxdWlyZSgnLi90ZXN0LXRlcm1pbmF0ZScpXG5yZXF1aXJlKCcuL3Rlc3QtZW5kLXRvLWVuZCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzeW5jIGZ1bmN0aW9uIGFzc2VydFVybFN0b3JhZ2UgKHVybFN0b3JhZ2UpIHtcbiAgLy8gSW4gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGVzdCwgdGhlIHN0b3JhZ2Ugc2hvdWxkIGJlIGVtcHR5LlxuICBsZXQgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG5cbiAgLy8gQWRkIGEgZmV3IHVwbG9hZHMgaW50byB0aGUgc3RvcmFnZVxuICBjb25zdCBrZXkxID0gYXdhaXQgdXJsU3RvcmFnZS5hZGRVcGxvYWQoJ2ZpbmdlcnByaW50QScsIHsgaWQ6IDEgfSlcbiAgY29uc3Qga2V5MiA9IGF3YWl0IHVybFN0b3JhZ2UuYWRkVXBsb2FkKCdmaW5nZXJwcmludEEnLCB7IGlkOiAyIH0pXG4gIGNvbnN0IGtleTMgPSBhd2FpdCB1cmxTdG9yYWdlLmFkZFVwbG9hZCgnZmluZ2VycHJpbnRCJywgeyBpZDogMyB9KVxuXG4gIGV4cGVjdCgvXnR1czo6ZmluZ2VycHJpbnRBOjovLnRlc3Qoa2V5MSkpLnRvQmUodHJ1ZSlcbiAgZXhwZWN0KC9edHVzOjpmaW5nZXJwcmludEE6Oi8udGVzdChrZXkyKSkudG9CZSh0cnVlKVxuICBleHBlY3QoL150dXM6OmZpbmdlcnByaW50Qjo6Ly50ZXN0KGtleTMpKS50b0JlKHRydWUpXG5cbiAgLy8gUXVlcnkgdGhlIGp1c3Qgc3RvcmVkIHVwbG9hZHMgaW5kaXZpZHVhbGx5XG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBzb3J0KHJlc3VsdClcbiAgZXhwZWN0KHJlc3VsdCkudG9FcXVhbChbXG4gICAgeyBpZDogMSwgdXJsU3RvcmFnZUtleToga2V5MSB9LFxuICAgIHsgaWQ6IDIsIHVybFN0b3JhZ2VLZXk6IGtleTIgfSxcbiAgXSlcblxuICByZXN1bHQgPSBhd2FpdCB1cmxTdG9yYWdlLmZpbmRVcGxvYWRzQnlGaW5nZXJwcmludCgnZmluZ2VycHJpbnRCJylcbiAgc29ydChyZXN1bHQpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW1xuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IHdlIGNhbiByZXRyaWV2ZSBhbGwgc3RvcmVkIHVwbG9hZHNcbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kQWxsVXBsb2FkcygpXG4gIHNvcnQocmVzdWx0KVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gICAgeyBpZDogMiwgdXJsU3RvcmFnZUtleToga2V5MiB9LFxuICAgIHsgaWQ6IDMsIHVybFN0b3JhZ2VLZXk6IGtleTMgfSxcbiAgXSlcblxuICAvLyBDaGVjayB0aGF0IGl0IGNhbiByZW1vdmUgYW4gdXBsb2FkIGFuZCB3aWxsIG5vdCByZXR1cm4gaXQgYmFja1xuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkyKVxuICBhd2FpdCB1cmxTdG9yYWdlLnJlbW92ZVVwbG9hZChrZXkzKVxuXG4gIHJlc3VsdCA9IGF3YWl0IHVybFN0b3JhZ2UuZmluZFVwbG9hZHNCeUZpbmdlcnByaW50KCdmaW5nZXJwcmludEEnKVxuICBleHBlY3QocmVzdWx0KS50b0VxdWFsKFtcbiAgICB7IGlkOiAxLCB1cmxTdG9yYWdlS2V5OiBrZXkxIH0sXG4gIF0pXG5cbiAgcmVzdWx0ID0gYXdhaXQgdXJsU3RvcmFnZS5maW5kVXBsb2Fkc0J5RmluZ2VycHJpbnQoJ2ZpbmdlcnByaW50QicpXG4gIGV4cGVjdChyZXN1bHQpLnRvRXF1YWwoW10pXG59XG5cbi8vIFNvcnQgdGhlIHJlc3VsdHMgZnJvbSB0aGUgVVJMIHN0b3JhZ2Ugc2luY2UgdGhlIG9yZGVyIGluIG5vdCBkZXRlcm1pbmlzdGljLlxuZnVuY3Rpb24gc29ydCAocmVzdWx0KSB7XG4gIHJlc3VsdC5zb3J0KChhLCBiKSA9PiBhLmlkIC0gYi5pZClcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXG5jb25zdCBpc0Jyb3dzZXIgID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbmNvbnN0IGlzTm9kZSAgICAgPSAhaXNCcm93c2VyXG5cbi8qKlxuICogT2J0YWluIGEgcGxhdGZvcm0gc3BlY2lmaWMgYnVmZmVyIG9iamVjdCwgd2hpY2ggY2FuIGJlXG4gKiBoYW5kbGVkIGJ5IHR1cy1qcy1jbGllbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEJsb2IgKHN0cikge1xuICBpZiAoaXNOb2RlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHN0cilcbiAgfVxuICByZXR1cm4gbmV3IEJsb2Ioc3RyLnNwbGl0KCcnKSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBwcm9taXNlIGFuZCBvYnRhaW4gdGhlIHJlc29sdmUvcmVqZWN0IGZ1bmN0aW9uc1xuICogb3V0c2lkZSBvZiB0aGUgUHJvbWlzZSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gZmxhdFByb21pc2UgKCkge1xuICBsZXQgcmVzb2x2ZUZuXG4gIGxldCByZWplY3RGblxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlc29sdmVGbiA9IHJlc29sdmVcbiAgICByZWplY3RGbiA9IHJlamVjdFxuICB9KVxuXG4gIHJldHVybiBbcCwgcmVzb2x2ZUZuLCByZWplY3RGbl1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBzcHktYWJsZSBmdW5jdGlvbiB3aGljaCByZXNvbHZlcyBhIFByb21pc2VcbiAqIG9uY2UgaXQgaXMgY2FsbGVkLlxuICovXG5mdW5jdGlvbiB3YWl0YWJsZUZ1bmN0aW9uIChuYW1lID0gJ2Z1bmMnKSB7XG4gIGNvbnN0IFtwcm9taXNlLCByZXNvbHZlXSA9IGZsYXRQcm9taXNlKClcbiAgY29uc3QgZm4gPSBqYXNtaW5lLmNyZWF0ZVNweShuYW1lLCByZXNvbHZlKS5hbmQuY2FsbFRocm91Z2goKVxuXG4gIGZuLnRvQmVDYWxsZWQgPSBwcm9taXNlXG4gIHJldHVybiBmblxufVxuXG4vKipcbiAqIENyZWF0ZSBhIFByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciB0aGUgc3BlY2lmaWVkIGR1cmF0aW9uLlxuICovXG5mdW5jdGlvbiB3YWl0IChkZWxheSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXksICd0aW1lZCBvdXQnKSlcbn1cblxuLyoqXG4gKiBUZXN0SHR0cFN0YWNrIGltcGxlbWVudHMgdGhlIEhUVFAgc3RhY2sgaW50ZXJmYWNlIGZvciB0dXMtanMtY2xpZW50XG4gKiBhbmQgY2FuIGJlIHVzZWQgdG8gYXNzZXJ0IG91dGdvaW5nIHJlcXVlc3RzIGFuZCByZXNwb25kIHdpdGggbW9jayBkYXRhLlxuICovXG5jbGFzcyBUZXN0SHR0cFN0YWNrIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuX3BlbmRpbmdSZXF1ZXN0cyA9IFtdXG4gICAgdGhpcy5fcGVuZGluZ1dhaXRzID0gW11cbiAgfVxuXG4gIGNyZWF0ZVJlcXVlc3QgKG1ldGhvZCwgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBUZXN0UmVxdWVzdChtZXRob2QsIHVybCwgKHJlcSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BlbmRpbmdXYWl0cy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5fcGVuZGluZ1dhaXRzLnNoaWZ0KClcbiAgICAgICAgaGFuZGxlcihyZXEpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wZW5kaW5nUmVxdWVzdHMucHVzaChyZXEpXG4gICAgfSlcbiAgfVxuXG4gIG5leHRSZXF1ZXN0ICgpIHtcbiAgICBpZiAodGhpcy5fcGVuZGluZ1JlcXVlc3RzLmxlbmd0aCA+PSAxKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuX3BlbmRpbmdSZXF1ZXN0cy5zaGlmdCgpKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy5fcGVuZGluZ1dhaXRzLnB1c2gocmVzb2x2ZSlcbiAgICB9KVxuICB9XG59XG5cbmNsYXNzIFRlc3RSZXF1ZXN0IHtcbiAgY29uc3RydWN0b3IgKG1ldGhvZCwgdXJsLCBvblJlcXVlc3RTZW5kKSB7XG4gICAgdGhpcy5tZXRob2QgPSBtZXRob2RcbiAgICB0aGlzLnVybCA9IHVybFxuICAgIHRoaXMucmVxdWVzdEhlYWRlcnMgPSB7fVxuICAgIHRoaXMuYm9keSA9IG51bGxcblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQgPSBvblJlcXVlc3RTZW5kXG4gICAgdGhpcy5fb25Qcm9ncmVzcyA9ICgpID0+IHt9O1xuXG4gICAgW3RoaXMuX3JlcXVlc3RQcm9taXNlLCB0aGlzLl9yZXNvbHZlUmVxdWVzdCwgdGhpcy5fcmVqZWN0UmVxdWVzdF0gPSBmbGF0UHJvbWlzZSgpXG4gIH1cblxuICBnZXRNZXRob2QgKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFxuICB9XG5cbiAgZ2V0VVJMICgpIHtcbiAgICByZXR1cm4gdGhpcy51cmxcbiAgfVxuXG4gIHNldEhlYWRlciAoaGVhZGVyLCB2YWx1ZSkge1xuICAgIHRoaXMucmVxdWVzdEhlYWRlcnNbaGVhZGVyXSA9IHZhbHVlXG4gIH1cblxuICBnZXRIZWFkZXIgKGhlYWRlcikge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3RIZWFkZXJzW2hlYWRlcl0gfHwgbnVsbFxuICB9XG5cbiAgc2V0UHJvZ3Jlc3NIYW5kbGVyIChwcm9ncmVzc0hhbmRsZXIpIHtcbiAgICB0aGlzLl9vblByb2dyZXNzID0gcHJvZ3Jlc3NIYW5kbGVyXG4gIH1cblxuICBzZW5kIChib2R5ID0gbnVsbCkge1xuICAgIHRoaXMuYm9keSA9IGJvZHlcblxuICAgIGlmIChib2R5KSB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzKDApXG4gICAgICB0aGlzLl9vblByb2dyZXNzKGJvZHkubGVuZ3RoIHx8IGJvZHkuc2l6ZSB8fCAwKVxuICAgIH1cblxuICAgIHRoaXMuX29uUmVxdWVzdFNlbmQodGhpcylcbiAgICByZXR1cm4gdGhpcy5fcmVxdWVzdFByb21pc2VcbiAgfVxuXG4gIGFib3J0ICgpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KG5ldyBFcnJvcigncmVxdWVzdCBhYm9ydGVkJykpXG4gIH1cblxuICBnZXRVbmRlcmx5aW5nT2JqZWN0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpXG4gIH1cblxuICByZXNwb25kV2l0aCAocmVzRGF0YSkge1xuICAgIHJlc0RhdGEucmVzcG9uc2VIZWFkZXJzID0gcmVzRGF0YS5yZXNwb25zZUhlYWRlcnMgfHwge31cblxuICAgIGNvbnN0IHJlcyA9IG5ldyBUZXN0UmVzcG9uc2UocmVzRGF0YSlcbiAgICB0aGlzLl9yZXNvbHZlUmVxdWVzdChyZXMpXG4gIH1cblxuICByZXNwb25zZUVycm9yIChlcnIpIHtcbiAgICB0aGlzLl9yZWplY3RSZXF1ZXN0KGVycilcbiAgfVxufVxuXG5jbGFzcyBUZXN0UmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvciAocmVzKSB7XG4gICAgdGhpcy5fcmVzcG9uc2UgPSByZXNcbiAgfVxuXG4gIGdldFN0YXR1cyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3BvbnNlLnN0YXR1c1xuICB9XG5cbiAgZ2V0SGVhZGVyIChoZWFkZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzcG9uc2UucmVzcG9uc2VIZWFkZXJzW2hlYWRlcl1cbiAgfVxuXG4gIGdldEJvZHkgKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNwb25zZS5yZXNwb25zZVRleHRcbiAgfVxuXG4gIGdldFVuZGVybHlpbmdPYmplY3QgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbm90IGltcGxlbWVudGVkJylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVGVzdEh0dHBTdGFjayxcbiAgd2FpdGFibGVGdW5jdGlvbixcbiAgd2FpdCxcbiAgZ2V0QmxvYixcbn1cbiIsImNvbnN0IGFzc2VydFVybFN0b3JhZ2UgPSByZXF1aXJlKCcuL2hlbHBlcnMvYXNzZXJ0VXJsU3RvcmFnZScpXG5jb25zdCB7IFRlc3RIdHRwU3RhY2ssIHdhaXRhYmxlRnVuY3Rpb24sIHdhaXQgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5jbGVhcigpXG4gIH0pXG5cbiAgZGVzY3JpYmUoJyNVcGxvYWQnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCByZXN1bWUgYW4gdXBsb2FkIGZyb20gYSBzdG9yZWQgdXJsJywgYXN5bmMgKCkgPT4ge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJyxcbiAgICAgIH0pKVxuXG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgY29uc3QgcHJldmlvdXNVcGxvYWRzID0gYXdhaXQgdXBsb2FkLmZpbmRQcmV2aW91c1VwbG9hZHMoKVxuICAgICAgZXhwZWN0KHByZXZpb3VzVXBsb2FkcykudG9FcXVhbChbe1xuICAgICAgICB1cGxvYWRVcmwgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJyxcbiAgICAgICAgdXJsU3RvcmFnZUtleTogJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycsXG4gICAgICB9XSlcbiAgICAgIHVwbG9hZC5yZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQocHJldmlvdXNVcGxvYWRzWzBdKVxuXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgoZmlsZSwgdXBsb2FkLm9wdGlvbnMpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAzLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDMpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSAtIDMpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgfSlcblxuICAgIGRlc2NyaWJlKCdzdG9yaW5nIG9mIHVwbG9hZCB1cmxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGZpbmdlcnByaW50ICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBzdGFydFVwbG9hZCAoKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBuZXcgQmxvYignaGVsbG8gd29ybGQnLnNwbGl0KCcnKSlcbiAgICAgICAgc3B5T24ob3B0aW9ucywgJ2ZpbmdlcnByaW50JykuYW5kLnJlc29sdmVUbygnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgIG9wdGlvbnMub25TdWNjZXNzID0gd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJylcblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgZGVsYXkgdG8gYWxsb3cgdGhlIFByb21pc2VzIHRvIHNldHRsZVxuICAgICAgICBhd2FpdCB3YWl0KDEwKVxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBmaW5pc2hVcGxvYWQgKCkge1xuICAgICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9XG5cbiAgICAgIGl0KCdzaG91bGQgc3RvcmUgYW5kIHJldGFpbiB3aXRoIGRlZmF1bHQgb3B0aW9ucycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IGZhbHNlXG4gICAgICAgIGF3YWl0IHN0YXJ0VXBsb2FkKClcblxuICAgICAgICBjb25zdCBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KDApXG4gICAgICAgIGV4cGVjdChrZXkuaW5kZXhPZigndHVzOjpmaW5nZXJwcmludGVkOjonKSkudG9CZSgwKVxuXG4gICAgICAgIGNvbnN0IHN0b3JlZFVwbG9hZCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSlcbiAgICAgICAgZXhwZWN0KHN0b3JlZFVwbG9hZC51cGxvYWRVcmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnNpemUpLnRvQmUoMTEpXG5cbiAgICAgICAgYXdhaXQgZmluaXNoVXBsb2FkKClcblxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShKU09OLnN0cmluZ2lmeShzdG9yZWRVcGxvYWQpKVxuICAgICAgfSlcblxuICAgICAgaXQoJ3Nob3VsZCBzdG9yZSBhbmQgcmVtb3ZlIHdpdGggb3B0aW9uIHJlbW92ZUZpbmdlcnByaW50T25TdWNjZXNzIHNldCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgb3B0aW9ucy5yZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA9IHRydWVcbiAgICAgICAgYXdhaXQgc3RhcnRVcGxvYWQoKVxuXG4gICAgICAgIGNvbnN0IGtleSA9IGxvY2FsU3RvcmFnZS5rZXkoMClcbiAgICAgICAgZXhwZWN0KGtleS5pbmRleE9mKCd0dXM6OmZpbmdlcnByaW50ZWQ6OicpKS50b0JlKDApXG5cbiAgICAgICAgY29uc3Qgc3RvcmVkVXBsb2FkID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKVxuICAgICAgICBleHBlY3Qoc3RvcmVkVXBsb2FkLnVwbG9hZFVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChzdG9yZWRVcGxvYWQuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgICBhd2FpdCBmaW5pc2hVcGxvYWQoKVxuICAgICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oa2V5KSkudG9CZShudWxsKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBkZWxldGUgdXBsb2FkIHVybHMgb24gYSA0WFgnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gbmV3IEJsb2IoJ2hlbGxvIHdvcmxkJy5zcGxpdCgnJykpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcblxuICAgICAgdXBsb2FkLnJlc3VtZUZyb21QcmV2aW91c1VwbG9hZCh7XG4gICAgICAgIHVwbG9hZFVybCAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgICB1cmxTdG9yYWdlS2V5OiAndHVzOjpmaW5nZXJwcmludGVkOjoxMzM3JyxcbiAgICAgIH0pXG5cbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCB3YWl0KDEwKVxuXG4gICAgICBleHBlY3QobG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpKS50b0JlKG51bGwpXG4gICAgfSlcblxuICAgIGRlc2NyaWJlKCd1cGxvYWRpbmcgZGF0YSBmcm9tIGEgUmVhZGVyJywgKCkgPT4ge1xuICAgICAgZnVuY3Rpb24gbWFrZVJlYWRlciAoY29udGVudCwgcmVhZFNpemUgPSBjb250ZW50Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCByZWFkZXIgPSB7XG4gICAgICAgICAgdmFsdWU6IGNvbnRlbnQuc3BsaXQoJycpLFxuICAgICAgICAgIHJlYWQgKCkge1xuICAgICAgICAgICAgbGV0IHZhbHVlXG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlXG4gICAgICAgICAgICBpZiAodGhpcy52YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZS5zbGljZSgwLCByZWFkU2l6ZSlcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudmFsdWUuc2xpY2UocmVhZFNpemUpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBkb25lID0gdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHZhbHVlLCBkb25lIH0pXG4gICAgICAgICAgfSxcbiAgICAgICAgICBjYW5jZWw6IHdhaXRhYmxlRnVuY3Rpb24oJ2NhbmNlbCcpLFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlYWRlclxuICAgICAgfVxuXG4gICAgICBhc3luYyBmdW5jdGlvbiBhc3NlcnRSZWFkZXJVcGxvYWQgKHsgcmVhZFNpemUsIGNodW5rU2l6ZSB9KSB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG1ha2VSZWFkZXIoJ2hlbGxvIHdvcmxkJywgcmVhZFNpemUpXG5cbiAgICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIGNodW5rU2l6ZSxcbiAgICAgICAgICBvblByb2dyZXNzICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25Qcm9ncmVzcycpLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICBmaW5nZXJwcmludCAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuICAgICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgZXhwZWN0KG9wdGlvbnMuZmluZ2VycHJpbnQpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKHJlYWRlciwgdXBsb2FkLm9wdGlvbnMpXG5cbiAgICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSh1bmRlZmluZWQpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1EZWZlci1MZW5ndGgnXSkudG9CZSgxKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDExKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblByb2dyZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIG51bGwpXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMTEpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkpLnRvQmUobnVsbClcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICB9XG5cbiAgICAgIGl0KCdzaG91bGQgdXBsb2FkIGRhdGEnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGFzc2VydFJlYWRlclVwbG9hZCh7IGNodW5rU2l6ZTogMTAwLCByZWFkU2l6ZTogMTAwIH0pXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHJlYWQgbXVsdGlwbGUgdGltZXMgZnJvbSB0aGUgcmVhZGVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCBhc3NlcnRSZWFkZXJVcGxvYWQoeyBjaHVua1NpemU6IDEwMCwgcmVhZFNpemU6IDYgfSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIG11bHRpcGxlIFBBVENIIHJlcXVlc3RzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBtYWtlUmVhZGVyKCdoZWxsbyB3b3JsZCcsIDEpXG5cbiAgICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGh0dHBTdGFjayAgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgOiA2LFxuICAgICAgICAgIG9uUHJvZ3Jlc3MgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblByb2dyZXNzJyksXG4gICAgICAgICAgb25TdWNjZXNzICAgICAgICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICAgIGZpbmdlcnByaW50ICgpIHt9LFxuICAgICAgICAgIHVwbG9hZExlbmd0aERlZmVycmVkOiB0cnVlLFxuICAgICAgICB9XG4gICAgICAgIHNweU9uKG9wdGlvbnMsICdmaW5nZXJwcmludCcpLmFuZC5yZXNvbHZlVG8oJ2ZpbmdlcnByaW50ZWQnKVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBleHBlY3Qob3B0aW9ucy5maW5nZXJwcmludCkudG9IYXZlQmVlbkNhbGxlZFdpdGgocmVhZGVyLCB1cGxvYWQub3B0aW9ucylcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKHVuZGVmaW5lZClcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLURlZmVyLUxlbmd0aCddKS50b0JlKDEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5sZW5ndGgpLnRvQmUoNilcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblByb2dyZXNzLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNiwgbnVsbClcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNilcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ10pLnRvQmUoJ2FwcGxpY2F0aW9uL29mZnNldCtvY3RldC1zdHJlYW0nKVxuICAgICAgICBleHBlY3QocmVxLmJvZHkubGVuZ3RoKS50b0JlKDUpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgxMSlcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keSkudG9CZShudWxsKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgdGhlIFBPU1QgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gd29ybGQnLCAxKVxuXG4gICAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBodHRwU3RhY2sgICAgICAgICAgIDogdGVzdFN0YWNrLFxuICAgICAgICAgIGVuZHBvaW50ICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICAgIGNodW5rU2l6ZSAgICAgICAgICAgOiAxMSxcbiAgICAgICAgICByZXRyeURlbGF5cyAgICAgICAgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgcmV0cnkgdGhlIGZpcnN0IFBBVENIIHJlcXVlc3QnLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG1ha2VSZWFkZXIoJ2hlbGxvIHdvcmxkJywgMSlcblxuICAgICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCAgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogMTEsXG4gICAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3MgICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgTG9jYXRpb246ICcvZmlsZXMvZm9vJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIHJldHJ5IGZvbGxvd2luZyBQQVRDSCByZXF1ZXN0cycsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gd29ybGQgdGhlcmUhJylcblxuICAgICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgICBlbmRwb2ludCAgICAgICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgICBjaHVua1NpemUgICAgICAgICAgIDogNixcbiAgICAgICAgICByZXRyeURlbGF5cyAgICAgICAgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICAgIG9uU3VjY2VzcyAoKSB7fSxcbiAgICAgICAgICB1cGxvYWRMZW5ndGhEZWZlcnJlZDogdHJ1ZSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKHJlYWRlciwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMixcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTgpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTgsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICB9KVxuXG4gICAgICBpdCgnc2hvdWxkIGNhbmNlbCB0aGUgcmVhZGVyIHdoZW4gYWJvcnRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbWFrZVJlYWRlcignaGVsbG8gdGhlcmUgd29ybGQnKVxuXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrICAgICAgICAgICA6IG5ldyBUZXN0SHR0cFN0YWNrKCksXG4gICAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgICAgY2h1bmtTaXplICAgICAgICAgICA6IDYsXG4gICAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgICBvblN1Y2Nlc3MgKCkge30sXG4gICAgICAgICAgdXBsb2FkTGVuZ3RoRGVmZXJyZWQ6IHRydWUsXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChyZWFkZXIsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgLy8gV2Ugd2FpdCB1bnRpbCB0aGUgZmlyc3QgcmVxdWVzdCBhcnJpdmVzLCBzbyB0aGF0IHRoZSBmaXJzdCBwcm9taXNlcyBoYXZlIHJlc29sdmVkLlxuICAgICAgICBhd2FpdCBvcHRpb25zLmh0dHBTdGFjay5uZXh0UmVxdWVzdCgpXG5cbiAgICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgICBhd2FpdCByZWFkZXIuY2FuY2VsLnRvQmVDYWxsZWRcbiAgICAgICAgZXhwZWN0KHJlYWRlci5jYW5jZWwpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgZGVzY3JpYmUoJ3Jlc29sdmluZyBvZiBVUklzJywgKCkgPT4ge1xuICAgICAgLy8gRGlzYWJsZSB0aGVzZSB0ZXN0cyBmb3IgSUUgMTAgYW5kIDExIGJlY2F1c2UgaXQncyBub3QgcG9zc2libGUgdG8gb3ZlcndyaXRlXG4gICAgICAvLyB0aGUgbmF2aWdhdG9yLnByb2R1Y3QgcHJvcGVydHkuXG4gICAgICBjb25zdCBpc0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdUcmlkZW50LycpID4gMFxuICAgICAgaWYgKGlzSUUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1NraXBwaW5nIHRlc3RzIGZvciBSZWFjdCBOYXRpdmUgaW4gSW50ZXJuZXQgRXhwbG9yZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsUHJvZHVjdCA9IG5hdmlnYXRvci5wcm9kdWN0XG5cbiAgICAgIGJlZm9yZUVhY2goKCkgPT4ge1xuICAgICAgICBqYXNtaW5lLkFqYXguaW5zdGFsbCgpXG4gICAgICAgIC8vIFNpbXVsYXRlIFJlYWN0IE5hdGl2ZSBlbnZpcm9ubWVudCB0byBlbmFibGUgVVJJcyBhcyBpbnB1dCBvYmplY3RzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF2aWdhdG9yLCAncHJvZHVjdCcsIHtcbiAgICAgICAgICB2YWx1ZSAgICAgICA6ICdSZWFjdE5hdGl2ZScsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9KVxuICAgICAgfSlcblxuICAgICAgYWZ0ZXJFYWNoKCgpID0+IHtcbiAgICAgICAgamFzbWluZS5BamF4LnVuaW5zdGFsbCgpXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuYXZpZ2F0b3IsICdwcm9kdWN0Jywge1xuICAgICAgICAgIHZhbHVlICAgICAgIDogb3JpZ2luYWxQcm9kdWN0LFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfSlcbiAgICAgIH0pXG5cbiAgICAgIGl0KCdzaG91bGQgdXBsb2FkIGEgZmlsZSBmcm9tIGFuIFVSSScsIGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IHtcbiAgICAgICAgICB1cmk6ICdmaWxlOi8vL215L2ZpbGUuZGF0JyxcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgICAvLyBXYWl0IGEgc2hvcnQgaW50ZXJ2YWwgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIFhIUiBoYXMgYmVlbiBzZW50LlxuICAgICAgICBhd2FpdCB3YWl0KDApXG5cbiAgICAgICAgbGV0IHJlcSA9IGphc21pbmUuQWpheC5yZXF1ZXN0cy5tb3N0UmVjZW50KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2ZpbGU6Ly8vbXkvZmlsZS5kYXQnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnR0VUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXNwb25zZVR5cGUpLnRvQmUoJ2Jsb2InKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDAsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAzLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVzcG9uc2U6IG5ldyBCbG9iKCdoZWxsbyB3b3JsZCcuc3BsaXQoJycpKSxcbiAgICAgICAgfSlcblxuICAgICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG5cbiAgICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAgIExvY2F0aW9uOiAnL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9KVxuXG4gICAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1PZmZzZXQnXSkudG9CZSgwKVxuICAgICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDExKVxuXG4gICAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pXG5cbiAgICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICB9KVxuXG4gICAgICBpdChcInNob3VsZCBlbWl0IGFuIGVycm9yIGlmIGl0IGNhbid0IHJlc29sdmUgdGhlIFVSSVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICAgICAgdXJpOiAnZmlsZTovLy9teS9maWxlLmRhdCcsXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBlbmRwb2ludDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgICAgb25FcnJvciA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgICAgLy8gV2FpdCBhIHNob3J0IGludGVydmFsIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBYSFIgaGFzIGJlZW4gc2VudC5cbiAgICAgICAgYXdhaXQgd2FpdCgwKVxuXG4gICAgICAgIGNvbnN0IHJlcSA9IGphc21pbmUuQWpheC5yZXF1ZXN0cy5tb3N0UmVjZW50KClcbiAgICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2ZpbGU6Ly8vbXkvZmlsZS5kYXQnKVxuICAgICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnR0VUJylcbiAgICAgICAgZXhwZWN0KHJlcS5yZXNwb25zZVR5cGUpLnRvQmUoJ2Jsb2InKVxuXG4gICAgICAgIHJlcS5yZXNwb25zZUVycm9yKClcblxuICAgICAgICBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuICAgICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoJ3R1czogY2Fubm90IGZldGNoIGBmaWxlLnVyaWAgYXMgQmxvYiwgbWFrZSBzdXJlIHRoZSB1cmkgaXMgY29ycmVjdCBhbmQgYWNjZXNzaWJsZS4gW29iamVjdCBPYmplY3RdJykpXG4gICAgICB9KVxuICAgIH0pXG4gIH0pXG5cbiAgZGVzY3JpYmUoJyNMb2NhbFN0b3JhZ2VVcmxTdG9yYWdlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYWxsb3cgc3RvcmluZyBhbmQgcmV0cmlldmluZyB1cGxvYWRzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgYXNzZXJ0VXJsU3RvcmFnZSh0dXMuZGVmYXVsdE9wdGlvbnMudXJsU3RvcmFnZSlcbiAgICB9KVxuICB9KVxufSlcbiIsImNvbnN0IHsgVGVzdEh0dHBTdGFjaywgd2FpdGFibGVGdW5jdGlvbiwgd2FpdCwgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuLy8gVW5jb21tZW50IHRvIGVuYWJsZSBkZWJ1ZyBsb2cgZnJvbSB0dXMtanMtY2xpZW50XG4vLyB0dXMuZW5hYmxlRGVidWdMb2coKTtcblxuZGVzY3JpYmUoJ3R1cycsICgpID0+IHtcbiAgZGVzY3JpYmUoJyNpc1N1cHBvcnRlZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIGJlIHRydWUnLCAoKSA9PiB7XG4gICAgICBleHBlY3QodHVzLmlzU3VwcG9ydGVkKS50b0JlKHRydWUpXG4gICAgfSlcbiAgfSlcblxuICBkZXNjcmliZSgnI1VwbG9hZCcsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHRocm93IGlmIG5vIGVycm9yIGhhbmRsZXIgaXMgYXZhaWxhYmxlJywgKCkgPT4ge1xuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQobnVsbClcbiAgICAgIGV4cGVjdCh1cGxvYWQuc3RhcnQuYmluZCh1cGxvYWQpKS50b1Rocm93RXJyb3IoJ3R1czogbm8gZmlsZSBvciBzdHJlYW0gdG8gdXBsb2FkIHByb3ZpZGVkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBpZiBubyBlbmRwb2ludCBhbmQgdXBsb2FkIFVSTCBpcyBwcm92aWRlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlKVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiBuZWl0aGVyIGFuIGVuZHBvaW50IG9yIGFuIHVwbG9hZCBVUkwgaXMgcHJvdmlkZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHVwbG9hZCBhIGZpbGUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBoZWFkZXJzICA6IHtcbiAgICAgICAgICBDdXN0b206ICdibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgIGZvbyAgICAgOiAnaGVsbG8nLFxuICAgICAgICAgIGJhciAgICAgOiAnd29ybGQnLFxuICAgICAgICAgIG5vbmxhdGluOiAnc8WCb8WEY2UnLFxuICAgICAgICAgIG51bWJlciAgOiAxMDAsXG4gICAgICAgIH0sXG4gICAgICAgIHdpdGhDcmVkZW50aWFsczogdHJ1ZSxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcbiAgICAgIC8vIGlmIChpc0Jyb3dzZXIpIGV4cGVjdChyZXEud2l0aENyZWRlbnRpYWxzKS50b0JlKHRydWUpO1xuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmUoJ2ZvbyBhR1ZzYkc4PSxiYXIgZDI5eWJHUT0sbm9ubGF0aW4gYzhXQ2I4V0VZMlU9LG51bWJlciBNVEF3JylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSlcbiAgICAgIC8vIGlmIChpc0Jyb3dzZXIpIGV4cGVjdChyZXEud2l0aENyZWRlbnRpYWxzKS50b0JlKHRydWUpO1xuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gdXBsb2FkIGlmIHJlc3VtaW5nIGZhaWxzJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWRVcmw6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL3Jlc3VtaW5nJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDExKVxuXG4gICAgICAvLyBUaGUgdXBsb2FkIFVSTCBzaG91bGQgYmUgY2xlYXJlZCB3aGVuIHR1cy1qcy5jbGllbnQgdHJpZXMgdG8gY3JlYXRlIGEgbmV3IHVwbG9hZC5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKG51bGwpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgY3JlYXRlIGFuIHVwbG9hZCB1c2luZyB0aGUgY3JlYXRpb24td2l0aC1kYXRhIGV4dGVuc2lvbicsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiB0cnVlLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvbkNodW5rQ29tcGxldGUgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgICAgICAgICAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkNodW5rQ29tcGxldGUnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uICAgICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBjcmVhdGUgYW4gdXBsb2FkIHdpdGggcGFydGlhbCBkYXRhIGFuZCBjb250aW51ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgICAgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgdXBsb2FkRGF0YUR1cmluZ0NyZWF0aW9uOiB0cnVlLFxuICAgICAgICBjaHVua1NpemUgICAgICAgICAgICAgICA6IDYsXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uQ2h1bmtDb21wbGV0ZSAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgICAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cblxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQ2h1bmtDb21wbGV0ZScpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoMTEpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb24gICAgICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgLy8gT25jZSB0aGUgc2Vjb25kIHJlcXVlc3QgaGFzIGJlZW4gc2VudCwgdGhlIHByb2dyZXNzIGhhbmRsZXIgbXVzdCBoYXZlIGJlZW4gaW52b2tlZC5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDYsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg2LCA2LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2Vzcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoNilcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDUpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbiAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExLCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KFwic2hvdWxkIGFkZCB0aGUgcmVxdWVzdCdzIGJvZHkgYW5kIElEIHRvIGVycm9yc1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIGFkZFJlcXVlc3RJZDogdHJ1ZSxcbiAgICAgICAgcmV0cnlEZWxheXMgOiBudWxsLFxuICAgICAgICBvbkVycm9yICAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgY29uc3QgcmVxSWQgPSByZXEucmVxdWVzdEhlYWRlcnNbJ1gtUmVxdWVzdC1JRCddXG4gICAgICBleHBlY3QodHlwZW9mIHJlcUlkKS50b0JlKCdzdHJpbmcnKVxuICAgICAgZXhwZWN0KHJlcUlkLmxlbmd0aCkudG9CZSgzNilcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgOiA1MDAsXG4gICAgICAgIHJlc3BvbnNlVGV4dDogJ3NlcnZlcl9lcnJvcicsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QoZXJyLm1lc3NhZ2UpLnRvQmUoYHR1czogdW5leHBlY3RlZCByZXNwb25zZSB3aGlsZSBjcmVhdGluZyB1cGxvYWQsIG9yaWdpbmF0ZWQgZnJvbSByZXF1ZXN0IChtZXRob2Q6IFBPU1QsIHVybDogaHR0cDovL3R1cy5pby91cGxvYWRzLCByZXNwb25zZSBjb2RlOiA1MDAsIHJlc3BvbnNlIHRleHQ6IHNlcnZlcl9lcnJvciwgcmVxdWVzdCBpZDogJHtyZXFJZH0pYClcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXF1ZXN0KS50b0JlRGVmaW5lZCgpXG4gICAgICBleHBlY3QoZXJyLm9yaWdpbmFsUmVzcG9uc2UpLnRvQmVEZWZpbmVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBpbnZva2UgdGhlIHJlcXVlc3QgYW5kIHJlc3BvbnNlIGNhbGxiYWNrcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgdXBsb2FkVXJsOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycsXG4gICAgICAgIG9uQmVmb3JlUmVxdWVzdCAocmVxKSB7XG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRVUkwoKSkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycpXG4gICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZSgnSEVBRCcpXG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJSZXNwb25zZSAocmVxLCByZXMpIHtcbiAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgICAgICBleHBlY3QocmVxLmdldE1ldGhvZCgpKS50b0JlKCdIRUFEJylcbiAgICAgICAgICBleHBlY3QocmVzLmdldFN0YXR1cygpKS50b0JlKDIwNClcbiAgICAgICAgICBleHBlY3QocmVzLmdldEhlYWRlcignVXBsb2FkLU9mZnNldCcpKS50b0JlKDExKVxuICAgICAgICB9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uQmVmb3JlUmVxdWVzdCcpXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25BZnRlclJlc3BvbnNlJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkJlZm9yZVJlcXVlc3QpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25BZnRlclJlc3BvbnNlKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBhbiBlcnJvciBpZiByZXN1bWluZyBmYWlscyBhbmQgbm8gZW5kcG9pbnQgaXMgcHJvdmlkZWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9yZXN1bWluZycsXG4gICAgICAgIG9uRXJyb3IgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgfSlcblxuICAgICAgY29uc3QgZXJyID0gYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChlcnIubWVzc2FnZSkudG9CZSgndHVzOiB1bmFibGUgdG8gcmVzdW1lIHVwbG9hZCAobmV3IHVwbG9hZCBjYW5ub3QgYmUgY3JlYXRlZCB3aXRob3V0IGFuIGVuZHBvaW50KSwgb3JpZ2luYXRlZCBmcm9tIHJlcXVlc3QgKG1ldGhvZDogSEVBRCwgdXJsOiBodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcsIHJlc3BvbnNlIGNvZGU6IDQwNCwgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXNvbHZlIHJlbGF0aXZlIFVSTHMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW86MTA4MC9maWxlcy8nLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pbzoxMDgwL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy8vbG9jYWxob3N0L3VwbG9hZHMvZm9vJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL2xvY2FsaG9zdC91cGxvYWRzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwOi8vbG9jYWxob3N0L3VwbG9hZHMvZm9vJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB1cGxvYWQgYSBmaWxlIGluIGNodW5rcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgY2h1bmtTaXplOiA3LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvbkNodW5rQ29tcGxldGUgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgxMSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL3VwbG9hZHMvYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg0KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25DaHVua0NvbXBsZXRlKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCg3LCA3LCAxMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoNCwgMTEsIDExKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGFkZCB0aGUgb3JpZ2luYWwgcmVxdWVzdCB0byBlcnJvcnMnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICByZXRyeURlbGF5czogbnVsbCxcbiAgICAgICAgb25FcnJvciAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiA1MDAsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIEN1c3RvbTogJ2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZShudWxsKVxuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKCd0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogNTAwLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlcXVlc3QpLnRvQmVEZWZpbmVkKClcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXNwb25zZSkudG9CZURlZmluZWQoKVxuICAgICAgZXhwZWN0KGVyci5vcmlnaW5hbFJlc3BvbnNlLmdldEhlYWRlcignQ3VzdG9tJykpLnRvQmUoJ2JsYXJnaCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgb25seSBjcmVhdGUgYW4gdXBsb2FkIGZvciBlbXB0eSBmaWxlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCcnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uU3VjY2Vzczogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSgwKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZW1wdHknLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmVzdW1lIGEgZmluaXNoZWQgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvblByb2dyZXNzICgpIHt9LFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICB1cGxvYWRVcmw6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnLFxuICAgICAgfVxuICAgICAgc3B5T24ob3B0aW9ucywgJ29uUHJvZ3Jlc3MnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvcmVzdW1pbmcnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6ICcxMScsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAnMTEnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHJlc3VtZSBhbiB1cGxvYWQgZnJvbSBhIHNwZWNpZmllZCB1cmwnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIHVwbG9hZFVybDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgZmluZ2VycHJpbnQgKCkge30sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnZmluZ2VycHJpbnQnKS5hbmQucmVzb2x2ZVRvKCdmaW5nZXJwcmludGVkJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLmZpbmdlcnByaW50KS50b0hhdmVCZWVuQ2FsbGVkKClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDMpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSgxMSAtIDMpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KHVwbG9hZC51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkJylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXN1bWUgYSBwcmV2aW91c2x5IHN0YXJ0ZWQgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBvblN1Y2Nlc3M6IHdhaXRhYmxlRnVuY3Rpb24oJ29uU3VjY2VzcycpLFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9ibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby91cGxvYWRzL2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgb3ZlcnJpZGUgdGhlIFBBVENIIG1ldGhvZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgICAgICAgICA6ICdodHRwOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICB1cGxvYWRVcmwgICAgICAgICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnLFxuICAgICAgICBvdmVycmlkZVBhdGNoTWV0aG9kOiB0cnVlLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy91cGxvYWQnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1gtSFRUUC1NZXRob2QtT3ZlcnJpZGUnXSkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZW1pdCBhbiBlcnJvciBpZiBhbiB1cGxvYWQgaXMgbG9ja2VkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgdXBsb2FkVXJsICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcsXG4gICAgICAgIG9uRXJyb3IgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL3VwbG9hZCcpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDIzLCAvLyBMb2NrZWRcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChuZXcgRXJyb3IoJ3R1czogdXBsb2FkIGlzIGN1cnJlbnRseSBsb2NrZWQ7IHJldHJ5IGxhdGVyLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBIRUFELCB1cmw6IGh0dHA6Ly90dXMuaW8vZmlsZXMvdXBsb2FkLCByZXNwb25zZSBjb2RlOiA0MjMsIHJlc3BvbnNlIHRleHQ6ICwgcmVxdWVzdCBpZDogbi9hKScpKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIGVtaXQgYW4gZXJyb3IgaWYgbm8gTG9jYXRpb24gaGVhZGVyIGlzIHByZXNlbnRlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vdXBsb2FkcycsXG4gICAgICAgIG9uRXJyb3IgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICAgIHJldHJ5RGVsYXlzOiBudWxsLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgY29uc3QgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAvLyBUaGUgTG9jYXRpb24gaGVhZGVyIGlzIG9taXR0ZWQgb24gcHVycG9zZSBoZXJlXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwMSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25FcnJvci50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKG5ldyBFcnJvcigndHVzOiBpbnZhbGlkIG9yIG1pc3NpbmcgTG9jYXRpb24gaGVhZGVyLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHA6Ly90dXMuaW8vdXBsb2FkcywgcmVzcG9uc2UgY29kZTogMjAxLCByZXNwb25zZSB0ZXh0OiAsIHJlcXVlc3QgaWQ6IG4vYSknKSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBpZiByZXRyeURlbGF5cyBpcyBub3QgYW4gYXJyYXknLCAoKSA9PiB7XG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwge1xuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly9lbmRwb2ludC8nLFxuICAgICAgICByZXRyeURlbGF5czogNDQsXG4gICAgICB9KVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiB0aGUgYHJldHJ5RGVsYXlzYCBvcHRpb24gbXVzdCBlaXRoZXIgYmUgYW4gYXJyYXkgb3IgbnVsbCcpXG4gICAgfSlcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IHJldHJpZXMgaWYgdGhlXG4gICAgLy8gcmVzcG9uc2UgaGFzIHRoZSBjb2RlIDUwMCBJbnRlcm5hbCBFcnJvciwgNDIzIExvY2tlZCBvciA0MDkgQ29uZmxpY3QuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB0aGUgdXBsb2FkJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA5LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICAvLyBUaGlzIHRlc3RzIGVuc3VyZXMgdGhhdCB0dXMtanMtY2xpZW50IGNvcnJlY3RseSByZXRyaWVzIGlmIHRoZVxuICAgIC8vIHJldHVybiB2YWx1ZSBvZiBvblNob3VsZFJldHJ5IGlzIHRydWUuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB0aGUgdXBsb2FkIHdoZW4gb25TaG91bGRSZXRyeSBzcGVjaWZpZWQgYW5kIHJldHVybnMgdHJ1ZScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50ICAgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIHJldHJ5RGVsYXlzICA6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzICAgIDogd2FpdGFibGVGdW5jdGlvbignb25TdWNjZXNzJyksXG4gICAgICAgIG9uU2hvdWxkUmV0cnk6ICgpID0+IHRydWUsXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblNob3VsZFJldHJ5JykuYW5kLmNhbGxUaHJvdWdoKClcbiAgICAgIHNweU9uKHR1cy5VcGxvYWQucHJvdG90eXBlLCAnX2VtaXRFcnJvcicpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAwLFxuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNDA5LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMTEsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblN1Y2Nlc3MpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICBjb25zdCBbZXJyb3IxXSAgPSB1cGxvYWQuX2VtaXRFcnJvci5jYWxscy5hcmdzRm9yKDApXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblNob3VsZFJldHJ5KS50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkuY2FsbHMuYXJnc0ZvcigwKSkudG9FcXVhbChbZXJyb3IxLCAwLCB1cGxvYWQub3B0aW9uc10pXG4gICAgICBjb25zdCBbZXJyb3IyXSA9IHVwbG9hZC5fZW1pdEVycm9yLmNhbGxzLmFyZ3NGb3IoMSlcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU2hvdWxkUmV0cnkuY2FsbHMuYXJnc0ZvcigxKSkudG9FcXVhbChbZXJyb3IyLCAxLCB1cGxvYWQub3B0aW9uc10pXG4gICAgfSlcblxuICAgIC8vIFRoaXMgdGVzdHMgZW5zdXJlcyB0aGF0IHR1cy1qcy1jbGllbnQgY29ycmVjdGx5IGFib3J0cyBpZiB0aGVcbiAgICAvLyByZXR1cm4gdmFsdWUgb2Ygb25TaG91bGRSZXRyeSBpcyBmYWxzZS5cbiAgICBpdCgnc2hvdWxkIG5vdCByZXRyeSB0aGUgdXBsb2FkIHdoZW4gY2FsbGJhY2sgc3BlY2lmaWVkIGFuZCByZXR1cm5zIGZhbHNlJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXMgIDogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvblN1Y2Nlc3MgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgICAgb25FcnJvciAgICAgIDogd2FpdGFibGVGdW5jdGlvbignb25FcnJvcicpLFxuICAgICAgICBvblNob3VsZFJldHJ5OiAoKSA9PiBmYWxzZSxcbiAgICAgIH1cblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAvLyBUaGUgZXJyb3IgY2FsbGJhY2sgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciB0aGUgZmlyc3QgZXJyb3IgcmVzcG9uc2UuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0cnkgaWYgdGhlIGVycm9yIGhhcyBub3QgYmVlbiBjYXVzZWQgYnkgYSByZXF1ZXN0JywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjayAgOiBuZXcgVGVzdEh0dHBTdGFjaygpLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTAsIDEwXSxcbiAgICAgICAgb25TdWNjZXNzICgpIHt9LFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25TdWNjZXNzJylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHNweU9uKHVwbG9hZCwgJ19jcmVhdGVVcGxvYWQnKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgYXdhaXQgd2FpdCgyMDApXG5cbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdjdXN0b20gZXJyb3InKVxuICAgICAgdXBsb2FkLl9lbWl0RXJyb3IoZXJyb3IpXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQuX2NyZWF0ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZFRpbWVzKDEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkV2l0aChlcnJvcilcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2Vzcykubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgcmV0cnlpbmcgYWZ0ZXIgYWxsIGRlbGF5cyBoYXZlIGJlZW4gdXNlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMF0sXG4gICAgICAgIG9uU3VjY2VzcyAoKSB7fSxcbiAgICAgICAgb25FcnJvciAgICA6IHdhaXRhYmxlRnVuY3Rpb24oJ29uRXJyb3InKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblN1Y2Nlc3MnKVxuXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgdXBsb2FkLnN0YXJ0KClcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICAvLyBUaGUgZXJyb3IgY2FsbGJhY2sgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciB0aGUgZmlyc3QgZXJyb3IgcmVzcG9uc2UuXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vbkVycm9yLnRvQmVDYWxsZWRcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25TdWNjZXNzKS5ub3QudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkVycm9yKS50b0hhdmVCZWVuQ2FsbGVkVGltZXMoMSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCBzdG9wIHJldHJ5aW5nIHdoZW4gdGhlIGFib3J0IGZ1bmN0aW9uIGlzIGNhbGxlZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMF0sXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICB9XG5cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGNvbnN0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy8nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuXG4gICAgICBzcHlPbih1cGxvYWQsICdzdGFydCcpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIHVwbG9hZC5hYm9ydCgpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCksXG4gICAgICAgIHdhaXQoMTAwKSxcbiAgICAgIF0pXG5cbiAgICAgIGV4cGVjdChyZXN1bHQpLnRvQmUoJ3RpbWVkIG91dCcpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgc3RvcCB1cGxvYWQgd2hlbiB0aGUgYWJvcnQgZnVuY3Rpb24gaXMgY2FsbGVkIGR1cmluZyBhIGNhbGxiYWNrJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIGNodW5rU2l6ZTogNSxcbiAgICAgICAgb25DaHVua0NvbXBsZXRlICgpIHtcbiAgICAgICAgICB1cGxvYWQuYWJvcnQoKVxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgbGV0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzLycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJy9maWxlcy9mb28nLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KCksXG4gICAgICAgIHdhaXQoMjAwKSxcbiAgICAgIF0pXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCd0aW1lZCBvdXQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgdXBsb2FkIHdoZW4gdGhlIGFib3J0IGZ1bmN0aW9uIGlzIGNhbGxlZCBkdXJpbmcgdGhlIFBPU1QgcmVxdWVzdCcsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2s6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgOiAnaHR0cDovL3R1cy5pby9maWxlcy8nLFxuICAgICAgICBvbkVycm9yICgpIHt9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25FcnJvcicpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICB0ZXN0U3RhY2submV4dFJlcXVlc3QoKSxcbiAgICAgICAgd2FpdCgyMDApLFxuICAgICAgXSlcblxuICAgICAgZXhwZWN0KG9wdGlvbnMub25FcnJvcikubm90LnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgICAgZXhwZWN0KHJlc3VsdCkudG9CZSgndGltZWQgb3V0JylcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXNldCB0aGUgYXR0ZW1wdCBjb3VudGVyIGlmIGFuIHVwbG9hZCBwcm9jZWVkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgIDogdGVzdFN0YWNrLFxuICAgICAgICBlbmRwb2ludCAgIDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMF0sXG4gICAgICAgIG9uRXJyb3IgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvblN1Y2Nlc3MnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkVycm9yJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiAxMSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IG9wdGlvbnMub25TdWNjZXNzLnRvQmVDYWxsZWRcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uRXJyb3IpLm5vdC50b0hhdmVCZWVuQ2FsbGVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uU3VjY2VzcykudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcbiAgfSlcbn0pXG4iLCJjb25zdCBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJylcbmNvbnN0IHsgZ2V0QmxvYiB9ID0gcmVxdWlyZSgnLi9oZWxwZXJzL3V0aWxzJylcbmNvbnN0IHR1cyA9IHJlcXVpcmUoJy4uLy4uJylcblxuLy8gVGVzdCB0aW1lb3V0IGZvciBlbmQtdG8tZW5kIHRlc3RzIHdoZW4gdXBsb2FkaW5nIHRvIHJlYWwgc2VydmVyLlxuY29uc3QgRU5EX1RPX0VORF9USU1FT1VUID0gMjAgKiAxMDAwXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdlbmQtdG8tZW5kJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdXBsb2FkIHRvIGEgcmVhbCB0dXMgc2VydmVyJywgYXN5bmMgKCkgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgZmlsZSA9IGdldEJsb2IoJ2hlbGxvIHdvcmxkJylcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICBlbmRwb2ludDogJ2h0dHBzOi8vdHVzZC50dXNkZW1vLm5ldC9maWxlcy8nLFxuICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICBub25sYXRpbjogJ3PFgm/FhGNlJyxcbiAgICAgICAgICAgIG51bWJlciAgOiAxMDAsXG4gICAgICAgICAgICBmaWxlbmFtZTogJ2hlbGxvLnR4dCcsXG4gICAgICAgICAgICBmaWxldHlwZTogJ3RleHQvcGxhaW4nLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25TdWNjZXNzICgpIHtcbiAgICAgICAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b01hdGNoKC9eaHR0cHM6XFwvXFwvdHVzZFxcLnR1c2RlbW9cXC5uZXRcXC9maWxlc1xcLy8pXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVXBsb2FkIFVSTDonLCB1cGxvYWQudXJsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICAgICAgcmVzb2x2ZSh1cGxvYWQpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBvbkVycm9yIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgICAgfSxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICAgIHVwbG9hZC5zdGFydCgpXG4gICAgICB9KVxuICAgICAgICAudGhlbih2YWxpZGF0ZVVwbG9hZENvbnRlbnQpXG4gICAgICAgIC50aGVuKCh1cGxvYWQpID0+IHtcbiAgICAgICAgICByZXR1cm4gdXBsb2FkLmFib3J0KHRydWUpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB1cGxvYWQpXG4gICAgICAgIH0pXG4gICAgICAgIC50aGVuKHZhbGlkYXRlVXBsb2FkRGVsZXRpb24pXG4gICAgfSwgRU5EX1RPX0VORF9USU1FT1VUKVxuXG4gICAgaXQoJ3Nob3VsZCB1cGxvYWQgdG8gYSByZWFsIHR1cyBzZXJ2ZXIgd2l0aCBjcmVhdGlvbi13aXRoLXVwbG9hZCcsIGFzeW5jICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL3R1c2QudHVzZGVtby5uZXQvZmlsZXMvJyxcbiAgICAgICAgICBtZXRhZGF0YToge1xuICAgICAgICAgICAgbm9ubGF0aW46ICdzxYJvxYRjZScsXG4gICAgICAgICAgICBudW1iZXIgIDogMTAwLFxuICAgICAgICAgICAgZmlsZW5hbWU6ICdoZWxsby50eHQnLFxuICAgICAgICAgICAgZmlsZXR5cGU6ICd0ZXh0L3BsYWluJyxcbiAgICAgICAgICB9LFxuICAgICAgICAgIG9uU3VjY2VzcyAoKSB7XG4gICAgICAgICAgICBleHBlY3QodXBsb2FkLnVybCkudG9NYXRjaCgvXmh0dHBzOlxcL1xcL3R1c2RcXC50dXNkZW1vXFwubmV0XFwvZmlsZXNcXC8vKVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1VwbG9hZCBVUkw6JywgdXBsb2FkLnVybCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgICAgICAgIHJlc29sdmUodXBsb2FkKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25FcnJvciAoZXJyKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICAgIH0sXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCBvcHRpb25zKVxuICAgICAgICB1cGxvYWQuc3RhcnQoKVxuICAgICAgfSlcbiAgICAgICAgLnRoZW4odmFsaWRhdGVVcGxvYWRDb250ZW50KVxuICAgIH0sIEVORF9UT19FTkRfVElNRU9VVClcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXBsb2FkQ29udGVudCAodXBsb2FkKSB7XG4gIHJldHVybiBheGlvcy5nZXQodXBsb2FkLnVybClcbiAgICAudGhlbigocmVzKSA9PiB7XG4gICAgICBleHBlY3QocmVzLnN0YXR1cykudG9CZSgyMDApXG4gICAgICBleHBlY3QocmVzLmRhdGEpLnRvQmUoJ2hlbGxvIHdvcmxkJylcblxuICAgICAgcmV0dXJuIHZhbGlkYXRlVXBsb2FkTWV0YWRhdGEodXBsb2FkKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVXBsb2FkTWV0YWRhdGEgKHVwbG9hZCkge1xuICByZXR1cm4gYXhpb3MuaGVhZCh1cGxvYWQudXJsLCB7XG4gICAgaGVhZGVyczoge1xuICAgICAgJ1R1cy1SZXN1bWFibGUnOiAnMS4wLjAnLFxuICAgIH0sXG4gIH0pLnRoZW4oKHJlcykgPT4ge1xuICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDIwMClcbiAgICBleHBlY3QocmVzLmRhdGEpLnRvQmUoJycpXG4gICAgZXhwZWN0KHJlcy5oZWFkZXJzWyd0dXMtcmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICBleHBlY3QocmVzLmhlYWRlcnNbJ3VwbG9hZC1vZmZzZXQnXSkudG9CZSgnMTEnKVxuICAgIGV4cGVjdChyZXMuaGVhZGVyc1sndXBsb2FkLWxlbmd0aCddKS50b0JlKCcxMScpXG5cbiAgICAvLyBUaGUgdmFsdWVzIGluIHRoZSBVcGxvYWQtTWV0YWRhdGEgaGVhZGVyIG1heSBub3QgYmUgaW4gdGhlIHNhbWVcbiAgICAvLyBvcmRlciBhcyB3ZSBzdWJtaXR0ZWQgdGhlbSAodGhlIHNwZWNpZmljYXRpb24gZG9lcyBub3QgcmVxdWlyZVxuICAgIC8vIHRoYXQpLiBUaGVyZWZvcmUsIHdlIHNwbGl0IHRoZSB2YWx1ZXMgYW5kIHZlcmlmeSB0aGF0IGVhY2ggb25lXG4gICAgLy8gaXMgcHJlc2VudC5cbiAgICBjb25zdCBtZXRhZGF0YVN0ciA9IHJlcy5oZWFkZXJzWyd1cGxvYWQtbWV0YWRhdGEnXVxuICAgIGV4cGVjdChtZXRhZGF0YVN0cikudG9CZVRydXRoeSgpXG4gICAgY29uc3QgbWV0YWRhdGEgPSBtZXRhZGF0YVN0ci5zcGxpdCgnLCcpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ2ZpbGVuYW1lIGFHVnNiRzh1ZEhoMCcpXG4gICAgZXhwZWN0KG1ldGFkYXRhKS50b0NvbnRhaW4oJ2ZpbGV0eXBlIGRHVjRkQzl3YkdGcGJnPT0nKVxuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKCdub25sYXRpbiBjOFdDYjhXRVkyVT0nKVxuICAgIGV4cGVjdChtZXRhZGF0YSkudG9Db250YWluKCdudW1iZXIgTVRBdycpXG4gICAgZXhwZWN0KG1ldGFkYXRhLmxlbmd0aCkudG9CZSg0KVxuXG4gICAgcmV0dXJuIHVwbG9hZFxuICB9KVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVVwbG9hZERlbGV0aW9uICh1cGxvYWQpIHtcbiAgcmV0dXJuIGF4aW9zLmdldCh1cGxvYWQudXJsLCB7XG4gICAgdmFsaWRhdGVTdGF0dXM6IChzdGF0dXMpID0+IHN0YXR1cyA9PT0gNDA0LFxuICB9KVxuICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgIGV4cGVjdChyZXMuc3RhdHVzKS50b0JlKDQwNClcblxuICAgICAgcmV0dXJuIHVwbG9hZFxuICAgIH0pXG59XG4iLCJjb25zdCB7IFRlc3RIdHRwU3RhY2ssIHdhaXRhYmxlRnVuY3Rpb24sIHdhaXQsIGdldEJsb2IgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdwYXJhbGxlbCB1cGxvYWRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCB0aHJvdyBpZiBpbmNvbXBhdGlibGUgb3B0aW9ucyBhcmUgdXNlZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCB1cGxvYWQgPSBuZXcgdHVzLlVwbG9hZChmaWxlLCB7XG4gICAgICAgIGVuZHBvaW50ICAgICAgIDogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnLFxuICAgICAgICBwYXJhbGxlbFVwbG9hZHM6IDIsXG4gICAgICAgIHVwbG9hZFVybCAgICAgIDogJ2ZvbycsXG4gICAgICB9KVxuICAgICAgZXhwZWN0KHVwbG9hZC5zdGFydC5iaW5kKHVwbG9hZCkpLnRvVGhyb3dFcnJvcigndHVzOiBjYW5ub3QgdXNlIHRoZSB1cGxvYWRVcmwgb3B0aW9uIHdoZW4gcGFyYWxsZWxVcGxvYWRzIGlzIGVuYWJsZWQnKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHNwbGl0IGEgZmlsZSBpbnRvIG11bHRpcGxlIHBhcnRzIGFuZCBjcmVhdGUgYW4gdXBsb2FkIGZvciBlYWNoJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuXG4gICAgICBjb25zdCB0ZXN0VXJsU3RvcmFnZSA9IHtcbiAgICAgICAgYWRkVXBsb2FkOiAoZmluZ2VycHJpbnQsIHVwbG9hZCkgPT4ge1xuICAgICAgICAgIGV4cGVjdChmaW5nZXJwcmludCkudG9CZSgnZmluZ2VycHJpbnRlZCcpXG4gICAgICAgICAgZXhwZWN0KHVwbG9hZC51cGxvYWRVcmwpLnRvQmVVbmRlZmluZWQoKVxuICAgICAgICAgIGV4cGVjdCh1cGxvYWQuc2l6ZSkudG9CZSgxMSlcbiAgICAgICAgICBleHBlY3QodXBsb2FkLnBhcmFsbGVsVXBsb2FkVXJscykudG9FcXVhbChbXG4gICAgICAgICAgICAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgICAgICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICAgIF0pXG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCd0dXM6OmZpbmdlcnByaW50ZWQ6OjEzMzcnKVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVVcGxvYWQ6ICh1cmxTdG9yYWdlS2V5KSA9PiB7XG4gICAgICAgICAgZXhwZWN0KHVybFN0b3JhZ2VLZXkpLnRvQmUoJ3R1czo6ZmluZ2VycHJpbnRlZDo6MTMzNycpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ3JlbW92ZVVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG4gICAgICBzcHlPbih0ZXN0VXJsU3RvcmFnZSwgJ2FkZFVwbG9hZCcpLmFuZC5jYWxsVGhyb3VnaCgpXG5cbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICAgICAgICAgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgdXJsU3RvcmFnZSAgICAgICAgICAgICAgICAgOiB0ZXN0VXJsU3RvcmFnZSxcbiAgICAgICAgc3RvcmVGaW5nZXJwcmludEZvclJlc3VtaW5nOiB0cnVlLFxuICAgICAgICByZW1vdmVGaW5nZXJwcmludE9uU3VjY2VzcyA6IHRydWUsXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkcyAgICAgICAgICAgIDogMixcbiAgICAgICAgcmV0cnlEZWxheXMgICAgICAgICAgICAgICAgOiBbMTBdLFxuICAgICAgICBlbmRwb2ludCAgICAgICAgICAgICAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgaGVhZGVycyAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgQ3VzdG9tOiAnYmxhcmdoJyxcbiAgICAgICAgfSxcbiAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICBmb286ICdoZWxsbycsXG4gICAgICAgIH0sXG4gICAgICAgIG9uUHJvZ3Jlc3MgKCkge30sXG4gICAgICAgIG9uU3VjY2VzcyAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICAgIGZpbmdlcnByaW50OiAoKSA9PiBQcm9taXNlLnJlc29sdmUoJ2ZpbmdlcnByaW50ZWQnKSxcbiAgICAgIH1cbiAgICAgIHNweU9uKG9wdGlvbnMsICdvblByb2dyZXNzJylcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVycy5DdXN0b20pLnRvQmUoJ2JsYXJnaCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1MZW5ndGgnXSkudG9CZSg1KVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdwYXJ0aWFsJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlVW5kZWZpbmVkKClcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJyxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2FkcycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUE9TVCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDYpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmVVbmRlZmluZWQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcblxuICAgICAgLy8gQXNzZXJ0IHRoYXQgdGhlIFVSTHMgaGF2ZSBiZWVuIHN0b3JlZC5cbiAgICAgIGV4cGVjdCh0ZXN0VXJsU3RvcmFnZS5hZGRVcGxvYWQpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg1KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA1LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKS50b0JlKCdhcHBsaWNhdGlvbi9vZmZzZXQrb2N0ZXQtc3RyZWFtJylcbiAgICAgIGV4cGVjdChyZXEuYm9keS5zaXplKS50b0JlKDYpXG5cbiAgICAgIC8vIFJldHVybiBhbiBlcnJvciB0byBlbnN1cmUgdGhhdCB0aGUgaW5kaXZpZHVhbCBwYXJ0aWFsIHVwbG9hZCBpcyBwcm9wZXJseSByZXRyaWVkLlxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDExLFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMCxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzLkN1c3RvbSkudG9CZSgnYmxhcmdoJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU9mZnNldCddKS50b0JlKDApXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnMuQ3VzdG9tKS50b0JlKCdibGFyZ2gnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmVVbmRlZmluZWQoKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUNvbmNhdCddKS50b0JlKCdmaW5hbDtodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEgaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1NZXRhZGF0YSddKS50b0JlKCdmb28gYUdWc2JHOD0nKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgb3B0aW9ucy5vblN1Y2Nlc3MudG9CZUNhbGxlZFxuXG4gICAgICBleHBlY3QodXBsb2FkLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQzJylcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uUHJvZ3Jlc3MpLnRvSGF2ZUJlZW5DYWxsZWRXaXRoKDUsIDExKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoMTEsIDExKVxuICAgICAgZXhwZWN0KHRlc3RVcmxTdG9yYWdlLnJlbW92ZVVwbG9hZCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgZW1pdCBlcnJvciBmcm9tIGEgcGFydGlhbCB1cGxvYWQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICAgICAgOiB0ZXN0U3RhY2ssXG4gICAgICAgIHBhcmFsbGVsVXBsb2FkczogMixcbiAgICAgICAgcmV0cnlEZWxheXMgICAgOiBudWxsLFxuICAgICAgICBlbmRwb2ludCAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25FcnJvciAgICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCdvbkVycm9yJyksXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ1BPU1QnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVHVzLVJlc3VtYWJsZSddKS50b0JlKCcxLjAuMCcpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtTGVuZ3RoJ10pLnRvQmUoNSlcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICBjb25zdCBlcnIgPSBhd2FpdCBvcHRpb25zLm9uRXJyb3IudG9CZUNhbGxlZFxuICAgICAgZXhwZWN0KGVyci5tZXNzYWdlKS50b0JlKCd0dXM6IHVuZXhwZWN0ZWQgcmVzcG9uc2Ugd2hpbGUgY3JlYXRpbmcgdXBsb2FkLCBvcmlnaW5hdGVkIGZyb20gcmVxdWVzdCAobWV0aG9kOiBQT1NULCB1cmw6IGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMsIHJlc3BvbnNlIGNvZGU6IDUwMCwgcmVzcG9uc2UgdGV4dDogLCByZXF1ZXN0IGlkOiBuL2EpJylcbiAgICAgIGV4cGVjdChlcnIub3JpZ2luYWxSZXF1ZXN0KS50b0JlKHJlcSlcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXN1bWUgdGhlIHBhcnRpYWwgdXBsb2FkcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgLy8gVGhlIGNsaWVudCBzaG91bGQgcmVzdW1lIHRoZSBwYXJhbGxlbCB1cGxvYWRzLCBldmVuIGlmIGl0IGlzIG5vdFxuICAgICAgICAvLyBjb25maWd1cmVkIGZvciBuZXcgdXBsb2Fkcy5cbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAxLFxuICAgICAgICBlbmRwb2ludCAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG5cbiAgICAgIHVwbG9hZC5yZXN1bWVGcm9tUHJldmlvdXNVcGxvYWQoe1xuICAgICAgICB1cmxTdG9yYWdlS2V5ICAgICA6ICd0dXM6OmZpbmdlcnByaW50OjoxMzM3JyxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRVcmxzOiBbXG4gICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScsXG4gICAgICAgICAgJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicsXG4gICAgICAgIF0sXG4gICAgICB9KVxuXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0hFQUQnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1MZW5ndGgnOiA1LFxuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogMixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogNixcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDAsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnUEFUQ0gnKVxuICAgICAgZXhwZWN0KHJlcS5ib2R5LnNpemUpLnRvQmUoMylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNSxcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQyJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG4gICAgICBleHBlY3QocmVxLmJvZHkuc2l6ZSkudG9CZSg2KVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwNCxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgnZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgYWJvcnQgYWxsIHBhcnRpYWwgdXBsb2FkcyBhbmQgcmVzdW1lIGZyb20gdGhlbScsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IGZpbGUgPSBnZXRCbG9iKCdoZWxsbyB3b3JsZCcpXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBodHRwU3RhY2sgICAgICA6IHRlc3RTdGFjayxcbiAgICAgICAgcGFyYWxsZWxVcGxvYWRzOiAyLFxuICAgICAgICBlbmRwb2ludCAgICAgICA6ICdodHRwczovL3R1cy5pby91cGxvYWRzJyxcbiAgICAgICAgb25Qcm9ncmVzcyAoKSB7fSxcbiAgICAgICAgb25TdWNjZXNzICAgICAgOiB3YWl0YWJsZUZ1bmN0aW9uKCksXG4gICAgICAgIGZpbmdlcnByaW50ICAgIDogKCkgPT4gUHJvbWlzZS5yZXNvbHZlKCdmaW5nZXJwcmludGVkJyksXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25Qcm9ncmVzcycpXG5cbiAgICAgIGNvbnN0IHVwbG9hZCA9IG5ldyB0dXMuVXBsb2FkKGZpbGUsIG9wdGlvbnMpXG4gICAgICB1cGxvYWQuc3RhcnQoKVxuXG4gICAgICBsZXQgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDUpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmVVbmRlZmluZWQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDEnLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlKDYpXG4gICAgICBleHBlY3QocmVxLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtQ29uY2F0J10pLnRvQmUoJ3BhcnRpYWwnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLU1ldGFkYXRhJ10pLnRvQmVVbmRlZmluZWQoKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXMgICAgICAgICA6IDIwMSxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzOiB7XG4gICAgICAgICAgTG9jYXRpb246ICdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDInLFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgY29uc3QgcmVxMSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxMS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMScpXG4gICAgICBleHBlY3QocmVxMS5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXExLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXExLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXExLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxMS5ib2R5LnNpemUpLnRvQmUoNSlcblxuICAgICAgY29uc3QgcmVxMiA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxMi51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxMi5tZXRob2QpLnRvQmUoJ1BBVENIJylcbiAgICAgIGV4cGVjdChyZXEyLnJlcXVlc3RIZWFkZXJzWydUdXMtUmVzdW1hYmxlJ10pLnRvQmUoJzEuMC4wJylcbiAgICAgIGV4cGVjdChyZXEyLnJlcXVlc3RIZWFkZXJzWydVcGxvYWQtT2Zmc2V0J10pLnRvQmUoMClcbiAgICAgIGV4cGVjdChyZXEyLnJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXSkudG9CZSgnYXBwbGljYXRpb24vb2Zmc2V0K29jdGV0LXN0cmVhbScpXG4gICAgICBleHBlY3QocmVxMi5ib2R5LnNpemUpLnRvQmUoNilcblxuICAgICAgdXBsb2FkLmFib3J0KClcblxuICAgICAgcmVxMS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEyLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtT2Zmc2V0JzogNixcbiAgICAgICAgfSxcbiAgICAgIH0pXG5cbiAgICAgIC8vIE5vIGZ1cnRoZXIgcmVxdWVzdHMgc2hvdWxkIGJlIHNlbnQuXG4gICAgICBjb25zdCByZXFQcm9taXNlID0gdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmFjZShbXG4gICAgICAgIHJlcVByb21pc2UsXG4gICAgICAgIHdhaXQoMTAwKSxcbiAgICAgIF0pXG4gICAgICBleHBlY3QocmVzdWx0KS50b0JlKCd0aW1lZCBvdXQnKVxuXG4gICAgICAvLyBSZXN0YXJ0IHRoZSB1cGxvYWRcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIC8vIFJldXNlIHRoZSBwcm9taXNlIGZyb20gYmVmb3JlIGFzIGl0IGlzIG5vdCBjYW5jZWxsZWQuXG4gICAgICByZXEgPSBhd2FpdCByZXFQcm9taXNlXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdIRUFEJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDQsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgICdVcGxvYWQtTGVuZ3RoJzogNSxcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnSEVBRCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLUxlbmd0aCc6IDYsXG4gICAgICAgICAgJ1VwbG9hZC1PZmZzZXQnOiA2LFxuICAgICAgICB9LFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1R1cy1SZXN1bWFibGUnXSkudG9CZSgnMS4wLjAnKVxuICAgICAgZXhwZWN0KHJlcS5yZXF1ZXN0SGVhZGVyc1snVXBsb2FkLUxlbmd0aCddKS50b0JlVW5kZWZpbmVkKClcbiAgICAgIGV4cGVjdChyZXEucmVxdWVzdEhlYWRlcnNbJ1VwbG9hZC1Db25jYXQnXSkudG9CZSgnZmluYWw7aHR0cHM6Ly90dXMuaW8vdXBsb2Fkcy91cGxvYWQxIGh0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMicpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjAxLFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICBMb2NhdGlvbjogJ2h0dHBzOi8vdHVzLmlvL3VwbG9hZHMvdXBsb2FkMycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICBhd2FpdCBvcHRpb25zLm9uU3VjY2Vzcy50b0JlQ2FsbGVkXG5cbiAgICAgIGV4cGVjdCh1cGxvYWQudXJsKS50b0JlKCdodHRwczovL3R1cy5pby91cGxvYWRzL3VwbG9hZDMnKVxuICAgICAgZXhwZWN0KG9wdGlvbnMub25Qcm9ncmVzcykudG9IYXZlQmVlbkNhbGxlZFdpdGgoNSwgMTEpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vblByb2dyZXNzKS50b0hhdmVCZWVuQ2FsbGVkV2l0aCgxMSwgMTEpXG4gICAgfSlcbiAgfSlcbn0pXG4iLCJjb25zdCB7IFRlc3RIdHRwU3RhY2ssIGdldEJsb2IgfSA9IHJlcXVpcmUoJy4vaGVscGVycy91dGlscycpXG5jb25zdCB0dXMgPSByZXF1aXJlKCcuLi8uLicpXG5cbmRlc2NyaWJlKCd0dXMnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCd0ZXJtaW5hdGUgdXBsb2FkJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgdGVybWluYXRlIHVwbG9hZCB3aGVuIGFib3J0IGlzIGNhbGxlZCB3aXRoIHRydWUnLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWJvcnRQcm9taXNlXG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrOiB0ZXN0U3RhY2ssXG4gICAgICAgIGVuZHBvaW50IDogJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJyxcbiAgICAgICAgY2h1bmtTaXplOiA1LFxuICAgICAgICBvbkNodW5rQ29tcGxldGUgKCkge1xuICAgICAgICAgIGFib3J0UHJvbWlzZSA9IHVwbG9hZC5hYm9ydCh0cnVlKVxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDIwNCxcbiAgICAgIH0pXG5cbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQ2h1bmtDb21wbGV0ZSkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBhd2FpdCBhYm9ydFByb21pc2VcbiAgICB9KVxuXG4gICAgaXQoJ3Nob3VsZCByZXRyeSB0ZXJtaW5hdGUgd2hlbiBhbiBlcnJvciBpcyByZXR1cm5lZCBvbiBmaXJzdCB0cnknLCBhc3luYyAoKSA9PiB7XG4gICAgICBsZXQgYWJvcnRQcm9taXNlXG4gICAgICBjb25zdCB0ZXN0U3RhY2sgPSBuZXcgVGVzdEh0dHBTdGFjaygpXG4gICAgICBjb25zdCBmaWxlID0gZ2V0QmxvYignaGVsbG8gd29ybGQnKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgZW5kcG9pbnQgICA6ICdodHRwOi8vdHVzLmlvL2ZpbGVzLycsXG4gICAgICAgIGNodW5rU2l6ZSAgOiA1LFxuICAgICAgICByZXRyeURlbGF5czogWzEwLCAxMCwgMTBdLFxuICAgICAgICBvbkNodW5rQ29tcGxldGUgKCkge1xuICAgICAgICAgIGFib3J0UHJvbWlzZSA9IHVwbG9hZC5hYm9ydCh0cnVlKVxuICAgICAgICB9LFxuICAgICAgfVxuXG4gICAgICBzcHlPbihvcHRpb25zLCAnb25DaHVua0NvbXBsZXRlJykuYW5kLmNhbGxUaHJvdWdoKClcblxuICAgICAgY29uc3QgdXBsb2FkID0gbmV3IHR1cy5VcGxvYWQoZmlsZSwgb3B0aW9ucylcbiAgICAgIHVwbG9hZC5zdGFydCgpXG5cbiAgICAgIGxldCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQT1NUJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzICAgICAgICAgOiAyMDEsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVyczoge1xuICAgICAgICAgIExvY2F0aW9uOiAnL2ZpbGVzL2ZvbycsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdQQVRDSCcpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1cyAgICAgICAgIDogMjA0LFxuICAgICAgICByZXNwb25zZUhlYWRlcnM6IHtcbiAgICAgICAgICAnVXBsb2FkLU9mZnNldCc6IDUsXG4gICAgICAgIH0sXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDQyMyxcbiAgICAgIH0pXG5cbiAgICAgIHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgYWJvcnRQcm9taXNlXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkNodW5rQ29tcGxldGUpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG5cbiAgICBpdCgnc2hvdWxkIHN0b3AgcmV0cnlpbmcgd2hlbiBhbGwgZGVsYXlzIGFyZSB1c2VkIHVwJywgYXN5bmMgKCkgPT4ge1xuICAgICAgY29uc3QgdGVzdFN0YWNrID0gbmV3IFRlc3RIdHRwU3RhY2soKVxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgaHR0cFN0YWNrICA6IHRlc3RTdGFjayxcbiAgICAgICAgcmV0cnlEZWxheXM6IFsxMCwgMTBdLFxuICAgICAgfVxuXG4gICAgICBjb25zdCB0ZXJtaW5hdGVQcm9taXNlID0gdHVzLlVwbG9hZC50ZXJtaW5hdGUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJywgb3B0aW9ucylcblxuICAgICAgbGV0IHJlcSA9IGF3YWl0IHRlc3RTdGFjay5uZXh0UmVxdWVzdCgpXG4gICAgICBleHBlY3QocmVxLnVybCkudG9CZSgnaHR0cDovL3R1cy5pby9maWxlcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgfSlcblxuICAgICAgcmVxID0gYXdhaXQgdGVzdFN0YWNrLm5leHRSZXF1ZXN0KClcbiAgICAgIGV4cGVjdChyZXEudXJsKS50b0JlKCdodHRwOi8vdHVzLmlvL2ZpbGVzL2ZvbycpXG4gICAgICBleHBlY3QocmVxLm1ldGhvZCkudG9CZSgnREVMRVRFJylcblxuICAgICAgcmVxLnJlc3BvbmRXaXRoKHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICB9KVxuXG4gICAgICByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vZmlsZXMvZm9vJylcbiAgICAgIGV4cGVjdChyZXEubWV0aG9kKS50b0JlKCdERUxFVEUnKVxuXG4gICAgICByZXEucmVzcG9uZFdpdGgoe1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgIH0pXG5cbiAgICAgIGF3YWl0IGV4cGVjdEFzeW5jKHRlcm1pbmF0ZVByb21pc2UpLnRvQmVSZWplY3RlZFdpdGhFcnJvcigvdHVzOiB1bmV4cGVjdGVkIHJlc3BvbnNlIHdoaWxlIHRlcm1pbmF0aW5nIHVwbG9hZC8pXG4gICAgfSlcblxuICAgIGl0KCdzaG91bGQgaW52b2tlIHRoZSByZXF1ZXN0IGFuZCByZXNwb25zZSBQcm9taXNlcycsIGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IHRlc3RTdGFjayA9IG5ldyBUZXN0SHR0cFN0YWNrKClcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIGh0dHBTdGFjazogdGVzdFN0YWNrLFxuICAgICAgICBvbkJlZm9yZVJlcXVlc3QgKHJlcSkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0VVJMKCkpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgICAgICAgZXhwZWN0KHJlcS5nZXRNZXRob2QoKSkudG9CZSgnREVMRVRFJylcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG9uQWZ0ZXJSZXNwb25zZSAocmVxLCByZXMpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBleHBlY3QocmVxLmdldFVSTCgpKS50b0JlKCdodHRwOi8vdHVzLmlvL3VwbG9hZHMvZm9vJylcbiAgICAgICAgICAgIGV4cGVjdChyZXEuZ2V0TWV0aG9kKCkpLnRvQmUoJ0RFTEVURScpXG4gICAgICAgICAgICBleHBlY3QocmVzLmdldFN0YXR1cygpKS50b0JlKDIwNClcbiAgICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICB9XG4gICAgICBzcHlPbihvcHRpb25zLCAnb25CZWZvcmVSZXF1ZXN0JylcbiAgICAgIHNweU9uKG9wdGlvbnMsICdvbkFmdGVyUmVzcG9uc2UnKVxuXG4gICAgICBjb25zdCB0ZXJtaW5hdGVQcm9taXNlID0gdHVzLlVwbG9hZC50ZXJtaW5hdGUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nLCBvcHRpb25zKVxuXG4gICAgICBjb25zdCByZXEgPSBhd2FpdCB0ZXN0U3RhY2submV4dFJlcXVlc3QoKVxuICAgICAgZXhwZWN0KHJlcS51cmwpLnRvQmUoJ2h0dHA6Ly90dXMuaW8vdXBsb2Fkcy9mb28nKVxuICAgICAgZXhwZWN0KHJlcS5tZXRob2QpLnRvQmUoJ0RFTEVURScpXG5cbiAgICAgIHJlcS5yZXNwb25kV2l0aCh7XG4gICAgICAgIHN0YXR1czogMjA0LFxuICAgICAgfSlcblxuICAgICAgYXdhaXQgZXhwZWN0QXN5bmModGVybWluYXRlUHJvbWlzZSkudG9CZVJlc29sdmVkKClcbiAgICAgIGV4cGVjdChvcHRpb25zLm9uQmVmb3JlUmVxdWVzdCkudG9IYXZlQmVlbkNhbGxlZCgpXG4gICAgICBleHBlY3Qob3B0aW9ucy5vbkFmdGVyUmVzcG9uc2UpLnRvSGF2ZUJlZW5DYWxsZWQoKVxuICAgIH0pXG4gIH0pXG59KVxuIl19
